import{a as b}from"./react-core-D6cE4lil.js";const H=t=>{let s;const e=new Set,o=(i,h)=>{const v=typeof i=="function"?i(s):i;if(!Object.is(v,s)){const g=s;s=h??(typeof v!="object"||v===null)?v:Object.assign({},s,v),e.forEach(m=>m(s,g))}},a=()=>s,u={setState:o,getState:a,getInitialState:()=>d,subscribe:i=>(e.add(i),()=>e.delete(i))},d=s=t(o,a,u);return u},R=(t=>t?H(t):H),k=t=>t;function w(t,s=k){const e=b.useSyncExternalStore(t.subscribe,b.useCallback(()=>s(t.getState()),[t,s]),b.useCallback(()=>s(t.getInitialState()),[t,s]));return b.useDebugValue(e),e}const O=t=>{const s=R(t),e=o=>w(s,o);return Object.assign(e,s),e},F=(t=>t?O(t):O);function E(t,s){let e;try{e=t()}catch{return}return{getItem:a=>{var r;const f=d=>d===null?null:JSON.parse(d,void 0),u=(r=e.getItem(a))!=null?r:null;return u instanceof Promise?u.then(f):f(u)},setItem:(a,r)=>e.setItem(a,JSON.stringify(r,void 0)),removeItem:a=>e.removeItem(a)}}const I=t=>s=>{try{const e=t(s);return e instanceof Promise?e:{then(o){return I(o)(e)},catch(o){return this}}}catch(e){return{then(o){return this},catch(o){return I(o)(e)}}}},x=(t,s)=>(e,o,a)=>{let r={storage:E(()=>localStorage),partialize:n=>n,version:0,merge:(n,S)=>({...S,...n}),...s},f=!1;const u=new Set,d=new Set;let i=r.storage;if(!i)return t((...n)=>{e(...n)},o,a);const h=()=>{const n=r.partialize({...o()});return i.setItem(r.name,{state:n,version:r.version})},v=a.setState;a.setState=(n,S)=>(v(n,S),h());const g=t((...n)=>(e(...n),h()),o,a);a.getInitialState=()=>g;let m;const _=()=>{var n,S;if(!i)return;f=!1,u.forEach(c=>{var l;return c((l=o())!=null?l:g)});const y=((S=r.onRehydrateStorage)==null?void 0:S.call(r,(n=o())!=null?n:g))||void 0;return I(i.getItem.bind(i))(r.name).then(c=>{if(c)if(typeof c.version=="number"&&c.version!==r.version){if(r.migrate){const l=r.migrate(c.state,c.version);return l instanceof Promise?l.then(p=>[!0,p]):[!0,l]}}else return[!1,c.state];return[!1,void 0]}).then(c=>{var l;const[p,j]=c;if(m=r.merge(j,(l=o())!=null?l:g),e(m,!0),p)return h()}).then(()=>{y?.(m,void 0),m=o(),f=!0,d.forEach(c=>c(m))}).catch(c=>{y?.(void 0,c)})};return a.persist={setOptions:n=>{r={...r,...n},n.storage&&(i=n.storage)},clearStorage:()=>{i?.removeItem(r.name)},getOptions:()=>r,rehydrate:()=>_(),hasHydrated:()=>f,onHydrate:n=>(u.add(n),()=>{u.delete(n)}),onFinishHydration:n=>(d.add(n),()=>{d.delete(n)})},r.skipHydration||_(),m||g},J=x;export{F as c,J as p};
