async function C(){const e=await crypto.subtle.generateKey({name:"ECDH",namedCurve:"P-256"},!0,["deriveKey","deriveBits"]);return{publicKey:await u(e.publicKey),privateKey:await p(e.privateKey)}}async function P(e,t){const r=await crypto.subtle.generateKey({name:"ECDH",namedCurve:"P-256"},!0,["deriveKey","deriveBits"]),n=await K(r.publicKey),i=await m(n);return{keyId:e,publicKey:await u(r.publicKey),privateKey:await p(r.privateKey),signature:a(i)}}async function S(e=100){const t=[];for(let r=0;r<e;r++){const n=await crypto.subtle.generateKey({name:"ECDH",namedCurve:"P-256"},!0,["deriveKey","deriveBits"]);t.push({keyId:r,publicKey:await u(n.publicKey),privateKey:await p(n.privateKey)})}return t}async function u(e){const t=await crypto.subtle.exportKey("jwk",e);return JSON.stringify(t)}async function p(e){const t=await crypto.subtle.exportKey("jwk",e);return JSON.stringify(t)}async function K(e){return await crypto.subtle.exportKey("raw",e)}async function w(e){const t=JSON.parse(e);return await crypto.subtle.importKey("jwk",t,{name:"ECDH",namedCurve:"P-256"},!0,[])}async function g(e){const t=JSON.parse(e);return await crypto.subtle.importKey("jwk",t,{name:"ECDH",namedCurve:"P-256"},!0,["deriveKey","deriveBits"])}async function m(e,t){const r=await crypto.subtle.generateKey({name:"ECDSA",namedCurve:"P-256"},!1,["sign","verify"]);return await crypto.subtle.sign({name:"ECDSA",hash:{name:"SHA-256"}},r.privateKey,e)}async function A(e,t){const r=await l(t),n=crypto.getRandomValues(new Uint8Array(12)),i=await crypto.subtle.encrypt({name:"AES-GCM",iv:n},r,b(e));return{ciphertext:a(i),iv:a(n)}}async function k(e,t,r){const n=await l(r),i=await crypto.subtle.decrypt({name:"AES-GCM",iv:y(t)},n,y(e));return v(i)}async function x(e,t){const r=await g(e),n=await w(t),i=await crypto.subtle.deriveBits({name:"ECDH",public:n},r,256);return a(i)}async function l(e){const t=y(e),r=await crypto.subtle.importKey("raw",t,"HKDF",!1,["deriveKey"]);return await crypto.subtle.deriveKey({name:"HKDF",hash:"SHA-256",salt:new Uint8Array([]),info:new Uint8Array([])},r,{name:"AES-GCM",length:256},!1,["encrypt","decrypt"])}function B(e,t,r){return{rootKey:r,sendingChainKey:null,receivingChainKey:null,sendCounter:0,receiveCounter:0,myRatchetPrivateKey:e,theirRatchetPublicKey:t}}async function _(e,t){if(t==="send"){e.sendCounter++;const r=await s(e.sendingChainKey||e.rootKey);e.sendingChainKey=r}else{e.receiveCounter++;const r=await s(e.receivingChainKey||e.rootKey);e.receivingChainKey=r}return e}async function E(e,t){const r=e+t,n=await s(r);return h(n).split("").map(c=>parseInt(c,16).toString()).join("").substring(0,60).match(/.{1,5}/g).join(" ")}async function D(e){const t=await crypto.subtle.generateKey({name:"AES-GCM",length:256},!0,["encrypt","decrypt"]),r=await e.arrayBuffer(),n=crypto.getRandomValues(new Uint8Array(12)),i=await crypto.subtle.encrypt({name:"AES-GCM",iv:n},t,r),o=await crypto.subtle.exportKey("jwk",t);return{encryptedFile:new Blob([i],{type:"application/octet-stream"}),fileKey:JSON.stringify(o),iv:a(n),originalFilename:e.name,originalMimeType:e.type}}async function j(e,t,r,n,i){const o=JSON.parse(t),c=await crypto.subtle.importKey("jwk",o,{name:"AES-GCM",length:256},!1,["decrypt"]),d=await e.arrayBuffer(),f=await crypto.subtle.decrypt({name:"AES-GCM",iv:y(r)},c,d);return new File([f],n,{type:i})}function b(e){return new TextEncoder().encode(e)}function v(e){return new TextDecoder().decode(e)}function a(e){const t=new Uint8Array(e);let r="";for(let n=0;n<t.byteLength;n++)r+=String.fromCharCode(t[n]);return btoa(r)}function y(e){const t=atob(e),r=new Uint8Array(t.length);for(let n=0;n<t.length;n++)r[n]=t.charCodeAt(n);return r.buffer}function h(e){const t=new Uint8Array(e);return Array.from(t).map(r=>r.toString(16).padStart(2,"0")).join("")}async function s(e){const t=new TextEncoder,r=typeof e=="string"?t.encode(e):e;return await crypto.subtle.digest("SHA-256",r)}async function H(e,t,r){try{return localStorage.setItem(`e2ee_identity_private_${e}`,t),localStorage.setItem(`e2ee_signed_pre_key_private_${e}`,r),localStorage.setItem(`e2ee_keys_timestamp_${e}`,Date.now().toString()),!0}catch(n){throw n}}async function M(e){try{const t=localStorage.getItem(`e2ee_identity_private_${e}`),r=localStorage.getItem(`e2ee_signed_pre_key_private_${e}`),n=localStorage.getItem(`e2ee_keys_timestamp_${e}`);return!t||!r?null:{username:e,identityPrivateKey:t,signedPreKeyPrivateKey:r,timestamp:parseInt(n)}}catch{return null}}async function I(e,t,r){try{const n=await r(`${e}/e2ee/pre-key-bundle/${t}/`);if(!n.ok)throw new Error(`Failed to fetch public keys: ${n.status}`);return await n.json()}catch(n){throw n}}export{j as decryptFile,k as decryptMessage,x as deriveSharedSecret,D as encryptFile,A as encryptMessage,I as fetchUserPublicKeys,C as generateIdentityKeyPair,S as generateOneTimePreKeys,E as generateSafetyNumber,P as generateSignedPreKeyPair,M as getPrivateKeys,B as initializeRatchet,_ as ratchetForward,H as storePrivateKeys};
