const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["static/js/crypto-vendor-NANfm9jb.js","static/js/react-core-BiY6fgAJ.js","static/js/CinemaModal-BvqRSqV8.js","static/js/media-vendor-BRMiuG2Y.js","static/js/icons-vendor-2VDeY8fW.js","static/js/CryptoChartModal-DVo8Azj1.js","static/js/GifPicker-DRHla4ZE.js","static/js/StickerPicker-D4KgwPIx.js","static/js/UserProfilePanel-D7peylHI.js","static/js/AvatarCropper-fmvEo3gX.js","static/css/AvatarCropper-B5grqd2m.css","static/js/LogoutModal-B4uPtFZv.js","static/css/LogoutModal-DwEIUg4y.css","static/js/index-BnLT0o6q.js","static/js/router-vendor-DrLUSS4j.js","static/js/state-vendor-BeEHnF_A.js","static/js/ui-vendor-iPoN0WGz.js","static/css/UserProfilePanel-hcmyn62x.css","static/js/AdminAnalyticsPanel-CeHNI74W.js","static/js/chart-vendor-4kC5cP2G.js","static/js/AdminPanelModal-CprLW31R.js","static/js/APIUsagePanel-BhDcZw3C.js","static/js/AutoModerationDashboard-Db2Mj8kJ.js","static/js/AuditLogPanel-DKJ2GZ5a.js","static/js/BookmarkPanel-kyNJY0U5.js","static/js/ChannelPermissionsPanel-EZYXCMYg.js","static/js/CodeSnippetModal-C61Oq3Pi.js","static/js/ConnectionsPanel-DzEFgQYY.js","static/css/ConnectionsPanel-BeOx6Y5A.css","static/js/CreateGroupModal-D_BiSitZ.js","static/js/CustomStatusModal-BWrL755S.js","static/js/DJModal-CAGaD54L.js","static/js/DailyRewardsModal-DQvOn490.js","static/js/DownloadModal-BmcJJ7ja.js","static/js/EncryptionKeyModal-C_s13e4y.js","static/js/ExportJobsPanel-BObQVuFH.js","static/js/MentionsInboxPanel-DZelkw8n.js","static/js/PasswordSetupModal-BTysGNpv.js","static/css/PasswordSetupModal-B1u1ziPo.css","static/js/PaymentPanel-By60yAWw.js","static/js/PollCreateModal-C0kTUS7Q.js","static/js/PremiumStoreModal-B9JTzr57.js","static/js/CoinStoreModal-BXmYuior.js","static/js/RaidProtectionPanel-DhzCOH3b.js","static/js/ReadLaterPanel-Bv7aDtH4.js","static/css/ReadLaterPanel-CWRWmI5W.css","static/js/ReportSystemPanel-C0VgbCF_.js","static/js/ScheduledAnnouncementsPanel-CyYd5qX7.js","static/js/ServerSettingsModal-DMBbz04j.js","static/js/AutoResponderManager-BT8eR5cy.js","static/js/VanityURLManager-DYHHPB97.js","static/js/SoundboardModal-BALiP7O-.js","static/js/StoreModal-Di58Ahiv.js","static/js/UserWarningsPanel-BPP8cjTU.js","static/js/WebhooksPanel-boei-7OV.js","static/css/WebhooksPanel-Dm1aL9cH.css","static/js/WhiteboardModal-BmKnXb_l.js","static/js/AdvancedSearchPanel-CWVX6Gip.js","static/js/AutoRespondersPanel-Dtllx_ff.js","static/js/AvatarStudioPanel-BrYOZdmz.js","static/js/ContentScannerPanel-Jxgf5LVl.js","static/js/DataRetentionPanel-Cbh_IIND.js","static/js/DraftsPanel-C-IbIfeO.js","static/js/EnhancedPollsPanel-BJ8sk77f.js","static/js/EphemeralMessagesPanel-C8rcuC5s.js","static/js/FieldChangeTrackingPanel--c_3LXa0.js","static/js/GDPRExportPanel-qSc0bx78.js","static/js/GrowthMetricsPanel-BSJUjD9b.js","static/js/InventoryPanel-B2sfU6fc.js","static/js/InviteAnalyticsPanel-BBESM7ym.js","static/js/InviteExportPanel-BeoQqWK9.js","static/js/JoinLeaveLogsPanel-Dtt005vw.js","static/js/LinkClickTrackingPanel-6FH16-Tn.js","static/js/LinkPreviewRenderer-C2LxW31e.js","static/js/MiniGamesPanel-C4JjnWMa.js","static/js/NicknameHistoryPanel-B-Wz69Sw.js","static/js/OAuthAppsPanel-Bu2YklTp.js","static/js/ProjectCollaborationPanel-DPbhuILk.js","static/js/ReactionAnalyticsPanel-BCFjvPIf.js","static/js/ReferralRewardsPanel-BbCOHbxH.js","static/js/RoomWebhooksPanel-B_fsIFRY.js","static/js/ServerBoostPanel-CEJjoMfa.js","static/js/ServerNicknamesPanel-GPlrKIyh.js","static/js/SessionManagementPanel-CMnZlXbZ.js","static/js/TopicHistoryPanel-C2MBkrQu.js","static/js/TwoFactorSetupWizard-CK1qKlxA.js","static/js/UserActivityPanel-CD0qRsam.js","static/js/VoiceTranscriptsPanel-CTXnGgYn.js","static/js/WaitlistPanel-B1K8-3rl.js","static/js/AccountDeletionModal-Bw4ik5gg.js","static/js/AchievementsPanel-B8dUoq52.js","static/css/AchievementsPanel-Zd4255Ih.css","static/js/AppearanceSettingsPanel-Bxj7cLbI.js","static/css/AppearanceSettingsPanel-s3bL8ESV.css","static/js/AutoRolesPanel-B28K5HKh.js","static/css/AutoRolesPanel-DxC-PeD1.css","static/js/BanAppealsPanel-BmWzFlW5.js","static/css/BanAppealsPanel-8tjH89uY.css","static/js/BirthdaySystemPanel-2i_s6nJU.js","static/css/BirthdaySystemPanel-BWn-tbcZ.css","static/js/BlockListPanel-fyPAXRqO.js","static/css/BlockListPanel-BFt9HwVv.css","static/js/BotMarketplace-DecUc5NP.js","static/css/BotMarketplace-BB8J3qkh.css","static/js/ChangelogPanel-Ch212w6j.js","static/css/ChangelogPanel-DEVkOz5c.css","static/js/CommandPalette-DEX-h-w2.js","static/css/CommandPalette-gTXDS_Vo.css","static/js/CustomCommandsPanel-HP4Ptsd_.js","static/css/CustomCommandsPanel-DDkLHWOq.css","static/js/CustomEmbedPanel-B2YjOp0-.js","static/css/CustomEmbedPanel-BOoDphgJ.css","static/js/E2EESettingsPanel-Bu2xjuVt.js","static/js/EventCalendar-CqWzHANE.js","static/js/ForumPanel-Cg4YKtbe.js","static/css/ForumPanel-CTAQYOZ0.css","static/js/GiveawayPanel-WTAKnx-f.js","static/css/GiveawayPanel-Djgzukrw.css","static/js/HighlightsPanel-cZ0rYJ9P.js","static/js/purify.es-BRhsgAzF.js","static/css/HighlightsPanel-DlZmw4UZ.css","static/js/IntegrationHubPanel-DvU2UgBp.js","static/css/IntegrationHubPanel--drmkV8M.css","static/js/KeyboardShortcutsModal-D5GaGFa_.js","static/js/LanguageSelector-O70Km-tX.js","static/css/LanguageSelector-DcVau2qJ.css","static/js/LevelingSystemPanel-D_GpIthE.js","static/css/LevelingSystemPanel-C_FXlunk.css","static/js/LiveStreamPanel-Bs4ri7Ey.js","static/js/LoginHistory-C2fgibfc.js","static/js/MessageSearchPanel-BgdC1osD.js","static/css/MessageSearchPanel-CPu5SIS7.css","static/js/MusicPlayer-DGaj7k61.js","static/css/MusicPlayer-C88a977c.css","static/js/NotificationSoundSettings-DWpAJxaO.js","static/js/PremiumModal-CFE1Dd0q.js","static/js/PrivacySettingsPanel-CfZaaSFf.js","static/css/PrivacySettingsPanel-CP1TWhkR.css","static/js/ProfileCustomization-BJfYgMpH.js","static/js/QuickSwitcher-XwmF63EV.js","static/css/QuickSwitcher-BnhorxOA.css","static/js/ReactionRolesPanel-D9_ZU0aX.js","static/css/ReactionRolesPanel-CXadD0zi.css","static/js/ReminderPanel-Dkvw-jRV.js","static/css/ReminderPanel-BqJ-8PKi.css","static/js/ScheduledMessagesPanel-D2KwFkyN.js","static/css/ScheduledMessagesPanel-DKMj-MEX.css","static/js/SecuritySettingsPanel-DVstCrkd.js","static/css/SecuritySettingsPanel-BE_i2Uic.css","static/js/ServerBackupPanel-CJnjsjcp.js","static/css/ServerBackupPanel-DB6S-tSL.css","static/js/ServerClonePanel-BD8f7Ard.js","static/css/ServerClonePanel-CW0I2jVI.css","static/js/ServerDiscoveryPage-hE-IdVfX.js","static/css/ServerDiscoveryPage-Ccsl5j5I.css","static/js/SpotifyIntegrationPanel-Bx1vw9y7.js","static/css/SpotifyIntegrationPanel-C48eNhVk.css","static/js/StageChannelPanel-B0CEZ-9H.js","static/css/StageChannelPanel-BVSC7gAO.css","static/js/StarboardPanel-BIXtfAjI.js","static/css/StarboardPanel-BXquJFAO.css","static/js/ThreadView-709GrGDB.js","static/js/TicketSystemPanel-BPfHSwkW.js","static/css/TicketSystemPanel-DW1Sy8hJ.css","static/js/TournamentSystem-DSbIJJ6b.js","static/js/UserSettingsModal-d0UikIEa.js","static/js/VideoCallModal-BCiQHGBX.js","static/js/VoiceSettingsPanel-C5MXlqa8.js","static/css/VoiceSettingsPanel-CdeXhvhr.css","static/js/index-CKlHPrBa.js","static/css/index-mHMR2Ikj.css","static/js/WeeklyChallengesPanel-B-Lahrgc.js","static/js/WelcomeMessagesPanel-DRgKL7i_.js","static/css/WelcomeMessagesPanel-CpLhfa76.css","static/js/AIChatbotPanel-v3Gxxsz6.js","static/css/AIChatbotPanel-j1ZdcASx.css","static/js/AIModerationPanel-vfmBCrZG.js","static/js/APIKeysPanel-CPNZkykh.js","static/js/AdvancedAnalyticsDashboard-D9W-7shq.js","static/css/AdvancedAnalyticsDashboard-BRVYQ8Kb.css","static/js/AuditLogsPanel-CtPAYxni.js","static/css/AuditLogsPanel-CLqBOg8U.css","static/js/BanHistoryPanel-D1pPc2TA.js","static/css/BanHistoryPanel-DYGjxN02.css","static/js/BotBuilder-DGAydBnn.js","static/js/BotDeveloperPortal-B00QB35w.js","static/css/BotDeveloperPortal-XZXr4YGK.css","static/js/ChannelSettingsModal-DwVgGmfD.js","static/js/CodeRunnerPanel-D6xXG7GF.js","static/css/CodeRunnerPanel-DvxO-6sg.css","static/js/CollaborativeCodeEditor-BOj76Z7l.js","static/js/CommunitySettingsPanel-BGghaQk8.js","static/css/CommunitySettingsPanel-BWBZnWty.css","static/js/ErrorReportingPanel-8oIX-fRe.js","static/css/ErrorReportingPanel-C2LK4zzy.css","static/js/FileManagerPanel-6a83_Su6.js","static/js/GIFPickerPanel-DISPZZsY.js","static/css/GIFPickerPanel-BnzbtpjE.css","static/js/GiftPremiumPanel-l_N0_Kh-.js","static/css/GiftPremiumPanel-D8f5PuaU.css","static/js/InviteLinkManager-wWUK3P0I.js","static/js/InviteModal-DPRjeSOT.js","static/js/LiveStreamModal-BwuP4i75.js","static/js/MessageSummaryPanel-BTf00WRi.js","static/css/MessageSummaryPanel-b13X14kk.css","static/js/ModerationLogsPanel-D51Q_nGQ.js","static/css/ModerationLogsPanel-BsScH8fV.css","static/js/ModeratorTools-CH2elA1l.js","static/js/MutualsPanel-_u7esGII.js","static/css/MutualsPanel-BFA5c4BZ.css","static/js/NotificationsCenter-DHIfAzy6.js","static/css/NotificationsCenter-BJ8ycbcR.css","static/js/PollCreator-DXbc-BVW.js","static/js/PremiumManagementPanel-BVE-3EVU.js","static/css/PremiumManagementPanel-CzAJWjdm.css","static/js/PremiumMarketplace-S1HoIffv.js","static/css/PremiumMarketplace-DTWgmBWi.css","static/js/ProfileCard-C32OLjCf.js","static/css/ProfileCard-BxZzz-TD.css","static/js/ProfileShowcasePanel-U803Ucns.js","static/css/ProfileShowcasePanel-Bl4Od9EN.css","static/js/ReportsPanel-Df1R0ORo.js","static/css/ReportsPanel-CflyNfRE.css","static/js/RolesManager-i2vrls0B.js","static/css/RolesManager-BoZd8r5k.css","static/js/SavedMessagesModal-CIhVFKdF.js","static/js/ScreenShareModal-CYX7LCLg.js","static/js/SecurityAlertsPanel-BW_fsW-w.js","static/css/SecurityAlertsPanel-CTr4un6t.css","static/js/ServerAnalyticsDashboard-B7OUNCl_.js","static/js/ServerTemplates-BM2E9hRL.js","static/css/ServerTemplates-CSGt_DNd.css","static/js/SessionManagerModal-DbQklqjF.js","static/js/SlashCommandsPanel-DflqoU2n.js","static/css/SlashCommandsPanel-D5PhcgrD.css","static/js/SpamDetectionPanel-DPIcJaa7.js","static/js/StatusPicker-DD16Tr_4.js","static/js/StickersPanel-BVRtOuAz.js","static/css/StickersPanel-De9kMEUm.css","static/js/SubscriptionManager-DDD3tnnb.js","static/js/ThemeMarketplace-DGpr98_G.js","static/css/ThemeMarketplace-CHmIrdQ4.css","static/js/TranslationPanel-0kP4NZJX.js","static/css/TranslationPanel-DUxc3zzR.css","static/js/UserNotesModal-CGi7VG1X.js","static/js/WebhookManager-Bm_F0_iZ.js","static/js/WelcomeScreenEditor-BjqJuHeB.js","static/js/ImageLightbox-Bd9djm77.js","static/js/MessageTemplateModal-CnWeDgQg.js","static/js/PinnedMessages-Bg4Z9VnI.js","static/js/Message-C6wc4GJi.js","static/js/LazyImage-DdkEZ080.js","static/js/imageCaching-xf5IJBbb.js","static/js/syntax-core-DVGewJU9.js","static/js/perf-vendor-C7SkqPhC.js","static/js/SummaryModal-BUIQMbK3.js","static/js/ThemeStoreModal-CduloDLv.js","static/js/UserProfileModal-nuerxjra.js","static/js/VirtualMessageList-C3qfbspt.js","static/js/MessageInput-BCyEfXGC.js","static/js/ScheduledMessageModal-DTCh0hbW.js","static/css/MessageInput-Dq1MhOE2.css","static/js/UserVideoContainer-BJKkjClY.js","static/js/VoiceAudioController-BynloBmG.js","static/js/RichTextEditor-CnydQuQx.js","static/js/editor-vendor-De2l9AY3.js","static/css/RichTextEditor-BJ_bcwUR.css","static/js/StickyMessageBanner-BrhaUpuN.js","static/js/LoginPage-B5YRkoJw.js","static/js/recaptcha-CiVUdm4Z.js","static/js/WelcomeScreen-CkaSQ0J1.js","static/js/ImageModal-BlJrc8Ul.js","static/js/CryptoStoreModal-r7SEacpu.js","static/js/KanbanBoard-BohoWxkS.js","static/js/AutoModerationPanel-DuXU2zwV.js","static/css/AutoModerationPanel-C32Du6hD.css","static/js/MessageThreadsPanel-DpAuXz70.js","static/js/ModeratorNotesPanel-dqGeUu3u.js","static/js/ServerRolesPanel-BisIj6K9.js","static/js/NotificationPreferencesPanel-CaVDUB-m.js","static/js/MessageOCRPanel-B8_VVSnl.js","static/js/MassActionsPanel-DWwwNS2M.js","static/js/TimeoutMutePanel-BrbMWxwY.js","static/js/ServerThemesPanel-BDBsAMR6.js","static/js/KeywordMutesPanel-Ckz7PqjQ.js","static/js/WelcomeTemplatesPanel-B0HoOvPt.js","static/js/StickyMessagesPanel-Pvubzjnz.js","static/js/MessageTemplatesPanel-BFnjdJJ-.js","static/js/MessageExportPanel-CQF93cMI.js","static/js/ArchivedRoomsPanel-D9aIjFxJ.js","static/js/SlowModePanel-LIKu6G7T.js","static/js/EmojiManagementPanel-DXmZXZHM.js","static/js/VanityURLPanel-BoWpWS4Q.js","static/js/VerifyEmailPage-CPqjRClY.js","static/js/ForgotPasswordPage-Dvi04eBr.js","static/js/ResetPasswordPage-C9pWHncF.js","static/js/TwoFactorLoginPage-DpZIJ5dO.js","static/js/TwoFactorSetup-BoCr7WMC.js","static/css/TwoFactorSetup-CiN9KZwT.css","static/js/TwoFactorLogin-Dzbvao0Q.js","static/css/TwoFactorLogin-CH80MXkS.css","static/js/VanityInviteScreen-B6hcNt_v.js","static/js/InviteCodeScreen-W1qOF0la.js","static/js/EmailVerification-CVo9AUBw.js","static/css/EmailVerification-C3sYdY7W.css","static/js/MobileNav-C54fV4k3.js","static/css/MobileNav-DtnO-H0A.css","static/js/SwipeActions-CAWSugvZ.js","static/css/SwipeActions-Cz9xl2of.css","static/js/VoiceMessage-D4-GrYKo.js","static/css/VoiceMessage-DER7v0BF.css","static/js/FriendsTab-m19L3Oau.js","static/js/RoomList-BtB_aped.js","static/js/UserFooter-CnbZqgnZ.js","static/js/VoiceChatPanel-Dov42lJK.js","static/js/UserContextMenu-D-FXCTVo.js","static/js/cjs-B_ypQz0b.js","static/js/ChatUserList-CltnwdLS.js","static/js/FloatingVoiceIsland-CK9oLub8.js","static/css/FloatingVoiceIsland-o2ysua3l.css","static/js/CinemaPlayer-CIM5njaf.js","static/js/NotificationDropdown-CDYtYqhu.js","static/js/ReactionStatsPanel-CRHDWfsY.js","static/css/ReactionStatsPanel-t19waiAA.css","static/js/ServerHealthPanel-CGgmPc-y.js","static/css/ServerHealthPanel-B_5Djj_A.css","static/js/ChannelAnalyticsPanel-PPJhsZeU.js","static/css/ChannelAnalyticsPanel-r3UgQ1hL.css","static/js/SmartSuggestionsPanel-ByLDopGD.js","static/css/SmartSuggestionsPanel-BbKvpusp.css","static/js/UserPresenceInsightsPanel-D-A48kV2.js","static/css/UserPresenceInsightsPanel-dGEOnCM8.css","static/js/ChannelAboutPanel-C6PgjMXG.js","static/js/MessageSchedulePicker-CXKNQyJv.js","static/js/RaidProtectionDashboard-COiZkN6y.js","static/css/RaidProtectionDashboard-BQt65ceE.css","static/js/BookmarksPanel-Cc20Q8JC.js","static/js/web-m9W83Dzh.js","static/js/urlHandlers-_pbByjvw.js","static/js/pushNotifications-BulFuBDa.js","static/js/EnglishHub-G_KHUP-w.js","static/js/GrammarQuizPage-DTOgzkom.js","static/js/EnglishLearningPage-XO_712z8.js","static/js/CryptoDashboard-DtZ_yZ-_.js","static/js/useWindowWidth-1OHah2CZ.js","static/js/CryptoSignals-C755l00d.js","static/js/PrivacyPolicyPage-BdVuT4be.js","static/js/StorePage-Cr8dmOoY.js","static/js/LandingPage-CbI7e7j_.js","static/css/LandingPage-DPQeioTe.css","static/js/ReferralProgram-lkfv9pX0.js","static/css/ReferralProgram-B8r8K3iq.css","static/js/GrowthDashboard-DQnhMVeM.js","static/css/GrowthDashboard-BzssGvAF.css","static/js/ToastDemo-BSh7d2-e.js","static/css/ToastDemo-wA4aHR9-.css"])))=>i.map(i=>d[i]);
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var _a;
import { _ as __vitePreload } from "./media-vendor-BRMiuG2Y.js";
import { a as React, j as jsxRuntimeExports, r as reactExports, h as clientExports, f as ReactDOM, i as ReactDOM$1 } from "./react-core-BiY6fgAJ.js";
import { u as useLocation, a as useParams, b as useNavigate, L as Link, c as useSearchParams, H as HashRouter, R as Routes, d as Route, N as Navigate } from "./router-vendor-DrLUSS4j.js";
import { c as create, p as persist } from "./state-vendor-BeEHnF_A.js";
import { j as jwtDecode, C as CryptoJS } from "./crypto-vendor-NANfm9jb.js";
import { F as FaTools, a as FaTimes, b as FaWifi, c as FaSync, d as FaExclamationTriangle, e as FaChevronDown, f as FaQuestionCircle, g as FaTrash, h as FaLock, i as FaThumbtack, j as FaLink, k as FaBell, l as FaBellSlash, m as FaInbox, n as FaSmile, o as FaFilm, p as FaCoffee, q as FaCode, r as FaMagic, s as FaBroom, t as FaSearch, u as FaUsers, v as FaSpinner, w as FaCheckCircle, x as FaTimesCircle, y as FaServer, z as FaClock, A as FaArrowLeft, B as FaRobot, C as FaUser, D as FaStop, E as FaMicrophone, G as FaVolumeUp, H as FaForward, I as FaRedo, J as FaBitcoin, K as FaArrowRight } from "./icons-vendor-2VDeY8fW.js";
import { y } from "./ui-vendor-iPoN0WGz.js";
(/* @__PURE__ */ __name(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) return;
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) processPreload(link);
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") continue;
      for (const node of mutation.addedNodes) if (node.tagName === "LINK" && node.rel === "modulepreload") processPreload(node);
    }
  }).observe(document, {
    childList: true,
    subtree: true
  });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity) fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials") fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous") fetchOpts.credentials = "omit";
    else fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  __name(getFetchOpts, "getFetchOpts");
  function processPreload(link) {
    if (link.ep) return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
  __name(processPreload, "processPreload");
}, "polyfill"))();
const originalConsole = {
  log: console.log,
  warn: console.warn,
  error: console.error,
  info: console.info,
  debug: console.debug
};
let logLevel = "warn";
const LOG_LEVELS = {
  none: 0,
  error: 1,
  warn: 2,
  info: 3,
  debug: 4
};
const currentLogLevel = LOG_LEVELS[logLevel];
const shouldLog = /* @__PURE__ */ __name((level, args) => {
  if (level > LOG_LEVELS.error) {
    return false;
  }
  if (level > currentLogLevel) {
    return false;
  }
  return true;
}, "shouldLog");
console.log = (...args) => {
  if (shouldLog(LOG_LEVELS.info)) {
    originalConsole.log(...args);
  }
};
console.info = (...args) => {
  if (shouldLog(LOG_LEVELS.info)) {
    originalConsole.info(...args);
  }
};
console.debug = (...args) => {
  if (shouldLog(LOG_LEVELS.debug)) {
    originalConsole.debug(...args);
  }
};
console.warn = (...args) => {
  if (shouldLog(LOG_LEVELS.warn)) {
    originalConsole.warn(...args);
  }
};
console.error = (...args) => {
  if (shouldLog(LOG_LEVELS.error)) {
    originalConsole.error(...args);
  }
};
const rateLimitedLogs = /* @__PURE__ */ new Map();
setInterval(() => {
  const now = Date.now();
  rateLimitedLogs.forEach((timestamp, key) => {
    if (now - timestamp > 6e4) {
      rateLimitedLogs.delete(key);
    }
  });
}, 6e4);
var ExceptionCode;
(function(ExceptionCode2) {
  ExceptionCode2["Unimplemented"] = "UNIMPLEMENTED";
  ExceptionCode2["Unavailable"] = "UNAVAILABLE";
})(ExceptionCode || (ExceptionCode = {}));
const _CapacitorException = class _CapacitorException extends Error {
  constructor(message, code, data) {
    super(message);
    this.message = message;
    this.code = code;
    this.data = data;
  }
};
__name(_CapacitorException, "CapacitorException");
let CapacitorException = _CapacitorException;
const getPlatformId = /* @__PURE__ */ __name((win) => {
  var _a2, _b;
  if (win === null || win === void 0 ? void 0 : win.androidBridge) {
    return "android";
  } else if ((_b = (_a2 = win === null || win === void 0 ? void 0 : win.webkit) === null || _a2 === void 0 ? void 0 : _a2.messageHandlers) === null || _b === void 0 ? void 0 : _b.bridge) {
    return "ios";
  } else {
    return "web";
  }
}, "getPlatformId");
const createCapacitor = /* @__PURE__ */ __name((win) => {
  const capCustomPlatform = win.CapacitorCustomPlatform || null;
  const cap = win.Capacitor || {};
  const Plugins = cap.Plugins = cap.Plugins || {};
  const getPlatform = /* @__PURE__ */ __name(() => {
    return capCustomPlatform !== null ? capCustomPlatform.name : getPlatformId(win);
  }, "getPlatform");
  const isNativePlatform = /* @__PURE__ */ __name(() => getPlatform() !== "web", "isNativePlatform");
  const isPluginAvailable = /* @__PURE__ */ __name((pluginName) => {
    const plugin = registeredPlugins.get(pluginName);
    if (plugin === null || plugin === void 0 ? void 0 : plugin.platforms.has(getPlatform())) {
      return true;
    }
    if (getPluginHeader(pluginName)) {
      return true;
    }
    return false;
  }, "isPluginAvailable");
  const getPluginHeader = /* @__PURE__ */ __name((pluginName) => {
    var _a2;
    return (_a2 = cap.PluginHeaders) === null || _a2 === void 0 ? void 0 : _a2.find((h) => h.name === pluginName);
  }, "getPluginHeader");
  const handleError = /* @__PURE__ */ __name((err) => win.console.error(err), "handleError");
  const registeredPlugins = /* @__PURE__ */ new Map();
  const registerPlugin2 = /* @__PURE__ */ __name((pluginName, jsImplementations = {}) => {
    const registeredPlugin = registeredPlugins.get(pluginName);
    if (registeredPlugin) {
      console.warn(`Capacitor plugin "${pluginName}" already registered. Cannot register plugins twice.`);
      return registeredPlugin.proxy;
    }
    const platform = getPlatform();
    const pluginHeader = getPluginHeader(pluginName);
    let jsImplementation;
    const loadPluginImplementation = /* @__PURE__ */ __name(async () => {
      if (!jsImplementation && platform in jsImplementations) {
        jsImplementation = typeof jsImplementations[platform] === "function" ? jsImplementation = await jsImplementations[platform]() : jsImplementation = jsImplementations[platform];
      } else if (capCustomPlatform !== null && !jsImplementation && "web" in jsImplementations) {
        jsImplementation = typeof jsImplementations["web"] === "function" ? jsImplementation = await jsImplementations["web"]() : jsImplementation = jsImplementations["web"];
      }
      return jsImplementation;
    }, "loadPluginImplementation");
    const createPluginMethod = /* @__PURE__ */ __name((impl, prop) => {
      var _a2, _b;
      if (pluginHeader) {
        const methodHeader = pluginHeader === null || pluginHeader === void 0 ? void 0 : pluginHeader.methods.find((m) => prop === m.name);
        if (methodHeader) {
          if (methodHeader.rtype === "promise") {
            return (options) => cap.nativePromise(pluginName, prop.toString(), options);
          } else {
            return (options, callback) => cap.nativeCallback(pluginName, prop.toString(), options, callback);
          }
        } else if (impl) {
          return (_a2 = impl[prop]) === null || _a2 === void 0 ? void 0 : _a2.bind(impl);
        }
      } else if (impl) {
        return (_b = impl[prop]) === null || _b === void 0 ? void 0 : _b.bind(impl);
      } else {
        throw new CapacitorException(`"${pluginName}" plugin is not implemented on ${platform}`, ExceptionCode.Unimplemented);
      }
    }, "createPluginMethod");
    const createPluginMethodWrapper = /* @__PURE__ */ __name((prop) => {
      let remove;
      const wrapper = /* @__PURE__ */ __name((...args) => {
        const p = loadPluginImplementation().then((impl) => {
          const fn = createPluginMethod(impl, prop);
          if (fn) {
            const p2 = fn(...args);
            remove = p2 === null || p2 === void 0 ? void 0 : p2.remove;
            return p2;
          } else {
            throw new CapacitorException(`"${pluginName}.${prop}()" is not implemented on ${platform}`, ExceptionCode.Unimplemented);
          }
        });
        if (prop === "addListener") {
          p.remove = async () => remove();
        }
        return p;
      }, "wrapper");
      wrapper.toString = () => `${prop.toString()}() { [capacitor code] }`;
      Object.defineProperty(wrapper, "name", {
        value: prop,
        writable: false,
        configurable: false
      });
      return wrapper;
    }, "createPluginMethodWrapper");
    const addListener = createPluginMethodWrapper("addListener");
    const removeListener = createPluginMethodWrapper("removeListener");
    const addListenerNative = /* @__PURE__ */ __name((eventName, callback) => {
      const call = addListener({ eventName }, callback);
      const remove = /* @__PURE__ */ __name(async () => {
        const callbackId = await call;
        removeListener({
          eventName,
          callbackId
        }, callback);
      }, "remove");
      const p = new Promise((resolve) => call.then(() => resolve({ remove })));
      p.remove = async () => {
        console.warn(`Using addListener() without 'await' is deprecated.`);
        await remove();
      };
      return p;
    }, "addListenerNative");
    const proxy = new Proxy({}, {
      get(_, prop) {
        switch (prop) {
          // https://github.com/facebook/react/issues/20030
          case "$$typeof":
            return void 0;
          case "toJSON":
            return () => ({});
          case "addListener":
            return pluginHeader ? addListenerNative : addListener;
          case "removeListener":
            return removeListener;
          default:
            return createPluginMethodWrapper(prop);
        }
      }
    });
    Plugins[pluginName] = proxy;
    registeredPlugins.set(pluginName, {
      name: pluginName,
      proxy,
      platforms: /* @__PURE__ */ new Set([...Object.keys(jsImplementations), ...pluginHeader ? [platform] : []])
    });
    return proxy;
  }, "registerPlugin");
  if (!cap.convertFileSrc) {
    cap.convertFileSrc = (filePath) => filePath;
  }
  cap.getPlatform = getPlatform;
  cap.handleError = handleError;
  cap.isNativePlatform = isNativePlatform;
  cap.isPluginAvailable = isPluginAvailable;
  cap.registerPlugin = registerPlugin2;
  cap.Exception = CapacitorException;
  cap.DEBUG = !!cap.DEBUG;
  cap.isLoggingEnabled = !!cap.isLoggingEnabled;
  return cap;
}, "createCapacitor");
const initCapacitorGlobal = /* @__PURE__ */ __name((win) => win.Capacitor = createCapacitor(win), "initCapacitorGlobal");
const Capacitor = /* @__PURE__ */ initCapacitorGlobal(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
const registerPlugin = Capacitor.registerPlugin;
const _WebPlugin = class _WebPlugin {
  constructor() {
    this.listeners = {};
    this.retainedEventArguments = {};
    this.windowListeners = {};
  }
  addListener(eventName, listenerFunc) {
    let firstListener = false;
    const listeners = this.listeners[eventName];
    if (!listeners) {
      this.listeners[eventName] = [];
      firstListener = true;
    }
    this.listeners[eventName].push(listenerFunc);
    const windowListener = this.windowListeners[eventName];
    if (windowListener && !windowListener.registered) {
      this.addWindowListener(windowListener);
    }
    if (firstListener) {
      this.sendRetainedArgumentsForEvent(eventName);
    }
    const remove = /* @__PURE__ */ __name(async () => this.removeListener(eventName, listenerFunc), "remove");
    const p = Promise.resolve({ remove });
    return p;
  }
  async removeAllListeners() {
    this.listeners = {};
    for (const listener in this.windowListeners) {
      this.removeWindowListener(this.windowListeners[listener]);
    }
    this.windowListeners = {};
  }
  notifyListeners(eventName, data, retainUntilConsumed) {
    const listeners = this.listeners[eventName];
    if (!listeners) {
      if (retainUntilConsumed) {
        let args = this.retainedEventArguments[eventName];
        if (!args) {
          args = [];
        }
        args.push(data);
        this.retainedEventArguments[eventName] = args;
      }
      return;
    }
    listeners.forEach((listener) => listener(data));
  }
  hasListeners(eventName) {
    var _a2;
    return !!((_a2 = this.listeners[eventName]) === null || _a2 === void 0 ? void 0 : _a2.length);
  }
  registerWindowListener(windowEventName, pluginEventName) {
    this.windowListeners[pluginEventName] = {
      registered: false,
      windowEventName,
      pluginEventName,
      handler: /* @__PURE__ */ __name((event) => {
        this.notifyListeners(pluginEventName, event);
      }, "handler")
    };
  }
  unimplemented(msg = "not implemented") {
    return new Capacitor.Exception(msg, ExceptionCode.Unimplemented);
  }
  unavailable(msg = "not available") {
    return new Capacitor.Exception(msg, ExceptionCode.Unavailable);
  }
  async removeListener(eventName, listenerFunc) {
    const listeners = this.listeners[eventName];
    if (!listeners) {
      return;
    }
    const index = listeners.indexOf(listenerFunc);
    this.listeners[eventName].splice(index, 1);
    if (!this.listeners[eventName].length) {
      this.removeWindowListener(this.windowListeners[eventName]);
    }
  }
  addWindowListener(handle) {
    window.addEventListener(handle.windowEventName, handle.handler);
    handle.registered = true;
  }
  removeWindowListener(handle) {
    if (!handle) {
      return;
    }
    window.removeEventListener(handle.windowEventName, handle.handler);
    handle.registered = false;
  }
  sendRetainedArgumentsForEvent(eventName) {
    const args = this.retainedEventArguments[eventName];
    if (!args) {
      return;
    }
    delete this.retainedEventArguments[eventName];
    args.forEach((arg) => {
      this.notifyListeners(eventName, arg);
    });
  }
};
__name(_WebPlugin, "WebPlugin");
let WebPlugin = _WebPlugin;
const encode = /* @__PURE__ */ __name((str) => encodeURIComponent(str).replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent).replace(/[()]/g, escape), "encode");
const decode = /* @__PURE__ */ __name((str) => str.replace(/(%[\dA-F]{2})+/gi, decodeURIComponent), "decode");
const _CapacitorCookiesPluginWeb = class _CapacitorCookiesPluginWeb extends WebPlugin {
  async getCookies() {
    const cookies = document.cookie;
    const cookieMap = {};
    cookies.split(";").forEach((cookie2) => {
      if (cookie2.length <= 0)
        return;
      let [key, value] = cookie2.replace(/=/, "CAP_COOKIE").split("CAP_COOKIE");
      key = decode(key).trim();
      value = decode(value).trim();
      cookieMap[key] = value;
    });
    return cookieMap;
  }
  async setCookie(options) {
    try {
      const encodedKey = encode(options.key);
      const encodedValue = encode(options.value);
      const expires = `; expires=${(options.expires || "").replace("expires=", "")}`;
      const path2 = (options.path || "/").replace("path=", "");
      const domain = options.url != null && options.url.length > 0 ? `domain=${options.url}` : "";
      document.cookie = `${encodedKey}=${encodedValue || ""}${expires}; path=${path2}; ${domain};`;
    } catch (error) {
      return Promise.reject(error);
    }
  }
  async deleteCookie(options) {
    try {
      document.cookie = `${options.key}=; Max-Age=0`;
    } catch (error) {
      return Promise.reject(error);
    }
  }
  async clearCookies() {
    try {
      const cookies = document.cookie.split(";") || [];
      for (const cookie2 of cookies) {
        document.cookie = cookie2.replace(/^ +/, "").replace(/=.*/, `=;expires=${(/* @__PURE__ */ new Date()).toUTCString()};path=/`);
      }
    } catch (error) {
      return Promise.reject(error);
    }
  }
  async clearAllCookies() {
    try {
      await this.clearCookies();
    } catch (error) {
      return Promise.reject(error);
    }
  }
};
__name(_CapacitorCookiesPluginWeb, "CapacitorCookiesPluginWeb");
let CapacitorCookiesPluginWeb = _CapacitorCookiesPluginWeb;
registerPlugin("CapacitorCookies", {
  web: /* @__PURE__ */ __name(() => new CapacitorCookiesPluginWeb(), "web")
});
const readBlobAsBase64 = /* @__PURE__ */ __name(async (blob) => new Promise((resolve, reject) => {
  const reader = new FileReader();
  reader.onload = () => {
    const base64String = reader.result;
    resolve(base64String.indexOf(",") >= 0 ? base64String.split(",")[1] : base64String);
  };
  reader.onerror = (error) => reject(error);
  reader.readAsDataURL(blob);
}), "readBlobAsBase64");
const normalizeHttpHeaders = /* @__PURE__ */ __name((headers = {}) => {
  const originalKeys = Object.keys(headers);
  const loweredKeys = Object.keys(headers).map((k) => k.toLocaleLowerCase());
  const normalized = loweredKeys.reduce((acc, key, index) => {
    acc[key] = headers[originalKeys[index]];
    return acc;
  }, {});
  return normalized;
}, "normalizeHttpHeaders");
const buildUrlParams = /* @__PURE__ */ __name((params, shouldEncode = true) => {
  if (!params)
    return null;
  const output = Object.entries(params).reduce((accumulator, entry) => {
    const [key, value] = entry;
    let encodedValue;
    let item;
    if (Array.isArray(value)) {
      item = "";
      value.forEach((str) => {
        encodedValue = shouldEncode ? encodeURIComponent(str) : str;
        item += `${key}=${encodedValue}&`;
      });
      item.slice(0, -1);
    } else {
      encodedValue = shouldEncode ? encodeURIComponent(value) : value;
      item = `${key}=${encodedValue}`;
    }
    return `${accumulator}&${item}`;
  }, "");
  return output.substr(1);
}, "buildUrlParams");
const buildRequestInit = /* @__PURE__ */ __name((options, extra = {}) => {
  const output = Object.assign({ method: options.method || "GET", headers: options.headers }, extra);
  const headers = normalizeHttpHeaders(options.headers);
  const type = headers["content-type"] || "";
  if (typeof options.data === "string") {
    output.body = options.data;
  } else if (type.includes("application/x-www-form-urlencoded")) {
    const params = new URLSearchParams();
    for (const [key, value] of Object.entries(options.data || {})) {
      params.set(key, value);
    }
    output.body = params.toString();
  } else if (type.includes("multipart/form-data") || options.data instanceof FormData) {
    const form = new FormData();
    if (options.data instanceof FormData) {
      options.data.forEach((value, key) => {
        form.append(key, value);
      });
    } else {
      for (const key of Object.keys(options.data)) {
        form.append(key, options.data[key]);
      }
    }
    output.body = form;
    const headers2 = new Headers(output.headers);
    headers2.delete("content-type");
    output.headers = headers2;
  } else if (type.includes("application/json") || typeof options.data === "object") {
    output.body = JSON.stringify(options.data);
  }
  return output;
}, "buildRequestInit");
const _CapacitorHttpPluginWeb = class _CapacitorHttpPluginWeb extends WebPlugin {
  /**
   * Perform an Http request given a set of options
   * @param options Options to build the HTTP request
   */
  async request(options) {
    const requestInit = buildRequestInit(options, options.webFetchExtra);
    const urlParams = buildUrlParams(options.params, options.shouldEncodeUrlParams);
    const url = urlParams ? `${options.url}?${urlParams}` : options.url;
    const response = await fetch(url, requestInit);
    const contentType = response.headers.get("content-type") || "";
    let { responseType = "text" } = response.ok ? options : {};
    if (contentType.includes("application/json")) {
      responseType = "json";
    }
    let data;
    let blob;
    switch (responseType) {
      case "arraybuffer":
      case "blob":
        blob = await response.blob();
        data = await readBlobAsBase64(blob);
        break;
      case "json":
        data = await response.json();
        break;
      case "document":
      case "text":
      default:
        data = await response.text();
    }
    const headers = {};
    response.headers.forEach((value, key) => {
      headers[key] = value;
    });
    return {
      data,
      headers,
      status: response.status,
      url: response.url
    };
  }
  /**
   * Perform an Http GET request given a set of options
   * @param options Options to build the HTTP request
   */
  async get(options) {
    return this.request(Object.assign(Object.assign({}, options), { method: "GET" }));
  }
  /**
   * Perform an Http POST request given a set of options
   * @param options Options to build the HTTP request
   */
  async post(options) {
    return this.request(Object.assign(Object.assign({}, options), { method: "POST" }));
  }
  /**
   * Perform an Http PUT request given a set of options
   * @param options Options to build the HTTP request
   */
  async put(options) {
    return this.request(Object.assign(Object.assign({}, options), { method: "PUT" }));
  }
  /**
   * Perform an Http PATCH request given a set of options
   * @param options Options to build the HTTP request
   */
  async patch(options) {
    return this.request(Object.assign(Object.assign({}, options), { method: "PATCH" }));
  }
  /**
   * Perform an Http DELETE request given a set of options
   * @param options Options to build the HTTP request
   */
  async delete(options) {
    return this.request(Object.assign(Object.assign({}, options), { method: "DELETE" }));
  }
};
__name(_CapacitorHttpPluginWeb, "CapacitorHttpPluginWeb");
let CapacitorHttpPluginWeb = _CapacitorHttpPluginWeb;
registerPlugin("CapacitorHttp", {
  web: /* @__PURE__ */ __name(() => new CapacitorHttpPluginWeb(), "web")
});
let ErrorBoundary$1 = (_a = class extends React.Component {
  constructor(props) {
    super(props);
    __publicField(this, "reportError", /* @__PURE__ */ __name(async (error, errorInfo) => {
      try {
        const apiBase = typeof window !== "undefined" && window.__PAWSCORD_API_BASE__ || "https://api.pawscord.com";
        const token = localStorage.getItem("access_token");
        const headers = { "Content-Type": "application/json" };
        if (token) headers["Authorization"] = `Bearer ${token}`;
        await fetch(`${apiBase}/errors/report/`, {
          method: "POST",
          headers,
          body: JSON.stringify({
            error: error.toString(),
            stack: errorInfo.componentStack,
            url: window.location.href,
            userAgent: navigator.userAgent,
            timestamp: (/* @__PURE__ */ new Date()).toISOString()
          })
        });
      } catch (err) {
      }
    }, "reportError"));
    __publicField(this, "handleReset", /* @__PURE__ */ __name(() => {
      this.setState({
        hasError: false,
        error: null,
        errorInfo: null
      });
    }, "handleReset"));
    this.state = {
      hasError: false,
      error: null,
      errorInfo: null,
      errorCount: 0
    };
  }
  static getDerivedStateFromError(error) {
    return { hasError: true };
  }
  componentDidCatch(error, errorInfo) {
    console.error("Error Boundary caught error:", error, errorInfo);
    this.setState({
      error,
      errorInfo,
      errorCount: this.state.errorCount + 1
    });
    if (window.gtag) {
      window.gtag("event", "exception", {
        description: error.toString(),
        fatal: false
      });
    }
    this.reportError(error, errorInfo);
  }
  render() {
    if (this.state.hasError) {
      if (this.state.errorCount > 3) {
        return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "error-boundary critical", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "error-content", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { children: "âš ï¸ Critical Error" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Multiple errors detected. Please refresh the page." }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: /* @__PURE__ */ __name(() => window.location.reload(), "onClick"), className: "btn-reload", children: "Refresh Page" })
        ] }) });
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "error-boundary", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "error-content", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "error-icon", children: "ðŸ˜•" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { children: "Oops! Something went wrong" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "error-message", children: this.props.fallbackMessage || "We're sorry for the inconvenience. The error has been reported." }),
        false,
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "error-actions", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: this.handleReset, className: "btn-retry", children: "Try Again" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: /* @__PURE__ */ __name(() => window.location.href = "/", "onClick"), className: "btn-home", children: "Go Home" })
        ] })
      ] }) });
    }
    return this.props.children;
  }
}, __name(_a, "ErrorBoundary"), _a);
const useChatStore = create((set, get2) => ({
  // --- STATE (Veriler) ---
  messages: [],
  encryptionKeys: {},
  activeChat: { type: "welcome", id: "welcome", targetUser: null },
  unreadCounts: {},
  typingUsers: [],
  onlineUsers: [],
  voiceUsers: {},
  // Sesli odalardaki kullanÄ±cÄ±lar
  currentPermissions: {
    is_owner: false,
    can_manage_channels: false,
    can_delete_messages: false,
    can_manage_roles: false,
    can_ban_members: false
  },
  // --- ACTIONS (Fonksiyonlar) ---
  // Sohbet DeÄŸiÅŸtirme
  // ðŸ”¥ FIX: Hem positional (type, id, targetUser) hem object ({type, id, slug}) formatÄ±nÄ± destekle
  setActiveChat: /* @__PURE__ */ __name((typeOrObj, id, targetUser = null) => {
    let type, chatId, chatTargetUser;
    if (typeOrObj && typeof typeOrObj === "object") {
      type = typeOrObj.type;
      chatId = typeOrObj.id || typeOrObj.slug;
      chatTargetUser = typeOrObj.targetUser || null;
    } else {
      type = typeOrObj;
      chatId = id;
      chatTargetUser = targetUser;
    }
    set({ activeChat: { type, id: chatId, targetUser: chatTargetUser } });
    const key = type === "room" ? `room-${chatId}` : `dm-${chatId}`;
    set((state) => {
      const newCounts = { ...state.unreadCounts };
      delete newCounts[key];
      return { unreadCounts: newCounts };
    });
  }, "setActiveChat"),
  // Mesaj Ekleme (Gelen veya GÃ¶nderilen)
  // ðŸ›¡ï¸ GUARD: GeÃ§ersiz mesajÄ± ekleme
  addMessage: /* @__PURE__ */ __name((message) => set((state) => {
    if (!message || typeof message !== "object" || !message.id) {
      console.warn("âš ï¸ [Store] Invalid message rejected:", message);
      return state;
    }
    if (message.temp_id) {
      const exists = state.messages.some((m) => m.temp_id === message.temp_id);
      if (exists) {
        return {
          messages: state.messages.map((m) => m.temp_id === message.temp_id ? message : m)
        };
      }
    }
    if (state.messages.some((m) => m.id === message.id)) return state;
    return { messages: [...state.messages, message] };
  }), "addMessage"),
  // Mesaj GÃ¼ncelleme (Poll update vb. iÃ§in)
  updateMessage: /* @__PURE__ */ __name((id, updates) => set((state) => ({
    messages: state.messages.map((m) => m.id === id ? { ...m, ...updates } : m)
  })), "updateMessage"),
  // MesajlarÄ± Toplu YÃ¼kleme (GeÃ§miÅŸi Ã§ekerken)
  // ðŸ›¡ï¸ GUARD: Bozuk mesajlarÄ± filtrele
  setMessages: /* @__PURE__ */ __name((newMessages) => set((state) => {
    const resolved = typeof newMessages === "function" ? newMessages(state.messages) : newMessages;
    const validMessages = Array.isArray(resolved) ? resolved.filter((m) => m && typeof m === "object" && m.id) : [];
    return { messages: validMessages };
  }), "setMessages"),
  // GeÃ§miÅŸ MesajlarÄ± BaÅŸa Ekleme (Scroll yukarÄ± yapÄ±nca)
  prependMessages: /* @__PURE__ */ __name((oldMessages) => set((state) => ({
    messages: [...oldMessages, ...state.messages]
  })), "prependMessages"),
  // OkunmamÄ±ÅŸ Mesaj SayÄ±sÄ±nÄ± ArtÄ±r
  incrementUnread: /* @__PURE__ */ __name((key) => set((state) => ({
    unreadCounts: {
      ...state.unreadCounts,
      [key]: (state.unreadCounts[key] || 0) + 1
    }
  })), "incrementUnread"),
  // Online KullanÄ±cÄ±larÄ± GÃ¼ncelle
  setOnlineUsers: /* @__PURE__ */ __name((users) => set({ onlineUsers: users }), "setOnlineUsers"),
  // YazÄ±yor... animasyonu
  setTypingUser: /* @__PURE__ */ __name((username, isTyping) => set((state) => {
    if (isTyping) {
      return { typingUsers: state.typingUsers.includes(username) ? state.typingUsers : [...state.typingUsers, username] };
    } else {
      return { typingUsers: state.typingUsers.filter((u) => u !== username) };
    }
  }), "setTypingUser"),
  // Sesli Sohbet KullanÄ±cÄ±larÄ±
  setVoiceUsers: /* @__PURE__ */ __name((usersMap) => set({ voiceUsers: usersMap }), "setVoiceUsers"),
  setVoiceUsersState: /* @__PURE__ */ __name((usersMap) => set({ voiceUsers: usersMap }), "setVoiceUsersState"),
  // Alias used by App.js
  // Selection mode
  selectedMessages: /* @__PURE__ */ new Set(),
  setSelectedMessages: /* @__PURE__ */ __name((val) => set({ selectedMessages: typeof val === "function" ? val(get2().selectedMessages) : val }), "setSelectedMessages"),
  setEncryptionKey: /* @__PURE__ */ __name((chatId, key) => set((state) => ({
    encryptionKeys: {
      ...state.encryptionKeys,
      [chatId]: key
    }
  })), "setEncryptionKey"),
  setPermissions: /* @__PURE__ */ __name((perms) => set({
    currentPermissions: perms || {
      is_owner: false,
      can_manage_channels: false,
      can_delete_messages: false,
      can_manage_roles: false,
      can_ban_members: false
    }
  }), "setPermissions")
}));
const useUIStore = create(
  persist(
    (set, get2) => ({
      // --- MODAL STATES ---
      // All modal visibility flags. Dynamic keys are auto-created by openModal().
      modals: {
        // Core UI
        settings: false,
        createServer: false,
        invitePeople: false,
        serverSettings: false,
        userProfile: false,
        imageViewer: false,
        // Migrated from App.js useState(false) â€” 191 modals
        groupModal: false,
        soundboard: false,
        whiteboard: false,
        encModal: false,
        templateModal: false,
        snippetModal: false,
        pollModal: false,
        profilePanel: false,
        pinned: false,
        gifPicker: false,
        cinema: false,
        stickerPicker: false,
        store: false,
        themeStore: false,
        analytics: false,
        adminPanel: false,
        webhooks: false,
        modTools: false,
        vanityURL: false,
        // Moderation
        autoModeration: false,
        raidProtection: false,
        reportSystem: false,
        auditLog: false,
        userWarnings: false,
        autoResponder: false,
        // Features
        bookmarks: false,
        readLater: false,
        mentionsInbox: false,
        customStatus: false,
        channelPermissions: false,
        messageThreads: false,
        moderatorNotes: false,
        serverRoles: false,
        notificationPrefs: false,
        messageOCR: false,
        massActions: false,
        // Analytics & Tracking
        reactionAnalytics: false,
        linkClickTracking: false,
        joinLeaveLogs: false,
        userActivity: false,
        nicknameHistory: false,
        fieldChangeTracking: false,
        inviteAnalytics: false,
        // Content & Moderation
        contentScanner: false,
        ephemeralMessages: false,
        topicHistory: false,
        drafts: false,
        serverNicknames: false,
        // Server Features
        serverBoost: false,
        roomWebhooks: false,
        oAuthApps: false,
        autoResponders: false,
        // Security & Privacy
        sessionManagement: false,
        gDPRExport: false,
        dataRetention: false,
        twoFactorSetup: false,
        // Communication
        enhancedPolls: false,
        voiceTranscripts: false,
        inviteExport: false,
        // Search & Analytics
        advancedSearch: false,
        growthMetrics: false,
        linkPreview: false,
        // Store & Gamification
        inventory: false,
        waitlist: false,
        referralRewards: false,
        miniGames: false,
        projectCollaboration: false,
        avatarStudio: false,
        timeoutMute: false,
        serverThemes: false,
        keywordMutes: false,
        welcomeTemplates: false,
        stickyMessages: false,
        messageTemplates: false,
        messageExport: false,
        archivedRooms: false,
        slowMode: false,
        emojiManagement: false,
        // Core UX
        userSettings: false,
        keyboardShortcuts: false,
        commandPalette: false,
        serverDiscovery: false,
        appearanceSettings: false,
        languageSelector: false,
        changelog: false,
        logoutConfirm: false,
        notificationSounds: false,
        quickSwitcher: false,
        // Security
        loginHistory: false,
        securitySettings: false,
        privacySettings: false,
        accountDeletion: false,
        blockList: false,
        e2EESettings: false,
        // Communication
        threadView: false,
        scheduledMessages: false,
        reminders: false,
        forum: false,
        stageChannel: false,
        videoCall: false,
        voiceSettings: false,
        messageSearch: false,
        watchTogether: false,
        // Server Management
        autoRoles: false,
        reactionRoles: false,
        welcomeMessages: false,
        eventCalendar: false,
        giveaway: false,
        ticketSystem: false,
        starboard: false,
        serverBackup: false,
        banAppeals: false,
        customCommands: false,
        levelingSystem: false,
        liveStream: false,
        // Engagement
        achievements: false,
        birthdaySystem: false,
        premium: false,
        musicPlayer: false,
        botMarketplace: false,
        profileCustomization: false,
        integrationHub: false,
        tournaments: false,
        // Advanced
        highlights: false,
        customEmbed: false,
        spotifyIntegration: false,
        serverClone: false,
        weeklyChallenges: false,
        featureHub: false,
        // Moderation Tools
        moderatorTools: false,
        aIModeration: false,
        spamDetection: false,
        auditLogs: false,
        banHistory: false,
        moderationLogs: false,
        securityAlerts: false,
        // Communication
        gIFPicker: false,
        pollCreator: false,
        stickers: false,
        savedMessages: false,
        notificationsCenter: false,
        messageSummary: false,
        translation: false,
        // Server Management
        channelSettings: false,
        inviteModal: false,
        serverTemplates: false,
        serverAnalytics: false,
        rolesManager: false,
        welcomeScreenEditor: false,
        communitySettings: false,
        inviteLinkManager: false,
        // Bot/Dev
        botBuilder: false,
        botDevPortal: false,
        webhookManager: false,
        aPIKeys: false,
        slashCommands: false,
        codeRunner: false,
        // Profile & Social
        profileCard: false,
        userNotes: false,
        statusPicker: false,
        mutuals: false,
        profileShowcase: false,
        sessionManager: false,
        // Premium
        coinStore: false,
        premiumManagement: false,
        subscriptionManager: false,
        giftPremium: false,
        premiumMarketplace: false,
        themeMarketplace: false,
        // Advanced
        aIChatbot: false,
        codeEditor: false,
        screenShare: false,
        liveStreamModal: false,
        advancedAnalytics: false,
        fileManager: false,
        reports: false,
        errorReporting: false,
        avatarCropper: false,
        downloadModal: false,
        summary: false,
        dJ: false,
        notifications: false,
        toolbarMenu: false,
        paymentPanel: false,
        storeModal: false,
        dailyRewards: false,
        aPIUsagePanel: false,
        exportJobsPanel: false,
        scheduledAnnouncements: false,
        connectionsPanel: false,
        passwordSetupModal: false
      },
      // --- APP STATE (migrated from App.js local state) ---
      animationState: "start",
      setAnimationState: /* @__PURE__ */ __name((val) => set({ animationState: typeof val === "function" ? val(get2().animationState) : val }), "setAnimationState"),
      isConnected: false,
      setIsConnected: /* @__PURE__ */ __name((val) => set({ isConnected: typeof val === "function" ? val(get2().isConnected) : val }), "setIsConnected"),
      updateStatusText: "",
      setUpdateStatusText: /* @__PURE__ */ __name((val) => set({ updateStatusText: typeof val === "function" ? val(get2().updateStatusText) : val }), "setUpdateStatusText"),
      downloadProgress: 0,
      setDownloadProgress: /* @__PURE__ */ __name((val) => set({ downloadProgress: typeof val === "function" ? val(get2().downloadProgress) : val }), "setDownloadProgress"),
      isDownloading: false,
      setIsDownloading: /* @__PURE__ */ __name((val) => set({ isDownloading: typeof val === "function" ? val(get2().isDownloading) : val }), "setIsDownloading"),
      searchQuery: "",
      setSearchQuery: /* @__PURE__ */ __name((val) => set({ searchQuery: typeof val === "function" ? val(get2().searchQuery) : val }), "setSearchQuery"),
      dropTarget: null,
      setDropTarget: /* @__PURE__ */ __name((val) => set({ dropTarget: typeof val === "function" ? val(get2().dropTarget) : val }), "setDropTarget"),
      // --- MODAL DATA ---
      // Stores data associated with open modals (e.g., which user profile to show)
      modalData: {},
      // --- PANEL STATES ---
      panels: {
        userList: true,
        memberList: true,
        serverList: true,
        channelList: true
      },
      // --- THEME ---
      theme: "dark",
      accentColor: "#5865F2",
      // --- SIDEBAR ---
      sidebarCollapsed: false,
      mobileSidebarOpen: false,
      // --- CONTEXT MENU ---
      contextMenu: null,
      // { x, y, type, data }
      // --- ACTIONS ---
      openModal: /* @__PURE__ */ __name((modalName, data = null) => set((state) => ({
        modals: { ...state.modals, [modalName]: true },
        modalData: data ? { ...state.modalData, [modalName]: data } : state.modalData
      })), "openModal"),
      closeModal: /* @__PURE__ */ __name((modalName) => set((state) => ({
        modals: { ...state.modals, [modalName]: false },
        modalData: { ...state.modalData, [modalName]: void 0 }
      })), "closeModal"),
      toggleModal: /* @__PURE__ */ __name((modalName) => set((state) => ({
        modals: { ...state.modals, [modalName]: !state.modals[modalName] }
      })), "toggleModal"),
      closeAllModals: /* @__PURE__ */ __name(() => set((state) => ({
        modals: Object.keys(state.modals).reduce((acc, key) => {
          acc[key] = false;
          return acc;
        }, {}),
        modalData: {}
      })), "closeAllModals"),
      getModalData: /* @__PURE__ */ __name((modalName) => get2().modalData[modalName], "getModalData"),
      togglePanel: /* @__PURE__ */ __name((panelName) => set((state) => ({
        panels: { ...state.panels, [panelName]: !state.panels[panelName] }
      })), "togglePanel"),
      setTheme: /* @__PURE__ */ __name((theme) => set({ theme }), "setTheme"),
      setAccentColor: /* @__PURE__ */ __name((color) => set({ accentColor: color }), "setAccentColor"),
      toggleSidebar: /* @__PURE__ */ __name(() => set((state) => ({
        sidebarCollapsed: !state.sidebarCollapsed
      })), "toggleSidebar"),
      setMobileSidebarOpen: /* @__PURE__ */ __name((isOpen) => set({ mobileSidebarOpen: isOpen }), "setMobileSidebarOpen"),
      setContextMenu: /* @__PURE__ */ __name((menu) => set({ contextMenu: menu }), "setContextMenu"),
      clearContextMenu: /* @__PURE__ */ __name(() => set({ contextMenu: null }), "clearContextMenu")
    }),
    {
      name: "pawscord-ui-store",
      partialize: /* @__PURE__ */ __name((state) => ({
        theme: state.theme,
        accentColor: state.accentColor,
        sidebarCollapsed: state.sidebarCollapsed,
        panels: state.panels
      }), "partialize")
    }
  )
);
const BREAKPOINTS = {
  mobile: 768,
  // 0-768px = Mobile
  tablet: 1024,
  // 769-1024px = Tablet
  desktop: 1920,
  // 1025-1920px = Desktop
  ultrawide: 2560
  // 1921+ = Ultrawide
};
const useResponsive = /* @__PURE__ */ __name(() => {
  const [dimensions, setDimensions] = reactExports.useState({
    width: typeof window !== "undefined" ? window.innerWidth : 1920,
    height: typeof window !== "undefined" ? window.innerHeight : 1080
  });
  reactExports.useEffect(() => {
    if (typeof window === "undefined") return;
    let timeoutId;
    const handleResize = /* @__PURE__ */ __name(() => {
      clearTimeout(timeoutId);
      timeoutId = setTimeout(() => {
        setDimensions({
          width: window.innerWidth,
          height: window.innerHeight
        });
      }, 150);
    }, "handleResize");
    handleResize();
    window.addEventListener("resize", handleResize);
    window.addEventListener("orientationchange", handleResize);
    return () => {
      clearTimeout(timeoutId);
      window.removeEventListener("resize", handleResize);
      window.removeEventListener("orientationchange", handleResize);
    };
  }, []);
  const { width, height } = dimensions;
  return {
    // Device type flags
    isMobile: width <= BREAKPOINTS.mobile,
    isTablet: width > BREAKPOINTS.mobile && width <= BREAKPOINTS.tablet,
    isDesktop: width > BREAKPOINTS.tablet && width <= BREAKPOINTS.desktop,
    isUltrawide: width > BREAKPOINTS.desktop,
    // Dimensions
    width,
    height,
    // Orientation
    orientation: height > width ? "portrait" : "landscape",
    // Utility functions
    isSmallScreen: width <= BREAKPOINTS.mobile,
    isMediumScreen: width > BREAKPOINTS.mobile && width <= BREAKPOINTS.tablet,
    isLargeScreen: width > BREAKPOINTS.tablet,
    // Touch device detection
    isTouchDevice: typeof window !== "undefined" && ("ontouchstart" in window || navigator.maxTouchPoints > 0),
    // Breakpoints (for custom comparisons)
    breakpoints: BREAKPOINTS
  };
}, "useResponsive");
const useOptimizedMessages = /* @__PURE__ */ __name((messages, searchQuery, activeChat) => {
  const filteredMessages = reactExports.useMemo(() => {
    if (!messages || !Array.isArray(messages)) return [];
    let filtered = messages;
    if (searchQuery && typeof searchQuery === "string" && searchQuery.trim()) {
      const query = searchQuery.toLowerCase();
      filtered = filtered.filter(
        (msg) => msg.content?.toLowerCase().includes(query) || msg.user?.username?.toLowerCase().includes(query)
      );
    }
    return filtered.sort((a, b) => {
      const dateA = new Date(a.created_at || a.timestamp);
      const dateB = new Date(b.created_at || b.timestamp);
      return dateA - dateB;
    });
  }, [messages, searchQuery]);
  return filteredMessages;
}, "useOptimizedMessages");
const useOnlineUsers = /* @__PURE__ */ __name((users) => {
  return reactExports.useMemo(() => {
    if (!users || !Array.isArray(users)) return [];
    return users.filter((u) => u.is_online || u.online);
  }, [users]);
}, "useOnlineUsers");
const useDebounce$1 = /* @__PURE__ */ __name((callback, delay) => {
  const timeoutRef = reactExports.useRef(null);
  return reactExports.useCallback((...args) => {
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
    }
    timeoutRef.current = setTimeout(() => {
      callback(...args);
    }, delay);
  }, [callback, delay]);
}, "useDebounce$1");
const useThrottle = /* @__PURE__ */ __name((callback, limit) => {
  const lastRun = reactExports.useRef(Date.now());
  return reactExports.useCallback((...args) => {
    const now = Date.now();
    if (now - lastRun.current >= limit) {
      callback(...args);
      lastRun.current = now;
    }
  }, [callback, limit]);
}, "useThrottle");
const useMeasurePerformance = /* @__PURE__ */ __name((componentName) => {
  const renderCount = reactExports.useRef(0);
  const totalTime = reactExports.useRef(0);
  reactExports.useEffect(() => {
    const startTime = performance.now();
    renderCount.current += 1;
    return () => {
      const endTime = performance.now();
      const renderTime = endTime - startTime;
      totalTime.current += renderTime;
      if (renderCount.current % 10 === 0) ;
    };
  });
}, "useMeasurePerformance");
function useDebounce(value, delay = 500) {
  const [debouncedValue, setDebouncedValue] = reactExports.useState(value);
  reactExports.useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);
    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);
  return debouncedValue;
}
__name(useDebounce, "useDebounce");
const MY_LOCAL_IP = "pawscord.com";
const DJANGO_PORT = "443";
const isElectron$1 = (() => {
  if (typeof window === "undefined") return false;
  if (typeof window.require === "function") return true;
  if (typeof process !== "undefined" && process.versions && process.versions.electron) return true;
  if (navigator.userAgent.toLowerCase().includes("electron")) return true;
  if (window.location.protocol === "file:") return true;
  return false;
})();
const isNative$1 = Capacitor.isNativePlatform();
const API_URL_BASE_STRING$1 = (() => {
  if (isNative$1 || isElectron$1) return "https://api.pawscord.com";
  if (!window.location.hostname.includes("localhost") && !window.location.hostname.includes("192.168.")) {
    return "https://api.pawscord.com";
  }
  return `http://${MY_LOCAL_IP}:${DJANGO_PORT}`;
})();
const API_BASE_URL$2 = `${API_URL_BASE_STRING$1}/api`;
const ABSOLUTE_HOST_URL$1 = API_URL_BASE_STRING$1;
if (typeof window !== "undefined") {
  window.__PAWSCORD_API_BASE__ = `${API_URL_BASE_STRING$1}/api`;
}
const MEDIA_BASE_URL$1 = isNative$1 || isElectron$1 || !window.location.hostname.includes("localhost") ? "https://media.pawscord.com" : API_URL_BASE_STRING$1;
const CDN_BASE_URL = "https://media.pawscord.com";
const PRODUCTION_URL = "https://www.pawscord.com";
const WS_PROTOCOL$1 = API_URL_BASE_STRING$1.startsWith("https") ? "wss" : "ws";
const API_HOST$1 = API_URL_BASE_STRING$1.replace(/^https?:\/\//, "");
const GOOGLE_WEB_CLIENT_ID = "774757987258-poa0elqqapnab8eud3tol3h2pilcqe71.apps.googleusercontent.com";
const AuthContext = reactExports.createContext(null);
const API_URL_BASE$2 = API_URL_BASE_STRING$1;
const AuthProvider = /* @__PURE__ */ __name(({ children }) => {
  const storedToken = localStorage.getItem("access_token");
  const initialAuth = (() => {
    if (!storedToken) return false;
    try {
      const decoded = jwtDecode(storedToken);
      return decoded.exp > Date.now() / 1e3;
    } catch {
      return false;
    }
  })();
  const [user, setUser] = reactExports.useState(initialAuth ? { username: localStorage.getItem("chat_username") || "" } : null);
  const [token, setToken] = reactExports.useState(storedToken);
  const [isAuthenticated, setIsAuthenticated] = reactExports.useState(initialAuth);
  const [isLoading, setIsLoading] = reactExports.useState(false);
  const refreshTimerRef = reactExports.useRef(null);
  const refreshAccessToken = reactExports.useCallback(async () => {
    const refreshToken2 = localStorage.getItem("refresh_token");
    if (!refreshToken2) {
      console.warn("âš ï¸ [Auth] No refresh token available");
      logout();
      return false;
    }
    try {
      const response = await fetch(`${API_URL_BASE$2}/api/auth/token/refresh/`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ refresh: refreshToken2 })
      });
      if (response.ok) {
        const data = await response.json();
        localStorage.setItem("access_token", data.access);
        if (data.refresh) {
          localStorage.setItem("refresh_token", data.refresh);
        }
        const decoded = jwtDecode(data.access);
        setToken(data.access);
        setUser({ username: decoded.username });
        setIsAuthenticated(true);
        scheduleTokenRefresh(data.access);
        return true;
      } else {
        console.error("âŒ [Auth] Token refresh failed:", response.status);
        logout();
        return false;
      }
    } catch (error) {
      console.error("âŒ [Auth] Token refresh error:", error);
      logout();
      return false;
    }
  }, []);
  const scheduleTokenRefresh = reactExports.useCallback((accessToken) => {
    if (refreshTimerRef.current) {
      clearTimeout(refreshTimerRef.current);
    }
    try {
      const decoded = jwtDecode(accessToken);
      const currentTime = Date.now() / 1e3;
      const expiresIn = decoded.exp - currentTime;
      const refreshTime = Math.max((expiresIn - 300) * 1e3, 6e4);
      refreshTimerRef.current = setTimeout(() => {
        refreshAccessToken();
      }, refreshTime);
    } catch (error) {
      console.error("âŒ [Auth] Failed to schedule token refresh:", error);
    }
  }, [refreshAccessToken]);
  reactExports.useEffect(() => {
    const checkToken = /* @__PURE__ */ __name(async () => {
      const storedToken2 = localStorage.getItem("access_token");
      if (storedToken2) {
        try {
          const decoded = jwtDecode(storedToken2);
          const currentTime = Date.now() / 1e3;
          const gracePeriod = 5 * 60;
          const isTokenActuallyValid = decoded.exp > currentTime;
          const isWithinGrace = decoded.exp > currentTime - gracePeriod;
          if (isTokenActuallyValid) {
            setToken(storedToken2);
            setUser({ username: decoded.username });
            setIsAuthenticated(true);
            localStorage.setItem("chat_username", decoded.username);
            scheduleTokenRefresh(storedToken2);
          } else if (isWithinGrace) {
            console.warn("âš ï¸ [Auth] Token expired but within grace, refreshing first...");
            const refreshed = await refreshAccessToken();
            if (!refreshed) {
              console.error("âŒ [Auth] Grace period refresh failed");
            }
          } else {
            console.warn("âš ï¸ [Auth] Token expired beyond grace period, attempting refresh...");
            refreshAccessToken();
          }
        } catch (e) {
          console.error("âŒ [Auth] Invalid token:", e);
          logout();
        }
      }
    }, "checkToken");
    checkToken();
    return () => {
      if (refreshTimerRef.current) {
        clearTimeout(refreshTimerRef.current);
      }
    };
  }, [scheduleTokenRefresh, refreshAccessToken]);
  const login = /* @__PURE__ */ __name((accessToken, refreshToken2) => {
    try {
      localStorage.setItem("access_token", accessToken);
      localStorage.setItem("refresh_token", refreshToken2);
      const decoded = jwtDecode(accessToken);
      localStorage.setItem("chat_username", decoded.username);
      setToken(accessToken);
      setUser({ username: decoded.username });
      setIsAuthenticated(true);
      scheduleTokenRefresh(accessToken);
    } catch (error) {
      console.error("âŒ [Auth] Login failed:", error);
      logout();
    }
  }, "login");
  const logout = reactExports.useCallback(() => {
    if (refreshTimerRef.current) {
      clearTimeout(refreshTimerRef.current);
    }
    localStorage.removeItem("access_token");
    localStorage.removeItem("refresh_token");
    localStorage.removeItem("chat_username");
    setToken(null);
    setUser(null);
    setIsAuthenticated(false);
  }, []);
  const authValue = reactExports.useMemo(() => ({
    user,
    token,
    isAuthenticated,
    login,
    logout,
    isLoading,
    refreshAccessToken
  }), [user, token, isAuthenticated, login, logout, isLoading, refreshAccessToken]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(AuthContext.Provider, { value: authValue, children });
}, "AuthProvider");
const useAuth = /* @__PURE__ */ __name(() => reactExports.useContext(AuthContext), "useAuth");
const logger = {
  log: /* @__PURE__ */ __name((...args) => {
  }, "log"),
  warn: /* @__PURE__ */ __name((...args) => {
  }, "warn"),
  error: /* @__PURE__ */ __name((...args) => {
    console.error(...args);
  }, "error"),
  debug: /* @__PURE__ */ __name((...args) => {
  }, "debug"),
  // Kategorili loglama
  voice: /* @__PURE__ */ __name((...args) => {
  }, "voice"),
  webrtc: /* @__PURE__ */ __name((...args) => {
  }, "webrtc"),
  signal: /* @__PURE__ */ __name((...args) => {
  }, "signal"),
  audio: /* @__PURE__ */ __name((...args) => {
  }, "audio")
};
let toastContainer = null;
function escapeHTML(str) {
  if (typeof str !== "string") return "";
  return str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
}
__name(escapeHTML, "escapeHTML");
function initToastContainer() {
  if (!toastContainer) {
    toastContainer = document.createElement("div");
    toastContainer.id = "toast-container";
    toastContainer.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 999999;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: none;
        `;
    document.body.appendChild(toastContainer);
  }
  return toastContainer;
}
__name(initToastContainer, "initToastContainer");
function showToast(message, type = "info", duration = 3e3) {
  const container = initToastContainer();
  const toast2 = document.createElement("div");
  toast2.className = `toast toast-${type}`;
  let icon = "â„¹ï¸";
  let bgColor = "#3b82f6";
  switch (type) {
    case "success":
      icon = "âœ…";
      bgColor = "#10b981";
      break;
    case "error":
      icon = "âŒ";
      bgColor = "#ef4444";
      break;
    case "warning":
      icon = "âš ï¸";
      bgColor = "#f59e0b";
      break;
    case "info":
      icon = "â„¹ï¸";
      bgColor = "#3b82f6";
      break;
  }
  toast2.style.cssText = `
        background: ${bgColor};
        color: white;
        padding: 12px 20px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        display: flex;
        align-items: center;
        gap: 10px;
        min-width: 300px;
        max-width: 500px;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        font-size: 14px;
        pointer-events: all;
        animation: slideIn 0.3s ease-out;
        transition: opacity 0.3s ease-out;
    `;
  toast2.innerHTML = `
        <span style="font-size: 20px;">${icon}</span>
        <span style="flex: 1;">${escapeHTML(message)}</span>
        <button onclick="this.parentElement.remove()" style="
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        " onmouseover="this.style.background='rgba(255,255,255,0.3)'" 
           onmouseout="this.style.background='rgba(255,255,255,0.2)'">Ã—</button>
    `;
  container.appendChild(toast2);
  const style = document.createElement("style");
  style.textContent = `
        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        @keyframes slideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(400px);
                opacity: 0;
            }
        }
    `;
  if (!document.getElementById("toast-styles")) {
    style.id = "toast-styles";
    document.head.appendChild(style);
  }
  setTimeout(() => {
    toast2.style.animation = "slideOut 0.3s ease-out";
    setTimeout(() => toast2.remove(), 300);
  }, duration);
}
__name(showToast, "showToast");
const toast = {
  success: /* @__PURE__ */ __name((message, duration) => showToast(message, "success", duration), "success"),
  error: /* @__PURE__ */ __name((message, duration) => showToast(message, "error", duration), "error"),
  warning: /* @__PURE__ */ __name((message, duration) => showToast(message, "warning", duration), "warning"),
  info: /* @__PURE__ */ __name((message, duration) => showToast(message, "info", duration), "info")
};
if (typeof window !== "undefined") {
  window.toast = toast;
  window.showToast = showToast;
}
const _SpatialAudioEngine = class _SpatialAudioEngine {
  constructor() {
    this.audioContext = null;
    this.masterGain = null;
    this.spatialNodes = {};
    this.listenerPosition = { x: 0, y: 0, z: 0 };
    this.initialized = false;
  }
  /**
   * Initialize the audio engine
   */
  async initialize() {
    if (this.initialized) return;
    try {
      const AudioContext2 = window.AudioContext || window.webkitAudioContext;
      this.audioContext = new AudioContext2();
      this.masterGain = this.audioContext.createGain();
      this.masterGain.gain.value = 1;
      this.masterGain.connect(this.audioContext.destination);
      if (this.audioContext.state === "suspended") {
        await this.audioContext.resume();
      }
      this.setupListener();
      this.initialized = true;
    } catch (error) {
      console.error("Failed to initialize spatial audio:", error);
      throw error;
    }
  }
  /**
   * Set up the audio listener (user's ears)
   */
  setupListener() {
    const listener = this.audioContext.listener;
    if (listener.positionX) {
      listener.positionX.value = this.listenerPosition.x;
      listener.positionY.value = this.listenerPosition.y;
      listener.positionZ.value = this.listenerPosition.z;
    } else {
      listener.setPosition(
        this.listenerPosition.x,
        this.listenerPosition.y,
        this.listenerPosition.z
      );
    }
    if (listener.forwardX) {
      listener.forwardX.value = 0;
      listener.forwardY.value = 0;
      listener.forwardZ.value = -1;
      listener.upX.value = 0;
      listener.upY.value = 1;
      listener.upZ.value = 0;
    } else {
      listener.setOrientation(0, 0, -1, 0, 1, 0);
    }
  }
  /**
   * Add a user's audio stream to spatial audio processing
   * @param {string} username - User identifier
   * @param {MediaStream} stream - User's audio stream
   * @param {Object} position - 3D position {x, y, z}
   */
  addUser(username, stream, position = { x: 0, y: 0, z: -1 }) {
    if (!this.initialized) {
      console.warn("Spatial audio not initialized");
      return null;
    }
    if (this.spatialNodes[username]) {
      this.removeUser(username);
    }
    try {
      const source = this.audioContext.createMediaStreamSource(stream);
      const panner = this.audioContext.createPanner();
      panner.panningModel = "HRTF";
      panner.distanceModel = "inverse";
      panner.refDistance = 1;
      panner.maxDistance = 1e4;
      panner.rolloffFactor = 1.5;
      panner.coneInnerAngle = 360;
      panner.coneOuterAngle = 360;
      panner.coneOuterGain = 0;
      this.setUserPosition(username, position, panner);
      const gain = this.audioContext.createGain();
      gain.gain.value = 1;
      const analyser = this.audioContext.createAnalyser();
      analyser.fftSize = 256;
      analyser.smoothingTimeConstant = 0.8;
      source.connect(analyser);
      analyser.connect(panner);
      panner.connect(gain);
      gain.connect(this.masterGain);
      this.spatialNodes[username] = {
        source,
        panner,
        gain,
        analyser,
        position,
        audioElement: null
      };
      return this.spatialNodes[username];
    } catch (error) {
      console.error(`Failed to add spatial audio for ${username}:`, error);
      return null;
    }
  }
  /**
   * Update user's 3D position
   * @param {string} username - User identifier
   * @param {Object} position - New position {x, y, z}
   */
  setUserPosition(username, position, pannerNode = null) {
    const panner = pannerNode || this.spatialNodes[username]?.panner;
    if (!panner) return;
    if (panner.positionX) {
      panner.positionX.setValueAtTime(position.x, this.audioContext.currentTime);
      panner.positionY.setValueAtTime(position.y, this.audioContext.currentTime);
      panner.positionZ.setValueAtTime(position.z, this.audioContext.currentTime);
    } else {
      panner.setPosition(position.x, position.y, position.z);
    }
    if (this.spatialNodes[username]) {
      this.spatialNodes[username].position = position;
    }
  }
  /**
   * Set user's volume
   * @param {string} username - User identifier
   * @param {number} volume - Volume level (0.0 to 1.0)
   */
  setUserVolume(username, volume) {
    const node = this.spatialNodes[username];
    if (!node) return;
    const clampedVolume = Math.max(0, Math.min(1, volume));
    node.gain.gain.setValueAtTime(clampedVolume, this.audioContext.currentTime);
  }
  /**
   * Get voice activity level
   * @param {string} username - User identifier
   * @returns {number} - Activity level (0-100)
   */
  getVoiceActivity(username) {
    const node = this.spatialNodes[username];
    if (!node) return 0;
    const analyser = node.analyser;
    const dataArray = new Uint8Array(analyser.frequencyBinCount);
    analyser.getByteFrequencyData(dataArray);
    const sum = dataArray.reduce((acc, val) => acc + val, 0);
    const average = sum / dataArray.length;
    return Math.round(average / 255 * 100);
  }
  /**
   * Remove user from spatial audio
   * @param {string} username - User identifier
   */
  removeUser(username) {
    const node = this.spatialNodes[username];
    if (!node) return;
    try {
      node.source.disconnect();
      node.analyser.disconnect();
      node.panner.disconnect();
      node.gain.disconnect();
      delete this.spatialNodes[username];
    } catch (error) {
      console.error(`Error removing spatial audio for ${username}:`, error);
    }
  }
  /**
   * Update listener position (camera/user position)
   * @param {Object} position - New position {x, y, z}
   */
  updateListenerPosition(position) {
    this.listenerPosition = position;
    this.setupListener();
  }
  /**
   * Set master volume
   * @param {number} volume - Volume level (0.0 to 1.0)
   */
  setMasterVolume(volume) {
    if (!this.masterGain) return;
    const clampedVolume = Math.max(0, Math.min(1, volume));
    this.masterGain.gain.setValueAtTime(clampedVolume, this.audioContext.currentTime);
  }
  /**
   * Mute/unmute user
   * @param {string} username - User identifier
   * @param {boolean} muted - Mute state
   */
  setUserMuted(username, muted) {
    this.setUserVolume(username, muted ? 0 : 1);
  }
  /**
   * Clean up and destroy engine
   */
  destroy() {
    Object.keys(this.spatialNodes).forEach((username) => {
      this.removeUser(username);
    });
    if (this.audioContext) {
      this.audioContext.close();
      this.audioContext = null;
    }
    this.initialized = false;
  }
  /**
   * Get distance between listener and user
   * @param {string} username - User identifier
   * @returns {number} - Distance
   */
  getUserDistance(username) {
    const node = this.spatialNodes[username];
    if (!node) return Infinity;
    const pos = node.position;
    const listener = this.listenerPosition;
    return Math.sqrt(
      Math.pow(pos.x - listener.x, 2) + Math.pow(pos.y - listener.y, 2) + Math.pow(pos.z - listener.z, 2)
    );
  }
  /**
   * Create a circular arrangement of users
   * Useful for voice channels with multiple users
   * @param {Array<string>} usernames - Array of usernames
   * @param {number} radius - Circle radius
   * @returns {Object} - Positions map { username: {x, y, z} }
   */
  arrangeUsersInCircle(usernames, radius = 3) {
    const positions = {};
    const angleStep = 2 * Math.PI / usernames.length;
    usernames.forEach((username, index) => {
      const angle = angleStep * index;
      const position = {
        x: Math.cos(angle) * radius,
        y: 0,
        z: Math.sin(angle) * radius
      };
      positions[username] = position;
      this.setUserPosition(username, position);
    });
    return positions;
  }
};
__name(_SpatialAudioEngine, "SpatialAudioEngine");
let SpatialAudioEngine = _SpatialAudioEngine;
const spatialAudio = new SpatialAudioEngine();
const API_URL_BASE$1 = API_URL_BASE_STRING$1;
let isRefreshing = false;
let refreshSubscribers = [];
const subscribeTokenRefresh = /* @__PURE__ */ __name((callback) => {
  refreshSubscribers.push(callback);
}, "subscribeTokenRefresh");
const onTokenRefreshed = /* @__PURE__ */ __name((newToken) => {
  refreshSubscribers.forEach((callback) => callback(newToken));
  refreshSubscribers = [];
}, "onTokenRefreshed");
const isTokenExpired = /* @__PURE__ */ __name((token) => {
  if (!token) return true;
  try {
    const decoded = jwtDecode(token);
    const currentTime = Date.now() / 1e3;
    return decoded.exp < currentTime + 30;
  } catch {
    return true;
  }
}, "isTokenExpired");
const refreshToken = /* @__PURE__ */ __name(async () => {
  const refreshTokenValue = localStorage.getItem("refresh_token");
  if (!refreshTokenValue) {
    throw new Error("No refresh token available");
  }
  const response = await fetch(`${API_URL_BASE$1}/api/auth/token/refresh/`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ refresh: refreshTokenValue })
  });
  if (!response.ok) {
    throw new Error("Token refresh failed");
  }
  const data = await response.json();
  localStorage.setItem("access_token", data.access);
  if (data.refresh) {
    localStorage.setItem("refresh_token", data.refresh);
  }
  return data.access;
}, "refreshToken");
const authFetch = /* @__PURE__ */ __name(async (url, options = {}) => {
  let accessToken = localStorage.getItem("access_token");
  if (isTokenExpired(accessToken)) {
    if (!isRefreshing) {
      isRefreshing = true;
      try {
        accessToken = await refreshToken();
        onTokenRefreshed(accessToken);
      } catch (error) {
        console.error("âŒ [AuthFetch] Token refresh failed:", error);
        isRefreshing = false;
        window.dispatchEvent(new CustomEvent("auth:logout"));
        throw error;
      } finally {
        isRefreshing = false;
      }
    } else {
      accessToken = await new Promise((resolve) => {
        subscribeTokenRefresh((token) => resolve(token));
      });
    }
  }
  const headers = {
    ...options.headers,
    "Authorization": `Bearer ${accessToken}`
  };
  let response = await fetch(url, { ...options, headers });
  if (response.status === 401) {
    console.warn("âš ï¸ [AuthFetch] Got 401, attempting token refresh...");
    if (!isRefreshing) {
      isRefreshing = true;
      try {
        accessToken = await refreshToken();
        onTokenRefreshed(accessToken);
        headers["Authorization"] = `Bearer ${accessToken}`;
        response = await fetch(url, { ...options, headers });
      } catch (error) {
        console.error("âŒ [AuthFetch] Retry refresh failed:", error);
        window.dispatchEvent(new CustomEvent("auth:logout"));
        throw error;
      } finally {
        isRefreshing = false;
      }
    } else {
      accessToken = await new Promise((resolve) => {
        subscribeTokenRefresh((token) => resolve(token));
      });
      headers["Authorization"] = `Bearer ${accessToken}`;
      response = await fetch(url, { ...options, headers });
    }
  }
  return response;
}, "authFetch");
const DEFAULT_ICE_SERVERS = [
  // Google STUN (Reliable, public, free)
  { urls: "stun:stun.l.google.com:19302" },
  { urls: "stun:stun1.l.google.com:19302" },
  { urls: "stun:stun2.l.google.com:19302" },
  { urls: "stun:stun3.l.google.com:19302" },
  { urls: "stun:stun4.l.google.com:19302" },
  // ðŸ”¥ YENÄ°: Ek STUN sunucularÄ± (redundancy)
  { urls: "stun:stun.cloudflare.com:3478" },
  { urls: "stun:stun.services.mozilla.com:3478" },
  { urls: "stun:stun.stunprotocol.org:3478" },
  // ðŸ”¥ FALLBACK TURN: Sunucu TURN'a eriÅŸilemezse kullanÄ±lacak (OpenRelay - Ã¼cretsiz)
  {
    urls: "turn:openrelay.metered.ca:80",
    username: "openrelayproject",
    credential: "openrelayproject"
  },
  {
    urls: "turn:openrelay.metered.ca:443",
    username: "openrelayproject",
    credential: "openrelayproject"
  },
  {
    urls: "turn:openrelay.metered.ca:443?transport=tcp",
    username: "openrelayproject",
    credential: "openrelayproject"
  }
];
let RTC_CONFIGURATION = {
  iceServers: DEFAULT_ICE_SERVERS,
  iceCandidatePoolSize: 10,
  iceTransportPolicy: "all",
  bundlePolicy: "max-bundle",
  rtcpMuxPolicy: "require"
};
const setRtcIceServers = /* @__PURE__ */ __name((servers) => {
  RTC_CONFIGURATION = { ...RTC_CONFIGURATION, iceServers: servers };
}, "setRtcIceServers");
function applyProfessionalAudioFilters(stream, globalAudioContextRef) {
  try {
    const voiceSettings = JSON.parse(localStorage.getItem("voice_settings") || "{}");
    const level = voiceSettings.audio?.noiseSuppressionLevel || "high";
    const levelSettings = {
      low: {
        gateThreshold: -70,
        // dB eÅŸiÄŸi
        compressorThreshold: -15,
        compressorRatio: 2,
        highPassFreq: 50,
        // 50Hz altÄ± kes (fan, AC sesi)
        lowPassFreq: 14e3,
        // 14kHz Ã¼stÃ¼ kes
        gateRelease: 0.3,
        speechThreshold: 20
        // KonuÅŸma algÄ±lama eÅŸiÄŸi
      },
      medium: {
        gateThreshold: -60,
        compressorThreshold: -20,
        compressorRatio: 3,
        highPassFreq: 80,
        // 80Hz altÄ± kes
        lowPassFreq: 12e3,
        gateRelease: 0.25,
        speechThreshold: 25
      },
      high: {
        gateThreshold: -50,
        // ðŸ”¥ Daha agresif
        compressorThreshold: -25,
        compressorRatio: 4,
        highPassFreq: 100,
        // ðŸ”¥ 100Hz altÄ± kes (daha agresif)
        lowPassFreq: 1e4,
        // ðŸ”¥ 10kHz Ã¼stÃ¼ kes
        gateRelease: 0.2,
        speechThreshold: 30
        // ðŸ”¥ Daha yÃ¼ksek eÅŸik
      },
      aggressive: {
        gateThreshold: -45,
        // ðŸ”¥ Ã‡OK agresif
        compressorThreshold: -30,
        compressorRatio: 6,
        highPassFreq: 120,
        // ðŸ”¥ 120Hz altÄ± kes
        lowPassFreq: 8e3,
        // ðŸ”¥ 8kHz Ã¼stÃ¼ kes (tiz gÃ¼rÃ¼ltÃ¼ler)
        gateRelease: 0.15,
        speechThreshold: 35
        // ðŸ”¥ YÃ¼ksek eÅŸik
      }
    };
    const settings2 = levelSettings[level] || levelSettings.high;
    if (!globalAudioContextRef.current) {
      const AudioContext2 = window.AudioContext || window.webkitAudioContext;
      globalAudioContextRef.current = new AudioContext2({
        sampleRate: 48e3,
        // WebRTC standart sample rate
        latencyHint: "interactive"
        // DÃ¼ÅŸÃ¼k gecikme modu
      });
    }
    const audioContext = globalAudioContextRef.current;
    if (audioContext.state === "suspended") {
      audioContext.resume().then(() => {
      });
    }
    const source = audioContext.createMediaStreamSource(stream);
    const noiseGateNode = audioContext.createGain();
    let isGateOpen = true;
    const GATE_THRESHOLD = settings2.gateThreshold;
    const GATE_ATTACK = 5e-3;
    const GATE_RELEASE = settings2.gateRelease;
    const compressor = audioContext.createDynamicsCompressor();
    compressor.threshold.value = settings2.compressorThreshold;
    compressor.knee.value = 30;
    compressor.ratio.value = Math.min(settings2.compressorRatio, 4);
    compressor.attack.value = 3e-3;
    compressor.release.value = 0.15;
    const highPassFilter = audioContext.createBiquadFilter();
    highPassFilter.type = "highpass";
    highPassFilter.frequency.value = settings2.highPassFreq;
    highPassFilter.Q.value = 0.707;
    const lowPassFilter = audioContext.createBiquadFilter();
    lowPassFilter.type = "lowpass";
    lowPassFilter.frequency.value = settings2.lowPassFreq;
    lowPassFilter.Q.value = 0.707;
    const notchFilter = audioContext.createBiquadFilter();
    notchFilter.type = "notch";
    notchFilter.frequency.value = 50;
    notchFilter.Q.value = 10;
    const deEsser = audioContext.createBiquadFilter();
    deEsser.type = "peaking";
    deEsser.frequency.value = 6e3;
    deEsser.Q.value = 1;
    deEsser.gain.value = -3;
    const analyser = audioContext.createAnalyser();
    analyser.fftSize = 2048;
    analyser.smoothingTimeConstant = 0.85;
    const dataArray = new Uint8Array(analyser.frequencyBinCount);
    let noiseProfile = new Float32Array(analyser.frequencyBinCount);
    let learningPhase = true;
    let silentFrames = 0;
    const learnNoiseProfile = /* @__PURE__ */ __name(() => {
      analyser.getByteFrequencyData(dataArray);
      const average = dataArray.reduce((a, b) => a + b) / dataArray.length;
      if (average < 20) {
        silentFrames++;
        if (silentFrames > 10) {
          for (let i = 0; i < dataArray.length; i++) {
            noiseProfile[i] = Math.max(noiseProfile[i], dataArray[i]);
          }
        }
      } else {
        silentFrames = 0;
      }
      if (learningPhase && silentFrames > 50) {
        learningPhase = false;
      }
    }, "learnNoiseProfile");
    const speechThreshold = settings2.speechThreshold || 25;
    const updateNoiseGate = /* @__PURE__ */ __name(() => {
      analyser.getByteFrequencyData(dataArray);
      const speechRange = dataArray.slice(8, 120);
      const speechLevel = speechRange.reduce((a, b) => a + b) / speechRange.length;
      const cleanSignal = speechLevel - (noiseProfile[50] || 0);
      const currentTime = audioContext.currentTime;
      if (cleanSignal > speechThreshold) {
        if (!isGateOpen) {
          noiseGateNode.gain.setTargetAtTime(1, currentTime, GATE_ATTACK);
          isGateOpen = true;
        }
      } else {
        if (isGateOpen) {
          noiseGateNode.gain.setTargetAtTime(0, currentTime, GATE_RELEASE);
          isGateOpen = false;
        }
      }
      if (learningPhase || Math.random() < 0.01) {
        learnNoiseProfile();
      }
    }, "updateNoiseGate");
    const noiseGateInterval = setInterval(updateNoiseGate, 30);
    source.connect(highPassFilter);
    highPassFilter.connect(notchFilter);
    notchFilter.connect(lowPassFilter);
    lowPassFilter.connect(deEsser);
    deEsser.connect(compressor);
    compressor.connect(noiseGateNode);
    noiseGateNode.connect(analyser);
    const destination = audioContext.createMediaStreamDestination();
    noiseGateNode.connect(destination);
    destination.stream.addEventListener("inactive", () => {
      clearInterval(noiseGateInterval);
    });
    return destination.stream;
  } catch (error) {
    console.error("âŒ [Audio] Could not apply professional filters:", error);
    return stream;
  }
}
__name(applyProfessionalAudioFilters, "applyProfessionalAudioFilters");
function createVoiceEffect(effectType, intensity, audioContext, sourceStream) {
  const source = audioContext.createMediaStreamSource(sourceStream);
  const destination = audioContext.createMediaStreamDestination();
  const nodes = [];
  const normalizedIntensity = intensity / 100;
  switch (effectType) {
    case "robot": {
      const oscillator = audioContext.createOscillator();
      const gainOsc = audioContext.createGain();
      const waveshaper = audioContext.createWaveShaper();
      oscillator.type = "sawtooth";
      oscillator.frequency.value = 50 + normalizedIntensity * 100;
      gainOsc.gain.value = 0.3 + normalizedIntensity * 0.4;
      const curve = new Float32Array(256);
      for (let i = 0; i < 256; i++) {
        const x = i / 128 - 1;
        curve[i] = Math.tanh(x * (1 + normalizedIntensity * 3));
      }
      waveshaper.curve = curve;
      oscillator.connect(gainOsc);
      source.connect(waveshaper);
      waveshaper.connect(destination);
      oscillator.start();
      nodes.push(oscillator, gainOsc, waveshaper);
      break;
    }
    case "echo": {
      const delay = audioContext.createDelay(1);
      const feedback = audioContext.createGain();
      const wetGain = audioContext.createGain();
      const dryGain = audioContext.createGain();
      delay.delayTime.value = 0.1 + normalizedIntensity * 0.4;
      feedback.gain.value = 0.2 + normalizedIntensity * 0.5;
      wetGain.gain.value = 0.3 + normalizedIntensity * 0.4;
      dryGain.gain.value = 1 - normalizedIntensity * 0.3;
      source.connect(dryGain);
      source.connect(delay);
      delay.connect(feedback);
      feedback.connect(delay);
      delay.connect(wetGain);
      dryGain.connect(destination);
      wetGain.connect(destination);
      nodes.push(delay, feedback, wetGain, dryGain);
      break;
    }
    case "deep": {
      const biquadFilter = audioContext.createBiquadFilter();
      const gainNode = audioContext.createGain();
      biquadFilter.type = "lowshelf";
      biquadFilter.frequency.value = 500;
      biquadFilter.gain.value = 10 + normalizedIntensity * 15;
      gainNode.gain.value = 1.2;
      source.connect(biquadFilter);
      biquadFilter.connect(gainNode);
      gainNode.connect(destination);
      nodes.push(biquadFilter, gainNode);
      break;
    }
    case "high": {
      const highFilter = audioContext.createBiquadFilter();
      const gainNode = audioContext.createGain();
      highFilter.type = "highshelf";
      highFilter.frequency.value = 1e3;
      highFilter.gain.value = 8 + normalizedIntensity * 12;
      gainNode.gain.value = 0.9;
      source.connect(highFilter);
      highFilter.connect(gainNode);
      gainNode.connect(destination);
      nodes.push(highFilter, gainNode);
      break;
    }
    case "radio": {
      const lowpass = audioContext.createBiquadFilter();
      const highpass = audioContext.createBiquadFilter();
      const distortion = audioContext.createWaveShaper();
      lowpass.type = "lowpass";
      lowpass.frequency.value = 3e3 - normalizedIntensity * 1e3;
      highpass.type = "highpass";
      highpass.frequency.value = 300 + normalizedIntensity * 200;
      const curve = new Float32Array(256);
      for (let i = 0; i < 256; i++) {
        const x = i / 128 - 1;
        curve[i] = Math.sign(x) * Math.pow(Math.abs(x), 0.8);
      }
      distortion.curve = curve;
      source.connect(highpass);
      highpass.connect(lowpass);
      lowpass.connect(distortion);
      distortion.connect(destination);
      nodes.push(lowpass, highpass, distortion);
      break;
    }
    case "reverb": {
      const convolver = audioContext.createConvolver();
      const wetGain = audioContext.createGain();
      const dryGain = audioContext.createGain();
      const sampleRate = audioContext.sampleRate;
      const length = sampleRate * (0.5 + normalizedIntensity * 2);
      const impulse = audioContext.createBuffer(2, length, sampleRate);
      for (let channel = 0; channel < 2; channel++) {
        const channelData = impulse.getChannelData(channel);
        for (let i = 0; i < length; i++) {
          channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2);
        }
      }
      convolver.buffer = impulse;
      wetGain.gain.value = 0.3 + normalizedIntensity * 0.5;
      dryGain.gain.value = 1 - normalizedIntensity * 0.2;
      source.connect(dryGain);
      source.connect(convolver);
      convolver.connect(wetGain);
      dryGain.connect(destination);
      wetGain.connect(destination);
      nodes.push(convolver, wetGain, dryGain);
      break;
    }
    default:
      source.connect(destination);
  }
  return { nodes, outputStream: destination.stream };
}
__name(createVoiceEffect, "createVoiceEffect");
function useVoiceSettings() {
  const [noiseGateThreshold, setNoiseGateThreshold] = reactExports.useState(() => {
    try {
      return parseInt(localStorage.getItem("pawscord_noise_gate")) || -50;
    } catch {
      return -50;
    }
  });
  const [isNoiseGateEnabled, setIsNoiseGateEnabled] = reactExports.useState(() => {
    try {
      return localStorage.getItem("pawscord_noise_gate_enabled") !== "false";
    } catch {
      return true;
    }
  });
  const [isVisualizerEnabled, setIsVisualizerEnabled] = reactExports.useState(() => {
    try {
      return localStorage.getItem("pawscord_visualizer") === "true";
    } catch {
      return false;
    }
  });
  const [remoteVolumes, setRemoteVolumes] = reactExports.useState(() => {
    try {
      return JSON.parse(localStorage.getItem("pawscord_user_volumes")) || {};
    } catch {
      return {};
    }
  });
  const [mutedUsers, setMutedUsers] = reactExports.useState(/* @__PURE__ */ new Set());
  const [isSpatialAudioEnabled, setIsSpatialAudioEnabled] = reactExports.useState(() => {
    try {
      return localStorage.getItem("pawscord_spatial_audio") === "true";
    } catch {
      return false;
    }
  });
  const [vadSensitivity, setVadSensitivity] = reactExports.useState(() => {
    try {
      return parseInt(localStorage.getItem("pawscord_vad_sensitivity")) || 45;
    } catch {
      return 45;
    }
  });
  const [isNoiseSuppressionEnabled, setIsNoiseSuppressionEnabled] = reactExports.useState(() => {
    try {
      const saved = localStorage.getItem("pawscord_noise_suppression");
      return saved === null ? true : saved === "true";
    } catch {
      return true;
    }
  });
  const [noiseSuppressionLevel, setNoiseSuppressionLevel] = reactExports.useState(() => {
    try {
      const voiceSettings = JSON.parse(localStorage.getItem("voice_settings") || "{}");
      return voiceSettings.audio?.noiseSuppressionLevel || "medium";
    } catch {
      return "medium";
    }
  });
  const [screenShareQuality, setScreenShareQuality] = reactExports.useState(() => {
    try {
      return localStorage.getItem("pawscord_screen_quality") || "1080p";
    } catch {
      return "1080p";
    }
  });
  const [screenShareFPS, setScreenShareFPS] = reactExports.useState(() => {
    try {
      return parseInt(localStorage.getItem("pawscord_screen_fps")) || 30;
    } catch {
      return 30;
    }
  });
  const [includeSystemAudio, setIncludeSystemAudio] = reactExports.useState(() => {
    try {
      return localStorage.getItem("pawscord_system_audio") !== "false";
    } catch {
      return false;
    }
  });
  const [isPTTMode, setIsPTTMode] = reactExports.useState(() => {
    try {
      return localStorage.getItem("pawscord_ptt_mode") === "true";
    } catch {
      return false;
    }
  });
  const [pttKey, setPTTKey] = reactExports.useState(() => {
    try {
      return localStorage.getItem("pawscord_ptt_key") || "Space";
    } catch {
      return "Space";
    }
  });
  const [isPTTActive, setIsPTTActive] = reactExports.useState(false);
  reactExports.useEffect(() => {
    localStorage.setItem("pawscord_user_volumes", JSON.stringify(remoteVolumes));
  }, [remoteVolumes]);
  const setRemoteVolume = reactExports.useCallback((targetUsername, volume) => {
    setRemoteVolumes((prev) => ({
      ...prev,
      [targetUsername]: Math.max(0, Math.min(200, volume))
    }));
  }, []);
  const updateVadSensitivity = reactExports.useCallback((newSensitivity) => {
    const clamped = Math.max(20, Math.min(80, newSensitivity));
    setVadSensitivity(clamped);
    localStorage.setItem("pawscord_vad_sensitivity", clamped.toString());
  }, []);
  const updateNoiseSuppressionLevel = reactExports.useCallback((level) => {
    const validLevels = ["low", "medium", "high", "aggressive"];
    const newLevel = validLevels.includes(level) ? level : "high";
    setNoiseSuppressionLevel(newLevel);
    try {
      const voiceSettings = JSON.parse(localStorage.getItem("voice_settings") || "{}");
      voiceSettings.audio = { ...voiceSettings.audio, noiseSuppressionLevel: newLevel };
      localStorage.setItem("voice_settings", JSON.stringify(voiceSettings));
    } catch (e) {
      console.error("[Noise Level] Storage error:", e);
    }
  }, []);
  const updateScreenQuality = reactExports.useCallback((quality) => {
    setScreenShareQuality(quality);
    localStorage.setItem("pawscord_screen_quality", quality);
  }, []);
  const updateScreenFPS = reactExports.useCallback((fps) => {
    const fpsInt = parseInt(fps);
    setScreenShareFPS(fpsInt);
    localStorage.setItem("pawscord_screen_fps", fpsInt.toString());
  }, []);
  const toggleSystemAudio = reactExports.useCallback((enabled) => {
    setIncludeSystemAudio(enabled);
    localStorage.setItem("pawscord_system_audio", enabled.toString());
  }, []);
  const toggleNoiseGate = reactExports.useCallback((enabled) => {
    setIsNoiseGateEnabled(enabled);
    localStorage.setItem("pawscord_noise_gate_enabled", enabled.toString());
  }, []);
  const updateNoiseGateThreshold = reactExports.useCallback((threshold) => {
    const clamped = Math.max(-80, Math.min(-20, threshold));
    setNoiseGateThreshold(clamped);
    localStorage.setItem("pawscord_noise_gate", clamped.toString());
  }, []);
  const toggleVisualizer = reactExports.useCallback((enabled) => {
    setIsVisualizerEnabled(enabled);
    localStorage.setItem("pawscord_visualizer", enabled.toString());
  }, []);
  const updatePTTKey = reactExports.useCallback((key) => {
    setPTTKey(key);
    localStorage.setItem("pawscord_ptt_key", key);
  }, []);
  return {
    // State
    noiseGateThreshold,
    isNoiseGateEnabled,
    isVisualizerEnabled,
    remoteVolumes,
    setRemoteVolumes,
    mutedUsers,
    setMutedUsers,
    isSpatialAudioEnabled,
    setIsSpatialAudioEnabled,
    vadSensitivity,
    isNoiseSuppressionEnabled,
    setIsNoiseSuppressionEnabled,
    noiseSuppressionLevel,
    screenShareQuality,
    screenShareFPS,
    includeSystemAudio,
    isPTTMode,
    setIsPTTMode,
    pttKey,
    isPTTActive,
    setIsPTTActive,
    // Updaters
    setRemoteVolume,
    updateVadSensitivity,
    updateNoiseSuppressionLevel,
    updateScreenQuality,
    updateScreenFPS,
    toggleSystemAudio,
    toggleNoiseGate,
    updateNoiseGateThreshold,
    toggleVisualizer,
    updatePTTKey
  };
}
__name(useVoiceSettings, "useVoiceSettings");
function useRecording({ isInVoice, localAudioStream, remoteStreams, currentRoom }) {
  const [isRecording, setIsRecording] = reactExports.useState(false);
  const [recordingDuration, setRecordingDuration] = reactExports.useState(0);
  const recordingChunksRef = reactExports.useRef([]);
  const mediaRecorderRef = reactExports.useRef(null);
  const recordingIntervalRef = reactExports.useRef(null);
  const startRecording = reactExports.useCallback(() => {
    if (!isInVoice || isRecording) {
      console.warn("[Recording] Cannot start - not in voice or already recording");
      return;
    }
    try {
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      const destination = audioContext.createMediaStreamDestination();
      if (localAudioStream) {
        const localSource = audioContext.createMediaStreamSource(localAudioStream);
        localSource.connect(destination);
      }
      Object.entries(remoteStreams).forEach(([key, stream]) => {
        if (!key.includes("_camera") && !key.includes("_screen")) {
          const audioTracks = stream.getAudioTracks();
          if (audioTracks.length > 0) {
            const remoteSource = audioContext.createMediaStreamSource(stream);
            remoteSource.connect(destination);
          }
        }
      });
      const mediaRecorder = new MediaRecorder(destination.stream, {
        mimeType: "audio/webm;codecs=opus",
        audioBitsPerSecond: 128e3
      });
      recordingChunksRef.current = [];
      mediaRecorder.ondataavailable = (event) => {
        if (event.data.size > 0) {
          recordingChunksRef.current.push(event.data);
        }
      };
      mediaRecorder.onstop = () => {
        const blob = new Blob(recordingChunksRef.current, { type: "audio/webm" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `pawscord-voice-${currentRoom}-${Date.now()}.webm`;
        a.click();
        URL.revokeObjectURL(url);
      };
      mediaRecorder.start(1e3);
      mediaRecorderRef.current = mediaRecorder;
      setIsRecording(true);
      setRecordingDuration(0);
      recordingIntervalRef.current = setInterval(() => {
        setRecordingDuration((prev) => prev + 1);
      }, 1e3);
    } catch (error) {
      console.error("[Recording] Start error:", error);
      toast.error("KayÄ±t baÅŸlatÄ±lamadÄ±: " + error.message);
    }
  }, [isInVoice, isRecording, localAudioStream, remoteStreams, currentRoom]);
  const stopRecording = reactExports.useCallback(() => {
    if (!isRecording) {
      return;
    }
    if (mediaRecorderRef.current && mediaRecorderRef.current.state !== "inactive") {
      mediaRecorderRef.current.stop();
    }
    if (recordingIntervalRef.current) {
      clearInterval(recordingIntervalRef.current);
      recordingIntervalRef.current = null;
    }
    mediaRecorderRef.current = null;
    setIsRecording(false);
    setRecordingDuration(0);
  }, [isRecording]);
  const downloadRecording = reactExports.useCallback(() => {
    if (recordingChunksRef.current.length === 0) {
      toast.warning("HenÃ¼z kayÄ±t yok!");
      return;
    }
    const blob = new Blob(recordingChunksRef.current, { type: "audio/webm" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `pawscord-voice-${currentRoom || "recording"}-${Date.now()}.webm`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }, [currentRoom]);
  return {
    isRecording,
    recordingDuration,
    startRecording,
    stopRecording,
    downloadRecording
  };
}
__name(useRecording, "useRecording");
function useStatsMonitoring() {
  const [connectionStats, setConnectionStats] = reactExports.useState({});
  const statsIntervalRef = reactExports.useRef(null);
  const startStatsMonitoring = reactExports.useCallback((peerConnectionsRef) => {
    if (statsIntervalRef.current) return;
    statsIntervalRef.current = setInterval(async () => {
      const stats = {};
      for (const [username, pc] of Object.entries(peerConnectionsRef.current)) {
        try {
          const report = await pc.getStats();
          let audioStats = null;
          let videoStats = null;
          report.forEach((stat) => {
            if (stat.type === "inbound-rtp" && stat.kind === "audio") {
              audioStats = {
                packetsReceived: stat.packetsReceived,
                packetsLost: stat.packetsLost,
                jitter: stat.jitter,
                bytesReceived: stat.bytesReceived
              };
            }
            if (stat.type === "inbound-rtp" && stat.kind === "video") {
              videoStats = {
                packetsReceived: stat.packetsReceived,
                packetsLost: stat.packetsLost,
                framesDecoded: stat.framesDecoded,
                frameWidth: stat.frameWidth,
                frameHeight: stat.frameHeight
              };
            }
            if (stat.type === "candidate-pair" && stat.state === "succeeded") {
              stats[username] = {
                ...stats[username],
                rtt: stat.currentRoundTripTime * 1e3,
                connectionType: stat.localCandidateId?.includes("relay") ? "TURN" : "STUN/Direct"
              };
            }
          });
          stats[username] = {
            ...stats[username],
            audio: audioStats,
            video: videoStats,
            connectionState: pc.connectionState,
            iceConnectionState: pc.iceConnectionState
          };
        } catch (e) {
          console.warn(`[Stats] Failed to get stats for ${username}:`, e);
        }
      }
      setConnectionStats(stats);
    }, 2e3);
  }, []);
  const stopStatsMonitoring = reactExports.useCallback(() => {
    if (statsIntervalRef.current) {
      clearInterval(statsIntervalRef.current);
      statsIntervalRef.current = null;
      setConnectionStats({});
    }
  }, []);
  return {
    connectionStats,
    startStatsMonitoring,
    stopStatsMonitoring
  };
}
__name(useStatsMonitoring, "useStatsMonitoring");
function useAudioVisualizer({ isVisualizerEnabled, localAudioStream, remoteStreams, isInVoice, globalAudioContextRef }) {
  const [audioVisualizerData, setAudioVisualizerData] = reactExports.useState({
    local: new Uint8Array(128),
    remote: {}
  });
  const visualizerIntervalRef = reactExports.useRef(null);
  const visualizerAnalyserRef = reactExports.useRef(null);
  const startVisualizer = reactExports.useCallback(() => {
    if (!isVisualizerEnabled || !localAudioStream) return;
    if (visualizerIntervalRef.current) return;
    try {
      if (!globalAudioContextRef.current) {
        globalAudioContextRef.current = new (window.AudioContext || window.webkitAudioContext)();
      }
      const audioContext = globalAudioContextRef.current;
      const localAnalyser = audioContext.createAnalyser();
      localAnalyser.fftSize = 256;
      const localSource = audioContext.createMediaStreamSource(localAudioStream);
      localSource.connect(localAnalyser);
      visualizerAnalyserRef.current = { local: localAnalyser, localSource, remote: {} };
      Object.entries(remoteStreams).forEach(([key, stream]) => {
        if (!key.includes("_camera") && !key.includes("_screen")) {
          const remoteAnalyser = audioContext.createAnalyser();
          remoteAnalyser.fftSize = 256;
          const remoteSource = audioContext.createMediaStreamSource(stream);
          remoteSource.connect(remoteAnalyser);
          visualizerAnalyserRef.current.remote[key] = { analyser: remoteAnalyser, source: remoteSource };
        }
      });
      visualizerIntervalRef.current = setInterval(() => {
        const localData = new Uint8Array(128);
        visualizerAnalyserRef.current.local.getByteFrequencyData(localData);
        const remoteData = {};
        Object.entries(visualizerAnalyserRef.current.remote).forEach(([key, { analyser }]) => {
          const data = new Uint8Array(128);
          analyser.getByteFrequencyData(data);
          remoteData[key] = data;
        });
        setAudioVisualizerData({ local: localData, remote: remoteData });
      }, 33);
    } catch (err) {
      console.error("[Visualizer] Failed to start:", err);
    }
  }, [isVisualizerEnabled, localAudioStream, remoteStreams, globalAudioContextRef]);
  const stopVisualizer = reactExports.useCallback(() => {
    if (visualizerIntervalRef.current) {
      clearInterval(visualizerIntervalRef.current);
      visualizerIntervalRef.current = null;
    }
    if (visualizerAnalyserRef.current) {
      try {
        visualizerAnalyserRef.current.localSource?.disconnect();
        Object.values(visualizerAnalyserRef.current.remote).forEach(({ source }) => {
          source?.disconnect();
        });
      } catch (_) {
      }
      visualizerAnalyserRef.current = null;
    }
    setAudioVisualizerData({ local: new Uint8Array(128), remote: {} });
  }, []);
  reactExports.useEffect(() => {
    if (isInVoice && isVisualizerEnabled) {
      startVisualizer();
    } else {
      stopVisualizer();
    }
    return () => stopVisualizer();
  }, [isInVoice, isVisualizerEnabled, startVisualizer, stopVisualizer]);
  return {
    audioVisualizerData,
    startVisualizer,
    stopVisualizer
  };
}
__name(useAudioVisualizer, "useAudioVisualizer");
const VoiceContext = reactExports.createContext(null);
const VoiceProvider = /* @__PURE__ */ __name(({ children }) => {
  const { user, token } = useAuth();
  const username = user?.username;
  const [isInVoice, setIsInVoice] = reactExports.useState(false);
  const [isConnecting, setIsConnecting] = reactExports.useState(false);
  const [currentRoom, setCurrentRoom] = reactExports.useState(null);
  const [isMuted, setIsMuted] = reactExports.useState(false);
  const [isDeafened, setIsDeafened] = reactExports.useState(false);
  const [isVideoEnabled, setIsVideoEnabled] = reactExports.useState(false);
  const [isScreenSharing, setIsScreenSharing] = reactExports.useState(false);
  const [isTalking, setIsTalking] = reactExports.useState(false);
  const [activeVoiceEffect, setActiveVoiceEffect] = reactExports.useState(null);
  const [voiceEffectIntensity, setVoiceEffectIntensity] = reactExports.useState(50);
  const [localAudioStream, setLocalAudioStream] = reactExports.useState(null);
  const [localCameraStream, setLocalCameraStream] = reactExports.useState(null);
  const [localScreenStream, setLocalScreenStream] = reactExports.useState(null);
  const [remoteStreams, setRemoteStreams] = reactExports.useState({});
  const [connectedUsers, setConnectedUsers] = reactExports.useState([]);
  const [lastReaction, setLastReaction] = reactExports.useState(null);
  const [cinemaState, setCinemaState] = reactExports.useState({
    isActive: false,
    url: "https://www.youtube.com/watch?v=jfKfPfyJRdk",
    playing: false,
    time: 0,
    lastSyncAction: null,
    timestamp: 0
  });
  const [gameState, setGameState] = reactExports.useState({
    gameType: "rps",
    moves: {},
    result: null,
    players: [],
    currentTurn: null
  });
  const [useNewVoicePanel] = reactExports.useState(true);
  const [showVoiceIsland, setShowVoiceIsland] = reactExports.useState(false);
  const [isVoicePanelMinimized, setIsVoicePanelMinimized] = reactExports.useState(false);
  const [focusedStream, setFocusedStream] = reactExports.useState(null);
  const [islandState, setIslandState] = reactExports.useState("collapsed");
  const {
    noiseGateThreshold,
    isNoiseGateEnabled,
    isVisualizerEnabled,
    remoteVolumes,
    mutedUsers,
    isSpatialAudioEnabled,
    setIsSpatialAudioEnabled,
    vadSensitivity,
    isNoiseSuppressionEnabled,
    setIsNoiseSuppressionEnabled,
    noiseSuppressionLevel,
    screenShareQuality,
    screenShareFPS,
    includeSystemAudio,
    isPTTMode,
    setIsPTTMode,
    pttKey,
    isPTTActive,
    setIsPTTActive,
    setRemoteVolume,
    updateVadSensitivity,
    updateNoiseSuppressionLevel,
    updateScreenQuality,
    updateScreenFPS,
    toggleSystemAudio,
    toggleNoiseGate,
    updateNoiseGateThreshold,
    toggleVisualizer,
    updatePTTKey
  } = useVoiceSettings();
  const [iceServers, setIceServers] = reactExports.useState(DEFAULT_ICE_SERVERS);
  const [isReconnecting, setIsReconnecting] = reactExports.useState(false);
  const [wsReconnectAttempt, setWsReconnectAttempt] = reactExports.useState(0);
  const [wsReconnectDelay, setWsReconnectDelay] = reactExports.useState(1e3);
  const wsReconnectTimeoutRef = reactExports.useRef(null);
  const wsHealthCheckIntervalRef = reactExports.useRef(null);
  reactExports.useRef(null);
  const refreshIceServers = reactExports.useCallback(async () => {
    if (!token) {
      setIceServers(DEFAULT_ICE_SERVERS);
      setRtcIceServers(DEFAULT_ICE_SERVERS);
      return;
    }
    try {
      const res = await authFetch(`${API_URL_BASE_STRING$1}/api/voice/turn-credentials/`, {
        method: "GET",
        headers: {
          "Content-Type": "application/json"
        }
      });
      if (!res.ok) {
        if (res.status === 401 || res.status === 403) {
          console.warn("ðŸ§Š [RTC] Auth failed, using STUN only");
        } else {
          console.warn(`ðŸ§Š [RTC] TURN fetch failed (${res.status}), using STUN only`);
        }
        throw new Error(`TURN fetch failed ${res.status}`);
      }
      const data = await res.json();
      const newServers = [...DEFAULT_ICE_SERVERS, ...data?.iceServers || []];
      setIceServers(newServers);
      setRtcIceServers(newServers);
    } catch (err) {
      console.warn("ðŸ§Š [RTC] Using STUN-only mode:", err.message);
      setIceServers(DEFAULT_ICE_SERVERS);
      setRtcIceServers(DEFAULT_ICE_SERVERS);
    }
  }, [token]);
  reactExports.useEffect(() => {
    refreshIceServers();
  }, [refreshIceServers]);
  const voiceWsRef = reactExports.useRef(null);
  const peerConnectionsRef = reactExports.useRef({});
  const audioContextRef = reactExports.useRef(null);
  const globalAudioContextRef = reactExports.useRef(null);
  const localStreamRef = reactExports.useRef(null);
  const localCameraStreamRef = reactExports.useRef(null);
  const localScreenStreamRef = reactExports.useRef(null);
  const isLeavingRef = reactExports.useRef(false);
  const isSwitchingRef = reactExports.useRef(false);
  const joinVoiceRoomRef = reactExports.useRef(null);
  const micHealthIntervalRef = reactExports.useRef(null);
  const voiceEffectNodesRef = reactExports.useRef(null);
  const processedStreamRef = reactExports.useRef(null);
  const {
    isRecording,
    recordingDuration,
    startRecording,
    stopRecording,
    downloadRecording
  } = useRecording({ isInVoice, localAudioStream, remoteStreams, currentRoom });
  const { connectionStats, startStatsMonitoring, stopStatsMonitoring } = useStatsMonitoring();
  const { audioVisualizerData, startVisualizer, stopVisualizer } = useAudioVisualizer({
    isVisualizerEnabled,
    localAudioStream,
    remoteStreams,
    isInVoice,
    globalAudioContextRef
  });
  reactExports.useEffect(() => {
    localStreamRef.current = localAudioStream;
  }, [localAudioStream]);
  reactExports.useEffect(() => {
    localCameraStreamRef.current = localCameraStream;
  }, [localCameraStream]);
  reactExports.useEffect(() => {
    localScreenStreamRef.current = localScreenStream;
  }, [localScreenStream]);
  reactExports.useEffect(() => {
    if (!localAudioStream || !isInVoice || isMuted) {
      setIsTalking(false);
      return;
    }
    if (!globalAudioContextRef.current) {
      const AudioContext2 = window.AudioContext || window.webkitAudioContext;
      globalAudioContextRef.current = new AudioContext2();
    }
    const audioContext = globalAudioContextRef.current;
    const analyser = audioContext.createAnalyser();
    analyser.fftSize = 2048;
    analyser.smoothingTimeConstant = 0.85;
    const bufferLength = analyser.frequencyBinCount;
    const dataArray = new Uint8Array(bufferLength);
    const source = audioContext.createMediaStreamSource(localAudioStream);
    source.connect(analyser);
    let talkingTimeout = null;
    const THRESHOLD = vadSensitivity;
    const TALKING_DELAY = 150;
    const vadIntervalId = setInterval(() => {
      analyser.getByteFrequencyData(dataArray);
      const speechRange = dataArray.slice(10, 100);
      const average = speechRange.reduce((a, b) => a + b, 0) / speechRange.length;
      if (average > THRESHOLD) {
        setIsTalking(true);
        if (talkingTimeout) clearTimeout(talkingTimeout);
        talkingTimeout = setTimeout(() => setIsTalking(false), TALKING_DELAY);
      }
    }, 25);
    return () => {
      clearInterval(vadIntervalId);
      if (talkingTimeout) clearTimeout(talkingTimeout);
      source.disconnect();
    };
  }, [localAudioStream, isInVoice, isMuted, vadSensitivity]);
  const initializeAudio = reactExports.useCallback(() => {
    if (!audioContextRef.current) {
      const AudioContext2 = window.AudioContext || window.webkitAudioContext;
      audioContextRef.current = new AudioContext2();
    }
    if (audioContextRef.current.state === "suspended") {
      audioContextRef.current.resume();
    }
  }, []);
  const toggleSpatialAudio = reactExports.useCallback(async () => {
    const newState = !isSpatialAudioEnabled;
    if (newState) {
      try {
        await spatialAudio.initialize();
        Object.keys(remoteStreams).forEach((streamKey, index) => {
          const stream = remoteStreams[streamKey];
          const username2 = streamKey.replace("_camera", "").replace("_screen", "");
          if (!streamKey.includes("_camera") && !streamKey.includes("_screen")) {
            const angle = index / Object.keys(remoteStreams).length * 2 * Math.PI;
            const position = {
              x: Math.cos(angle) * 3,
              y: 0,
              z: Math.sin(angle) * 3
            };
            spatialAudio.addUser(username2, stream, position);
          }
        });
      } catch (err) {
        console.error("Failed to enable spatial audio:", err);
        toast.warning("Spatial Audio baÅŸlatÄ±lamadÄ±. TarayÄ±cÄ±nÄ±z desteklemiyor olabilir.");
        return;
      }
    } else {
      spatialAudio.destroy();
    }
    setIsSpatialAudioEnabled(newState);
    localStorage.setItem("pawscord_spatial_audio", newState.toString());
  }, [isSpatialAudioEnabled, remoteStreams]);
  const toggleNoiseSuppression = reactExports.useCallback(async () => {
    const newState = !isNoiseSuppressionEnabled;
    setIsNoiseSuppressionEnabled(newState);
    localStorage.setItem("pawscord_noise_suppression", newState.toString());
    if (localAudioStream) {
      const audioTrack = localAudioStream.getAudioTracks()[0];
      if (audioTrack && audioTrack.applyConstraints) {
        try {
          await audioTrack.applyConstraints({
            noiseSuppression: newState,
            echoCancellation: true,
            autoGainControl: true
          });
        } catch (err) {
          console.warn("[Noise] Failed to apply, trying fallback getUserMedia:", err);
          try {
            const fresh = await navigator.mediaDevices.getUserMedia({
              audio: {
                noiseSuppression: newState,
                echoCancellation: true,
                autoGainControl: true,
                // ðŸ”¥ GELÄ°ÅžMÄ°Åž SES AYARLARI
                googHighpassFilter: true,
                googNoiseSuppression: newState,
                googNoiseSuppression2: newState,
                googEchoCancellation: true,
                googAutoGainControl: true,
                googTypingNoiseDetection: true,
                // Klavye sesi engelleme
                sampleRate: { ideal: 48e3 },
                latency: { ideal: 0.01 },
                // Daha dÃ¼ÅŸÃ¼k latency
                channelCount: { ideal: 1 }
                // Mono = daha iyi gÃ¼rÃ¼ltÃ¼ engelleme
              }
            });
            const track = fresh.getAudioTracks()[0];
            const newStream = new MediaStream([track]);
            setLocalAudioStream(newStream);
            localStreamRef.current = newStream;
          } catch (e2) {
            console.error("[Noise] Fallback failed:", e2);
          }
        }
      }
    }
  }, [isNoiseSuppressionEnabled, localAudioStream]);
  const togglePTTMode = reactExports.useCallback(() => {
    const newMode = !isPTTMode;
    setIsPTTMode(newMode);
    localStorage.setItem("pawscord_ptt_mode", newMode.toString());
    if (newMode) {
      if (localStreamRef.current) {
        localStreamRef.current.getAudioTracks().forEach((track) => {
          track.enabled = false;
        });
      }
      setIsMuted(true);
    } else {
      if (localStreamRef.current) {
        localStreamRef.current.getAudioTracks().forEach((track) => {
          track.enabled = true;
        });
      }
      setIsMuted(false);
    }
  }, [isPTTMode]);
  reactExports.useEffect(() => {
    if (!isPTTMode || !isInVoice) return;
    const handleKeyDown = /* @__PURE__ */ __name((e) => {
      const target = e.target;
      if (target.tagName === "INPUT" || target.tagName === "TEXTAREA") {
        return;
      }
      if (e.code === pttKey && !e.repeat) {
        setIsPTTActive(true);
        if (localStreamRef.current) {
          localStreamRef.current.getAudioTracks().forEach((track) => {
            track.enabled = true;
          });
        }
      }
    }, "handleKeyDown");
    const handleKeyUp = /* @__PURE__ */ __name((e) => {
      if (e.code === pttKey) {
        setIsPTTActive(false);
        if (localStreamRef.current) {
          localStreamRef.current.getAudioTracks().forEach((track) => {
            track.enabled = false;
          });
        }
      }
    }, "handleKeyUp");
    window.addEventListener("keydown", handleKeyDown);
    window.addEventListener("keyup", handleKeyUp);
    return () => {
      window.removeEventListener("keydown", handleKeyDown);
      window.removeEventListener("keyup", handleKeyUp);
    };
  }, [isPTTMode, isInVoice, pttKey]);
  reactExports.useEffect(() => {
    if (!isSpatialAudioEnabled) return;
    Object.keys(remoteStreams).forEach((streamKey, index) => {
      const stream = remoteStreams[streamKey];
      const username2 = streamKey.replace("_camera", "").replace("_screen", "");
      if (!streamKey.includes("_camera") && !streamKey.includes("_screen")) {
        if (!spatialAudio.spatialNodes[username2]) {
          const angle = index / Object.keys(remoteStreams).length * 2 * Math.PI;
          const position = {
            x: Math.cos(angle) * 3,
            y: 0,
            z: Math.sin(angle) * 3
          };
          spatialAudio.addUser(username2, stream, position);
        }
      }
    });
  }, [remoteStreams, isSpatialAudioEnabled]);
  const sendSignal = reactExports.useCallback((signal) => {
    if (voiceWsRef.current?.readyState === WebSocket.OPEN) {
      logger.signal(`Sending ${signal.type} to ${signal.receiver_username || "BROADCAST"}`);
      voiceWsRef.current.send(JSON.stringify({ ...signal, sender_username: username }));
    } else {
      logger.warn("[Signal] WS not ready, cannot send:", signal.type);
    }
  }, [username]);
  const adjustBandwidth = reactExports.useCallback((peerConnection, quality) => {
    try {
      const senders = peerConnection.getSenders();
      const videoSender = senders.find((sender) => sender.track?.kind === "video");
      if (!videoSender) {
        return;
      }
      const parameters = videoSender.getParameters();
      if (!parameters.encodings || parameters.encodings.length === 0) {
        parameters.encodings = [{}];
      }
      const qualitySettings = {
        low: { maxBitrate: 3e5, maxFramerate: 15 },
        // 300kbps, 15fps (Mobil)
        medium: { maxBitrate: 8e5, maxFramerate: 24 },
        // 800kbps, 24fps
        high: { maxBitrate: 25e5, maxFramerate: 30 }
        // 2.5Mbps, 30fps (Desktop)
      };
      const settings2 = qualitySettings[quality] || qualitySettings.medium;
      parameters.encodings[0].maxBitrate = settings2.maxBitrate;
      parameters.encodings[0].maxFramerate = settings2.maxFramerate;
      videoSender.setParameters(parameters).then(() => {
      }).catch((err) => {
        console.warn("[Bandwidth] Failed to set parameters:", err);
      });
    } catch (err) {
      console.warn("[Bandwidth] Error adjusting bandwidth:", err);
    }
  }, []);
  const handleRemoteStream = reactExports.useCallback((partnerUsername, event) => {
    const { track } = event;
    logger.webrtc(`Track Received from ${partnerUsername}:`, track.kind, track.id, "label:", track.label, "hint:", track.contentHint);
    const trackLabel = (track.label || "").toLowerCase();
    const isScreenTrack = trackLabel.includes("screen") || trackLabel.includes("window") || trackLabel.includes("monitor") || trackLabel.includes("display") || trackLabel.includes("tab") || track.contentHint === "detail";
    const streamKey = track.kind === "video" && isScreenTrack ? `${partnerUsername}_screen` : track.kind === "video" ? `${partnerUsername}_camera` : partnerUsername;
    setRemoteStreams((prev) => {
      const currentStream = prev[streamKey];
      if (currentStream) {
        if (!currentStream.getTracks().some((t) => t.id === track.id)) {
          currentStream.addTrack(track);
          const refreshedStream = new MediaStream(currentStream.getTracks());
          return { ...prev, [streamKey]: refreshedStream };
        }
        return prev;
      }
      const newStream = new MediaStream([track]);
      return { ...prev, [streamKey]: newStream };
    });
    if (track.kind === "audio") {
      initializeAudio();
      try {
        const audioEl = document.createElement("audio");
        audioEl.id = `remote-audio-${partnerUsername}`;
        audioEl.srcObject = new MediaStream([track]);
        audioEl.autoplay = true;
        audioEl.playsInline = true;
        const existingEl = document.getElementById(`remote-audio-${partnerUsername}`);
        if (existingEl) existingEl.remove();
        audioEl.style.display = "none";
        document.body.appendChild(audioEl);
        audioEl.play().then(() => {
        }).catch((err) => {
          console.warn(`[Audio] Autoplay blocked for ${partnerUsername}, waiting for interaction:`, err.message);
          const resumeAudio = /* @__PURE__ */ __name(() => {
            audioEl.play().catch(() => {
            });
            document.removeEventListener("click", resumeAudio);
          }, "resumeAudio");
          document.addEventListener("click", resumeAudio, { once: true });
        });
      } catch (err) {
        console.error(`[Audio] Failed to create audio element for ${partnerUsername}:`, err);
      }
    } else if (track.kind === "video") ;
  }, [initializeAudio]);
  const iceCandidateBufferRef = reactExports.useRef({});
  const createPeerConnection = reactExports.useCallback((partnerUsername, isInitiator = false) => {
    if (peerConnectionsRef.current[partnerUsername]) {
      return peerConnectionsRef.current[partnerUsername];
    }
    const pc = new RTCPeerConnection(RTC_CONFIGURATION);
    peerConnectionsRef.current[partnerUsername] = pc;
    try {
      const transceivers = pc.getTransceivers();
      transceivers.forEach((transceiver) => {
        if (transceiver.sender && transceiver.sender.track?.kind === "audio") {
          const codecs = RTCRtpSender.getCapabilities("audio")?.codecs || [];
          const opusCodecs = codecs.filter((c) => c.mimeType.toLowerCase().includes("opus"));
          const otherCodecs = codecs.filter((c) => !c.mimeType.toLowerCase().includes("opus"));
          const orderedCodecs = [...opusCodecs, ...otherCodecs];
          if (transceiver.setCodecPreferences && orderedCodecs.length > 0) {
            transceiver.setCodecPreferences(orderedCodecs);
          }
        }
      });
    } catch (e) {
      console.warn("[Codec] setCodecPreferences not supported:", e.message);
    }
    if (typeof window !== "undefined") {
      window.__pawscord_peer_connections__ = peerConnectionsRef.current;
    }
    pc.onicecandidate = (event) => {
      if (event.candidate) {
        sendSignal({
          type: "candidate",
          candidate: event.candidate,
          receiver_username: partnerUsername
        });
      }
    };
    pc.ontrack = (event) => handleRemoteStream(partnerUsername, event);
    if (localStreamRef.current) {
      localStreamRef.current.getTracks().forEach((track) => {
        logger.webrtc(`Adding local audio track to PC for ${partnerUsername}:`, track.kind);
        pc.addTrack(track, localStreamRef.current);
      });
    }
    pc.oniceconnectionstatechange = () => {
      if (pc.iceConnectionState === "failed") {
        console.warn(`[WebRTC] ICE failed with ${partnerUsername}, attempting restart...`);
        setIsReconnecting(true);
        pc.restartIce();
        setTimeout(() => setIsReconnecting(false), 3e3);
      } else if (pc.iceConnectionState === "disconnected") {
        console.warn(`[WebRTC] ICE disconnected from ${partnerUsername}, waiting for reconnection...`);
        setIsReconnecting(true);
        setTimeout(() => {
          if (pc.iceConnectionState === "disconnected" || pc.iceConnectionState === "failed") {
            console.error(`[WebRTC] ICE reconnection timeout for ${partnerUsername}, cleaning up...`);
            setRemoteStreams((prev) => {
              const newStreams = { ...prev };
              delete newStreams[partnerUsername];
              return newStreams;
            });
            if (peerConnectionsRef.current[partnerUsername]) {
              peerConnectionsRef.current[partnerUsername].close();
              delete peerConnectionsRef.current[partnerUsername];
            }
          }
          setIsReconnecting(false);
        }, 15e3);
      } else if (pc.iceConnectionState === "closed") {
        setRemoteStreams((prev) => {
          const newStreams = { ...prev };
          delete newStreams[partnerUsername];
          return newStreams;
        });
        if (peerConnectionsRef.current[partnerUsername]) {
          delete peerConnectionsRef.current[partnerUsername];
        }
        setIsReconnecting(false);
      } else if (pc.iceConnectionState === "connected") {
        setIsReconnecting(false);
        setTimeout(async () => {
          try {
            const stats = await pc.getStats();
            stats.forEach((report) => {
              if (report.type === "candidate-pair" && report.state === "succeeded") {
                const rtt = report.currentRoundTripTime * 1e3;
                if (rtt > 500) {
                  console.warn(`âš ï¸ [Bandwidth] High latency detected (${rtt.toFixed(0)}ms), reducing video quality to LOW`);
                  adjustBandwidth(pc, "low");
                } else if (rtt > 300) {
                  console.warn(`âš ï¸ [Bandwidth] Medium latency detected (${rtt.toFixed(0)}ms), reducing video quality to MEDIUM`);
                  adjustBandwidth(pc, "medium");
                } else {
                  adjustBandwidth(pc, "high");
                }
              }
            });
          } catch (err) {
            console.warn("[Bandwidth] Failed to get stats:", err);
          }
        }, 2e3);
      } else if (pc.iceConnectionState === "checking") ;
    };
    return pc;
  }, [sendSignal, handleRemoteStream]);
  const handleSignalMessage = reactExports.useCallback(async (data) => {
    if (data.type === "kicked") {
      console.warn("ðŸ”´ [Voice] Kicked from channel:", data.reason, data.message);
      if (data.reason === "moved" && data.target_channel) {
        toast.info(`ðŸ”€ ${data.message || "BaÅŸka kanala taÅŸÄ±ndÄ±nÄ±z"}`, 3e3);
        leaveVoiceRoom();
        const targetChannel = data.target_channel;
        setTimeout(() => {
          if (joinVoiceRoomRef.current) {
            joinVoiceRoomRef.current(targetChannel);
          }
        }, 800);
      } else {
        toast.warning(`Sesli Kanaldan Ã‡Ä±karÄ±ldÄ±nÄ±z

Neden: ${data.message}`, 5e3);
        leaveVoiceRoom();
      }
      return;
    }
    if (data.type === "video_ended") {
      const senderUsername2 = data.from || data.username;
      const streamType = data.streamType || "camera";
      const streamKey = `${senderUsername2}_${streamType}`;
      setRemoteStreams((prev) => {
        const newStreams = { ...prev };
        if (newStreams[streamKey]) {
          newStreams[streamKey].getTracks().forEach((t) => t.stop());
          delete newStreams[streamKey];
        }
        return newStreams;
      });
      return;
    }
    if (data.type === "voice_reaction") {
      const senderUsername2 = data.from || data.username;
      setLastReaction({
        username: senderUsername2,
        emoji: data.emoji,
        timestamp: Date.now()
      });
      setTimeout(() => {
        setLastReaction((prev) => {
          if (prev && prev.timestamp === Date.now()) return null;
          return prev;
        });
      }, 3e3);
      return;
    }
    if (data.type === "game_signal") {
      const senderUsername2 = data.from || data.username;
      setGameState((prev) => {
        const newState = { ...prev };
        if (data.action === "start") {
          newState.gameType = data.game_type;
          newState.players = [senderUsername2, data.target].filter(Boolean);
          newState.moves = {};
          newState.result = null;
          newState.currentTurn = senderUsername2;
        } else if (data.action === "move") {
          newState.moves = {
            ...prev.moves,
            [senderUsername2]: data.move
          };
          if (data.game_type === "rps" && Object.keys(newState.moves).length === 2) {
            const [p1, p2] = Object.keys(newState.moves);
            const m1 = newState.moves[p1];
            const m2 = newState.moves[p2];
            const winMap = { rock: "scissors", scissors: "paper", paper: "rock" };
            if (m1 === m2) {
              newState.result = { winner: null, type: "draw" };
            } else if (winMap[m1] === m2) {
              newState.result = { winner: p1, loser: p2 };
            } else {
              newState.result = { winner: p2, loser: p1 };
            }
          }
        } else if (data.action === "end") {
          newState.result = data.result || { type: "cancelled" };
        }
        return newState;
      });
      return;
    }
    if (data.type === "cinema_sync") {
      const senderUsername2 = data.from || data.username;
      setCinemaState((prev) => ({
        ...prev,
        isActive: data.action !== "stop",
        url: data.url || prev.url,
        playing: data.action === "play",
        time: data.time || prev.time,
        lastSyncAction: data.action,
        timestamp: Date.now(),
        syncedBy: senderUsername2
      }));
      return;
    }
    if (data.type === "current_users") {
      setConnectedUsers((prev) => {
        const backendUsers = data.users || [];
        const meInBackendList = backendUsers.some((u) => u.username === username);
        const myInfo = prev.find((u) => u.username === username);
        let finalList = [...backendUsers];
        if (!meInBackendList && myInfo) {
          finalList = [myInfo, ...backendUsers];
        } else if (!meInBackendList && username) {
          finalList = [{
            username,
            isMuted,
            isCameraOn: isVideoEnabled,
            isScreenSharing,
            isTalking
          }, ...backendUsers];
        }
        return finalList;
      });
      return;
    }
    const senderUsername = data.from || data.sender_username || data.username;
    const { type, sdp, candidate } = data;
    if (!senderUsername) {
      console.error("[Signal] No sender username found in message:", data);
      return;
    }
    if (senderUsername === username) {
      return;
    }
    let pc = peerConnectionsRef.current[senderUsername];
    if (!pc) {
      if (type === "offer") {
        pc = createPeerConnection(senderUsername, false);
      } else if (type === "user_joined") {
        setConnectedUsers((prev) => {
          if (prev.find((u) => u.username === senderUsername)) return prev;
          return [...prev, {
            username: senderUsername,
            isMuted: false,
            isCameraOn: false,
            isScreenSharing: false
          }];
        });
        pc = createPeerConnection(senderUsername, true);
        if (localStreamRef.current) {
          const existingSenders = pc.getSenders();
          localStreamRef.current.getTracks().forEach((track) => {
            const trackAlreadyAdded = existingSenders.some((sender) => sender.track === track);
            if (!trackAlreadyAdded) {
              logger.webrtc(`Adding audio track to new peer ${senderUsername}:`, track.kind);
              pc.addTrack(track, localStreamRef.current);
            }
          });
        }
        if (localCameraStreamRef.current) {
          const existingSenders = pc.getSenders();
          localCameraStreamRef.current.getTracks().forEach((track) => {
            const trackAlreadyAdded = existingSenders.some((sender) => sender.track === track);
            if (!trackAlreadyAdded) {
              logger.webrtc(`Adding camera track to new peer ${senderUsername}:`, track.kind);
              pc.addTrack(track, localCameraStreamRef.current);
            }
          });
        }
        if (localScreenStreamRef.current) {
          const existingSenders = pc.getSenders();
          localScreenStreamRef.current.getTracks().forEach((track) => {
            const trackAlreadyAdded = existingSenders.some((sender) => sender.track === track);
            if (!trackAlreadyAdded) {
              logger.webrtc(`Adding screen track to new peer ${senderUsername}:`, track.kind);
              pc.addTrack(track, localScreenStreamRef.current);
            }
          });
        }
        try {
          const offer = await pc.createOffer();
          await pc.setLocalDescription(offer);
          sendSignal({
            type: "offer",
            sdp: pc.localDescription,
            target: senderUsername
          });
          logger.signal(`Sent offer to ${senderUsername}`);
        } catch (e) {
          logger.error("Offer creation failed", e);
          console.error(`âŒ [user_joined] Failed to create/send offer to ${senderUsername}:`, e);
        }
        return;
      } else if (type === "user_left") {
        setConnectedUsers((prev) => prev.filter((u) => u.username !== senderUsername));
        const audioEl = document.getElementById(`remote-audio-${senderUsername}`);
        if (audioEl) {
          audioEl.pause();
          audioEl.srcObject = null;
          audioEl.remove();
        }
        setRemoteStreams((prev) => {
          const newStreams = { ...prev };
          delete newStreams[senderUsername];
          delete newStreams[`${senderUsername}_camera`];
          delete newStreams[`${senderUsername}_screen`];
          return newStreams;
        });
        if (peerConnectionsRef.current[senderUsername]) {
          peerConnectionsRef.current[senderUsername].close();
          delete peerConnectionsRef.current[senderUsername];
        }
        return;
      } else if (type === "stream_update") {
        setConnectedUsers((prev) => prev.map((u) => {
          if (u.username === senderUsername) {
            return {
              ...u,
              isCameraOn: data.streamType === "camera" ? data.enabled : u.isCameraOn,
              isScreenSharing: data.streamType === "screen" ? data.enabled : u.isScreenSharing
            };
          }
          return u;
        }));
        if (data.enabled && !peerConnectionsRef.current[senderUsername]) {
          const newPC = createPeerConnection(senderUsername, true);
          if (localStreamRef.current) {
            localStreamRef.current.getTracks().forEach((track) => {
              logger.webrtc(`Adding audio track to ${senderUsername}:`, track.kind);
              newPC.addTrack(track, localStreamRef.current);
            });
          }
          if (localCameraStreamRef.current) {
            localCameraStreamRef.current.getTracks().forEach((track) => {
              logger.webrtc(`Adding camera track to ${senderUsername}:`, track.kind);
              newPC.addTrack(track, localCameraStreamRef.current);
            });
          }
          if (localScreenStreamRef.current) {
            localScreenStreamRef.current.getTracks().forEach((track) => {
              logger.webrtc(`Adding screen track to ${senderUsername}:`, track.kind);
              newPC.addTrack(track, localScreenStreamRef.current);
            });
          }
          try {
            const offer = await newPC.createOffer();
            await newPC.setLocalDescription(offer);
            sendSignal({
              type: "offer",
              sdp: newPC.localDescription,
              target: senderUsername
            });
            logger.signal(`Sent offer to ${senderUsername} after stream_update`);
          } catch (e) {
            logger.error(`Failed to create offer for ${senderUsername}:`, e);
          }
        }
        return;
      } else {
        console.warn(`[Signal] Ignored ${type} from ${senderUsername} (No PC)`);
        return;
      }
    }
    try {
      if (type === "offer") {
        if (pc.signalingState !== "stable") {
          console.warn(`[Signal] Ignoring offer from ${senderUsername}, already in state: ${pc.signalingState}`);
          return;
        }
        await pc.setRemoteDescription(new RTCSessionDescription(sdp));
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        sendSignal({
          type: "answer",
          sdp: pc.localDescription,
          target: senderUsername
        });
        if (iceCandidateBufferRef.current[senderUsername]) {
          for (const bufferedCandidate of iceCandidateBufferRef.current[senderUsername]) {
            try {
              await pc.addIceCandidate(bufferedCandidate);
            } catch (e) {
              console.warn(`[Signal] Failed to add buffered candidate:`, e);
            }
          }
          delete iceCandidateBufferRef.current[senderUsername];
        }
      } else if (type === "answer") {
        if (pc.signalingState !== "have-local-offer") {
          console.warn(`[WebRTC] Error handling answer from ${senderUsername}: InvalidStateError: Failed to execute 'setRemoteDescription' on 'RTCPeerConnection': Failed to set remote answer sdp: Called in wrong state: ${pc.signalingState}`);
          return;
        }
        await pc.setRemoteDescription(new RTCSessionDescription(sdp));
        if (iceCandidateBufferRef.current[senderUsername]) {
          for (const bufferedCandidate of iceCandidateBufferRef.current[senderUsername]) {
            try {
              await pc.addIceCandidate(bufferedCandidate);
            } catch (e) {
              console.warn(`[Signal] Failed to add buffered candidate:`, e);
            }
          }
          delete iceCandidateBufferRef.current[senderUsername];
        }
      } else if (type === "candidate") {
        if (pc.remoteDescription) {
          await pc.addIceCandidate(new RTCIceCandidate(candidate));
        } else {
          if (!iceCandidateBufferRef.current[senderUsername]) {
            iceCandidateBufferRef.current[senderUsername] = [];
          }
          iceCandidateBufferRef.current[senderUsername].push(new RTCIceCandidate(candidate));
        }
      }
    } catch (e) {
      console.error(`[WebRTC] Error handling ${type} from ${senderUsername}:`, e);
    }
  }, [username, createPeerConnection, sendSignal]);
  const leaveVoiceRoom = reactExports.useCallback(() => {
    if (isLeavingRef.current) {
      return;
    }
    isLeavingRef.current = true;
    if (voiceWsRef.current && voiceWsRef.current.readyState === WebSocket.OPEN) {
      try {
        voiceWsRef.current.send(JSON.stringify({
          type: "user_leaving",
          sender_username: username
        }));
      } catch (e) {
        console.warn("[Voice] Failed to send leave signal:", e);
      }
    }
    if (localStreamRef.current) {
      localStreamRef.current.getTracks().forEach((track) => {
        track.stop();
      });
      setLocalAudioStream(null);
      localStreamRef.current = null;
    }
    if (localCameraStream) {
      localCameraStream.getTracks().forEach((track) => {
        track.stop();
      });
      setLocalCameraStream(null);
      setIsVideoEnabled(false);
    }
    if (localScreenStream) {
      localScreenStream.getTracks().forEach((track) => {
        track.stop();
      });
      setLocalScreenStream(null);
      setIsScreenSharing(false);
    }
    Object.entries(peerConnectionsRef.current).forEach(([user2, pc]) => {
      pc.close();
    });
    peerConnectionsRef.current = {};
    setRemoteStreams({});
    iceCandidateBufferRef.current = {};
    if (voiceWsRef.current) {
      voiceWsRef.current.onclose = null;
      voiceWsRef.current.close();
      voiceWsRef.current = null;
    }
    setIsInVoice(false);
    setCurrentRoom(null);
    setIsConnecting(false);
    setIsMuted(false);
    setIsDeafened(false);
    stopRecording();
    if (micHealthIntervalRef.current) {
      clearInterval(micHealthIntervalRef.current);
      micHealthIntervalRef.current = null;
    }
    if (wsReconnectTimeoutRef.current) {
      clearTimeout(wsReconnectTimeoutRef.current);
      wsReconnectTimeoutRef.current = null;
    }
    if (wsHealthCheckIntervalRef.current) {
      clearInterval(wsHealthCheckIntervalRef.current);
      wsHealthCheckIntervalRef.current = null;
    }
    setWsReconnectAttempt(0);
    setWsReconnectDelay(1e3);
    setIsReconnecting(false);
    setTimeout(() => {
      isLeavingRef.current = false;
    }, 100);
  }, [username, localCameraStream, localScreenStream, stopRecording]);
  const joinVoiceRoom = reactExports.useCallback(async (roomSlug) => {
    if (isInVoice && currentRoom && currentRoom !== roomSlug && !isSwitchingRef.current) {
      isSwitchingRef.current = true;
      if (voiceWsRef.current) {
        const ws = voiceWsRef.current;
        try {
          ws.send(JSON.stringify({ type: "user_leaving", sender_username: username }));
        } catch (e) {
        }
        ws.onclose = null;
        ws.onerror = null;
        ws.onmessage = null;
        ws.close(1e3, "Switching channel");
        voiceWsRef.current = null;
      }
      Object.values(peerConnectionsRef.current).forEach((pc) => pc.close());
      peerConnectionsRef.current = {};
      setRemoteStreams({});
      iceCandidateBufferRef.current = {};
      isSwitchingRef.current = false;
    }
    if (isInVoice && currentRoom === roomSlug) {
      return;
    }
    if (isSwitchingRef.current) {
      return;
    }
    setIsConnecting(true);
    setCurrentRoom(roomSlug);
    try {
      if (iceServers && iceServers.length > 0) {
        setRtcIceServers(iceServers);
      }
      let processedStream;
      const existingTrack = localStreamRef.current?.getAudioTracks()?.[0];
      if (existingTrack && existingTrack.readyState === "live") {
        processedStream = localStreamRef.current;
      } else {
        const stream = await navigator.mediaDevices.getUserMedia({
          audio: {
            // ðŸ”¥ Echo Cancellation (YankÄ± Ã–nleme) - AÃ‡IK
            echoCancellation: true,
            // ðŸ”¥ Noise Suppression (GÃ¼rÃ¼ltÃ¼ Engelleme) - HER ZAMAN AÃ‡IK
            noiseSuppression: true,
            // ðŸ”¥ Auto Gain Control - AÃ‡IK (ses seviyesi dengelemesi)
            autoGainControl: true,
            // ðŸ”¥ CIZIRTIYI Ã–NLE: Sample rate ve buffer ayarlarÄ±
            sampleRate: { ideal: 48e3 },
            // WebRTC standart (exact yerine ideal)
            sampleSize: { ideal: 16 },
            // 16-bit audio
            channelCount: { ideal: 1 },
            // Mono (stereo cÄ±zÄ±rtÄ± yapabilir)
            // ðŸ”¥ Chrome-specific AGRESIF gÃ¼rÃ¼ltÃ¼ engelleme
            googEchoCancellation: true,
            googAutoGainControl: true,
            googNoiseSuppression: true,
            // ðŸ”¥ HER ZAMAN AÃ‡IK
            googHighpassFilter: true,
            // ðŸ”¥ DÃ¼ÅŸÃ¼k frekans cÄ±zÄ±rtÄ±larÄ± engeller
            googTypingNoiseDetection: true,
            // Klavye sesi engeller
            googAudioMirroring: false,
            // ðŸ”¥ Ses yansÄ±masÄ±nÄ± engelle
            // ðŸ”¥ CIZIRTIYI Ã–NLE: Latency ayarÄ±
            latency: { ideal: 0.02 }
            // 20ms (10ms Ã§ok dÃ¼ÅŸÃ¼k - cÄ±zÄ±rtÄ± yapabilir)
          },
          video: false
        });
        processedStream = stream;
        if (isNoiseSuppressionEnabled) {
          try {
            processedStream = applyProfessionalAudioFilters(stream, globalAudioContextRef);
          } catch (filterError) {
            console.warn("âš ï¸ [Voice] Professional filters failed:", filterError);
            processedStream = stream;
          }
        }
      }
      setLocalAudioStream(processedStream);
      localStreamRef.current = processedStream;
      processedStream.getAudioTracks().forEach((track) => {
        track.enabled = !isMuted;
      });
      initializeAudio();
      if (!micHealthIntervalRef.current) {
        micHealthIntervalRef.current = setInterval(async () => {
          const current = localStreamRef.current;
          const track = current?.getAudioTracks()?.[0];
          if (!isInVoice || isLeavingRef.current) return;
          if (audioContextRef.current?.state === "suspended") {
            await audioContextRef.current.resume().catch(() => {
            });
          }
          if (!track || track.readyState === "ended" || !track.enabled && !isMuted && !isPTTMode) {
            try {
              const fresh = await navigator.mediaDevices.getUserMedia({
                audio: {
                  echoCancellation: true,
                  noiseSuppression: true,
                  // ðŸ”¥ HER ZAMAN AÃ‡IK
                  autoGainControl: true,
                  googEchoCancellation: true,
                  googNoiseSuppression: true,
                  // ðŸ”¥ HER ZAMAN AÃ‡IK
                  googHighpassFilter: true,
                  googTypingNoiseDetection: true,
                  sampleRate: 48e3,
                  channelCount: 1
                },
                video: false
              });
              setLocalAudioStream(fresh);
              localStreamRef.current = fresh;
              const newTrack = fresh.getAudioTracks()[0];
              Object.values(peerConnectionsRef.current).forEach((pc) => {
                pc.getSenders().filter((s) => s.track?.kind === "audio").forEach((sender) => sender.replaceTrack(newTrack).catch(() => {
                }));
              });
            } catch (err) {
              console.warn("[Mic Watchdog] Mic refresh failed:", err);
            }
          }
        }, 8e3);
      }
      const wsUrl = `${WS_PROTOCOL$1}://${API_HOST$1}/ws/voice/${roomSlug}/?token=${token}`;
      const ws = new WebSocket(wsUrl);
      voiceWsRef.current = ws;
      ws.onopen = () => {
        setIsInVoice(true);
        setIsConnecting(false);
        setConnectedUsers((prev) => {
          const meInList = prev.some((u) => u.username === username);
          if (meInList) return prev;
          return [{
            username,
            isMuted,
            isCameraOn: isVideoEnabled,
            isScreenSharing,
            isTalking: false
          }, ...prev];
        });
      };
      ws.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          handleSignalMessage(data);
        } catch (e) {
          console.error("[VoiceWS] Parse error:", e);
        }
      };
      ws.onerror = (error) => {
        console.error("ðŸŽ¤ [VoiceWS] Error:", error);
        setIsConnecting(false);
        if (!isLeavingRef.current && !isSwitchingRef.current) {
          console.warn("[VoiceWS] Error occurred, reconnect will be attempted on close");
        }
      };
      ws.onclose = (event) => {
        if (isLeavingRef.current || isSwitchingRef.current) {
          setIsReconnecting(false);
          setWsReconnectAttempt(0);
          setWsReconnectDelay(1e3);
          if (wsReconnectTimeoutRef.current) {
            clearTimeout(wsReconnectTimeoutRef.current);
            wsReconnectTimeoutRef.current = null;
          }
          return;
        }
        if (event.code === 1e3) {
          leaveVoiceRoom();
          return;
        }
        if (roomSlug && isInVoice) {
          const maxRetries = 10;
          const currentAttempt = wsReconnectAttempt + 1;
          if (currentAttempt > maxRetries) {
            console.error(`[VoiceWS] âŒ Max retry limit reached (${maxRetries}), giving up`);
            toast.error(`Sesli sohbet baÄŸlantÄ±sÄ± ${maxRetries} denemeden sonra kurulamadÄ±. LÃ¼tfen sayfayÄ± yenileyin.`, 5e3);
            leaveVoiceRoom();
            setWsReconnectAttempt(0);
            setWsReconnectDelay(1e3);
            return;
          }
          const delay = Math.min(wsReconnectDelay, 3e4);
          console.warn(`[VoiceWS] ðŸ”„ Unexpected disconnect (code: ${event.code})`);
          setIsReconnecting(true);
          setWsReconnectAttempt(currentAttempt);
          if (wsReconnectTimeoutRef.current) {
            clearTimeout(wsReconnectTimeoutRef.current);
          }
          wsReconnectTimeoutRef.current = setTimeout(() => {
            if (!isLeavingRef.current && !isSwitchingRef.current && roomSlug) {
              setWsReconnectDelay((prev) => Math.min(prev * 2, 3e4));
              joinVoiceRoom(roomSlug).then(() => {
                setWsReconnectAttempt(0);
                setWsReconnectDelay(1e3);
                setIsReconnecting(false);
              }).catch((err) => {
                console.error("[VoiceWS] Reconnection failed:", err);
              });
            } else {
              setIsReconnecting(false);
              setWsReconnectAttempt(0);
              setWsReconnectDelay(1e3);
            }
          }, delay);
        } else {
          leaveVoiceRoom();
        }
      };
    } catch (err) {
      console.error("Voice Join Error:", err);
      setIsConnecting(false);
      isSwitchingRef.current = false;
      if (err.name === "NotAllowedError") {
        toast.warning("Mikrofon izni reddedildi. LÃ¼tfen tarayÄ±cÄ± ayarlarÄ±ndan izin verin.", 5e3);
      } else if (err.name === "NotFoundError") {
        toast.warning("Mikrofon bulunamadÄ±. LÃ¼tfen bir mikrofon baÄŸlayÄ±n.");
      } else {
        toast.error("Sesli sohbete baÄŸlanÄ±lamadÄ±: " + err.message);
      }
    }
  }, [isInVoice, currentRoom, token, handleSignalMessage, initializeAudio, leaveVoiceRoom]);
  reactExports.useEffect(() => {
    joinVoiceRoomRef.current = joinVoiceRoom;
  }, [joinVoiceRoom]);
  const toggleMute = reactExports.useCallback(() => {
    setIsMuted((prev) => {
      const newMuted = !prev;
      if (localStreamRef.current) {
        localStreamRef.current.getAudioTracks().forEach((track) => {
          track.enabled = !newMuted;
        });
      }
      if (voiceWsRef.current?.readyState === WebSocket.OPEN) {
        voiceWsRef.current.send(JSON.stringify({
          type: "mic_off_state",
          is_mic_off: newMuted
        }));
      }
      return newMuted;
    });
  }, []);
  const toggleDeafened = reactExports.useCallback(() => {
    setIsDeafened((prev) => {
      const newDeafened = !prev;
      if (voiceWsRef.current?.readyState === WebSocket.OPEN) {
        voiceWsRef.current.send(JSON.stringify({
          type: "deaf_state",
          is_deafened: newDeafened
        }));
      }
      return newDeafened;
    });
  }, []);
  const cameraToggleLockRef = reactExports.useRef(false);
  const toggleVideo = reactExports.useCallback(async () => {
    if (cameraToggleLockRef.current) {
      return;
    }
    cameraToggleLockRef.current = true;
    try {
      const currentStream = localCameraStreamRef.current;
      if (currentStream) {
        setIsVideoEnabled(false);
        setLocalCameraStream(null);
        localCameraStreamRef.current = null;
        currentStream.getTracks().forEach((track) => {
          track.stop();
        });
        const renegotiationPromises = [];
        for (const [username2, pc] of Object.entries(peerConnectionsRef.current)) {
          const senders = pc.getSenders();
          let trackRemoved = false;
          for (const sender of senders) {
            if (sender.track && sender.track.kind === "video" && sender.track.contentHint !== "detail") {
              try {
                pc.removeTrack(sender);
                trackRemoved = true;
              } catch (e) {
                console.warn(`[Camera] Failed to remove track from ${username2}:`, e);
              }
            }
          }
          if (trackRemoved) {
            const renegPromise = (async () => {
              try {
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);
                sendSignal({
                  type: "offer",
                  sdp: pc.localDescription,
                  target: username2
                });
              } catch (e) {
                console.warn(`[Camera] Renegotiation failed with ${username2}:`, e);
              }
            })();
            renegotiationPromises.push(renegPromise);
          }
        }
        if (voiceWsRef.current?.readyState === WebSocket.OPEN) {
          voiceWsRef.current.send(JSON.stringify({
            type: "camera_state",
            is_camera_on: false
          }));
          voiceWsRef.current.send(JSON.stringify({
            type: "video_ended",
            streamType: "camera"
          }));
        }
        Promise.all(renegotiationPromises).catch(
          (e) => console.warn("[Camera] Some renegotiations failed:", e)
        );
      } else {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: {
            width: { ideal: 1280 },
            height: { ideal: 720 },
            frameRate: { ideal: 30 }
          }
        });
        if (!cameraToggleLockRef.current) {
          stream.getTracks().forEach((t) => t.stop());
          return;
        }
        localCameraStreamRef.current = stream;
        setLocalCameraStream(stream);
        setIsVideoEnabled(true);
        const videoTrack = stream.getVideoTracks()[0];
        videoTrack.onended = () => {
          setLocalCameraStream(null);
          localCameraStreamRef.current = null;
          setIsVideoEnabled(false);
          if (voiceWsRef.current?.readyState === WebSocket.OPEN) {
            voiceWsRef.current.send(JSON.stringify({
              type: "video_ended",
              streamType: "camera"
            }));
          }
        };
        try {
          videoTrack.contentHint = "motion";
        } catch (e) {
          console.warn("[Camera] contentHint not supported:", e);
        }
        const addTrackPromises = [];
        for (const [username2, pc] of Object.entries(peerConnectionsRef.current)) {
          const addPromise = (async () => {
            try {
              pc.addTrack(videoTrack, stream);
              const offer = await pc.createOffer();
              await pc.setLocalDescription(offer);
              sendSignal({
                type: "offer",
                sdp: pc.localDescription,
                target: username2
              });
            } catch (e) {
              console.warn(`[Camera] Failed to add/renegotiate with ${username2}:`, e);
            }
          })();
          addTrackPromises.push(addPromise);
        }
        if (voiceWsRef.current?.readyState === WebSocket.OPEN) {
          voiceWsRef.current.send(JSON.stringify({
            type: "camera_state",
            is_camera_on: true
          }));
        }
        Promise.all(addTrackPromises).catch(
          (e) => console.warn("[Camera] Some track additions failed:", e)
        );
      }
    } catch (error) {
      console.error("[Camera] Error:", error);
      if (error.name === "NotAllowedError") {
        toast.warning("Kamera izni reddedildi. LÃ¼tfen tarayÄ±cÄ± ayarlarÄ±ndan kamera iznini aÃ§Ä±n.", 5e3);
      } else if (error.name === "NotFoundError") {
        toast.warning("Kamera bulunamadÄ±. LÃ¼tfen bir kamera baÄŸlayÄ±n.");
      } else {
        toast.error("Kamera baÅŸlatÄ±lamadÄ±: " + error.message);
      }
      setIsVideoEnabled(false);
      localCameraStreamRef.current = null;
      setLocalCameraStream(null);
    } finally {
      setTimeout(() => {
        cameraToggleLockRef.current = false;
      }, 300);
    }
  }, [sendSignal]);
  const toggleCamera = toggleVideo;
  const screenToggleLockRef = reactExports.useRef(false);
  const toggleScreenShare = reactExports.useCallback(async () => {
    if (screenToggleLockRef.current) {
      return;
    }
    screenToggleLockRef.current = true;
    try {
      const currentStream = localScreenStreamRef.current;
      if (currentStream) {
        setIsScreenSharing(false);
        setLocalScreenStream(null);
        localScreenStreamRef.current = null;
        currentStream.getTracks().forEach((track) => {
          track.stop();
        });
        const renegotiationPromises = [];
        for (const [username2, pc] of Object.entries(peerConnectionsRef.current)) {
          const senders = pc.getSenders();
          let trackRemoved = false;
          for (const sender of senders) {
            if (sender.track && sender.track.contentHint === "detail") {
              try {
                pc.removeTrack(sender);
                trackRemoved = true;
              } catch (e) {
                console.warn(`[Screen] Failed to remove track from ${username2}:`, e);
              }
            }
          }
          if (trackRemoved) {
            const renegPromise = (async () => {
              try {
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);
                sendSignal({
                  type: "offer",
                  sdp: pc.localDescription,
                  target: username2
                });
              } catch (e) {
                console.warn(`[Screen] Renegotiation failed with ${username2}:`, e);
              }
            })();
            renegotiationPromises.push(renegPromise);
          }
        }
        if (voiceWsRef.current?.readyState === WebSocket.OPEN) {
          voiceWsRef.current.send(JSON.stringify({
            type: "screen_share_state",
            is_sharing: false
          }));
          voiceWsRef.current.send(JSON.stringify({
            type: "video_ended",
            streamType: "screen"
          }));
        }
        Promise.all(renegotiationPromises).catch(
          (e) => console.warn("[Screen] Some renegotiations failed:", e)
        );
      } else {
        const qualityPresets = {
          "720p": { width: 1280, height: 720 },
          "1080p": { width: 1920, height: 1080 },
          "4K": { width: 3840, height: 2160 }
        };
        const quality = qualityPresets[screenShareQuality] || qualityPresets["1080p"];
        const stream = await navigator.mediaDevices.getDisplayMedia({
          video: {
            cursor: "always",
            displaySurface: "monitor",
            width: { ideal: quality.width },
            height: { ideal: quality.height },
            frameRate: { ideal: screenShareFPS }
          },
          audio: includeSystemAudio
          // ðŸ”¥ YENÄ°: System audio toggle
        });
        if (!screenToggleLockRef.current) {
          stream.getTracks().forEach((t) => t.stop());
          return;
        }
        stream.getVideoTracks()[0].onended = () => {
          setLocalScreenStream(null);
          localScreenStreamRef.current = null;
          setIsScreenSharing(false);
          if (voiceWsRef.current?.readyState === WebSocket.OPEN) {
            voiceWsRef.current.send(JSON.stringify({
              type: "screen_share_state",
              is_sharing: false
            }));
            voiceWsRef.current.send(JSON.stringify({
              type: "video_ended",
              streamType: "screen"
            }));
          }
        };
        localScreenStreamRef.current = stream;
        setLocalScreenStream(stream);
        setIsScreenSharing(true);
        const screenTrack = stream.getVideoTracks()[0];
        try {
          screenTrack.contentHint = "detail";
        } catch (e) {
          console.warn("[Screen] contentHint not supported:", e);
        }
        const addTrackPromises = [];
        for (const [username2, pc] of Object.entries(peerConnectionsRef.current)) {
          const addPromise = (async () => {
            try {
              pc.addTrack(screenTrack, stream);
              const offer = await pc.createOffer();
              await pc.setLocalDescription(offer);
              sendSignal({
                type: "offer",
                sdp: pc.localDescription,
                target: username2
              });
            } catch (e) {
              console.error(`[Screen] Failed to add track to ${username2}:`, e.message);
            }
          })();
          addTrackPromises.push(addPromise);
        }
        if (voiceWsRef.current?.readyState === WebSocket.OPEN) {
          voiceWsRef.current.send(JSON.stringify({
            type: "screen_share_state",
            is_sharing: true
          }));
        }
        Promise.all(addTrackPromises).catch(
          (e) => console.warn("[Screen] Some track additions failed:", e)
        );
      }
    } catch (error) {
      console.error("[Screen] Error:", error);
      if (error.name === "NotAllowedError") ;
      else if (error.name === "NotFoundError") {
        toast.warning("Ekran paylaÅŸÄ±mÄ± desteklenmiyor.");
      } else {
        toast.error("Ekran paylaÅŸÄ±mÄ± baÅŸlatÄ±lamadÄ±: " + error.message);
      }
      setIsScreenSharing(false);
      localScreenStreamRef.current = null;
      setLocalScreenStream(null);
    } finally {
      setTimeout(() => {
        screenToggleLockRef.current = false;
      }, 300);
    }
  }, [sendSignal, screenShareQuality, screenShareFPS, includeSystemAudio]);
  const applyVoiceEffect = reactExports.useCallback(async (effectType, intensity = 50) => {
    if (!localAudioStream || !isInVoice) {
      console.warn("[VoiceEffect] No stream or not in voice");
      return;
    }
    try {
      if (voiceEffectNodesRef.current) {
        voiceEffectNodesRef.current.forEach((node) => {
          try {
            node.disconnect();
          } catch (_) {
          }
        });
        voiceEffectNodesRef.current = null;
      }
      if (!effectType) {
        setActiveVoiceEffect(null);
        return;
      }
      const audioContext = globalAudioContextRef.current || new AudioContext();
      if (!globalAudioContextRef.current) globalAudioContextRef.current = audioContext;
      const { nodes, outputStream } = createVoiceEffect(effectType, intensity, audioContext, localAudioStream);
      voiceEffectNodesRef.current = nodes;
      processedStreamRef.current = outputStream;
      setActiveVoiceEffect(effectType);
      setVoiceEffectIntensity(intensity);
    } catch (error) {
      console.error("[VoiceEffect] Error:", error);
      toast.error("Ses efekti uygulanamadÄ±");
    }
  }, [localAudioStream, isInVoice]);
  const sendReaction = reactExports.useCallback((emoji) => {
    if (!voiceWsRef.current || voiceWsRef.current.readyState !== WebSocket.OPEN) {
      console.warn("[Reaction] WebSocket not connected");
      return;
    }
    voiceWsRef.current.send(JSON.stringify({
      type: "voice_reaction",
      emoji
    }));
  }, []);
  const sendGameSignal = reactExports.useCallback((gameType, action, move = null, target = null) => {
    if (!voiceWsRef.current || voiceWsRef.current.readyState !== WebSocket.OPEN) {
      console.warn("[Game] WebSocket not connected");
      return;
    }
    voiceWsRef.current.send(JSON.stringify({
      type: "game_signal",
      game_type: gameType,
      action,
      move,
      target
    }));
  }, []);
  const sendCinemaSync = reactExports.useCallback((action, time2 = 0, url = null) => {
    if (!voiceWsRef.current || voiceWsRef.current.readyState !== WebSocket.OPEN) {
      console.warn("[Cinema] WebSocket not connected");
      return;
    }
    voiceWsRef.current.send(JSON.stringify({
      type: "cinema_sync",
      action,
      time: time2,
      url
    }));
  }, []);
  reactExports.useEffect(() => {
    return () => {
      stopRecording();
      if (micHealthIntervalRef.current) {
        clearInterval(micHealthIntervalRef.current);
        micHealthIntervalRef.current = null;
      }
      stopStatsMonitoring();
    };
  }, [stopRecording, stopStatsMonitoring]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(VoiceContext.Provider, { value: {
    isInVoice,
    isConnecting,
    currentRoom,
    isMuted,
    isDeafened,
    isVideoEnabled,
    isScreenSharing,
    isTalking,
    isSpatialAudioEnabled,
    vadSensitivity,
    isNoiseSuppressionEnabled,
    screenShareQuality,
    screenShareFPS,
    isRecording,
    recordingDuration,
    isPTTMode,
    isPTTActive,
    pttKey,
    includeSystemAudio,
    localStream: localAudioStream,
    localAudioStream,
    localCameraStream,
    localScreenStream,
    remoteStreams,
    connectedUsers,
    // ðŸ†•
    remoteVolumes,
    mutedUsers,
    joinVoiceRoom,
    leaveVoiceRoom,
    joinChannel: joinVoiceRoom,
    leaveChannel: leaveVoiceRoom,
    setRemoteVolume,
    setIsMuted,
    setIsDeafened,
    setIsVideoEnabled,
    setIsScreenSharing,
    toggleMute,
    toggleDeafened,
    toggleVideo,
    toggleCamera,
    // ðŸ†• Alias
    toggleScreenShare,
    toggleSpatialAudio,
    // ðŸ”¥ YENÄ°: Spatial audio toggle
    updateVadSensitivity,
    toggleNoiseSuppression,
    updateScreenQuality,
    updateScreenFPS,
    toggleSystemAudio,
    togglePTTMode,
    updatePTTKey,
    startRecording,
    stopRecording,
    downloadRecording,
    // ðŸ”¥ YENÄ°: Manuel download
    sendSignal,
    isPttActive: isPTTActive,
    // ðŸ’¬ Reaction System
    sendReaction,
    lastReaction,
    // ðŸŽµ Voice Effects
    applyVoiceEffect,
    activeVoiceEffect,
    activeEffect: activeVoiceEffect,
    // Alias used by App.js
    voiceEffectIntensity,
    setVoiceEffectIntensity,
    // ðŸŽ¬ Cinema Mode
    cinemaState,
    setCinemaState,
    sendCinemaSync,
    // ðŸŽ® Games
    gameState,
    setGameState,
    sendGameSignal,
    // ðŸ“Š WebRTC Stats
    connectionStats,
    startStatsMonitoring,
    stopStatsMonitoring,
    // ðŸ”§ Advanced Settings
    noiseSuppressionLevel,
    updateNoiseSuppressionLevel,
    // ðŸ”¥ GeliÅŸmiÅŸ gÃ¼rÃ¼ltÃ¼ engelleme seviyesi
    iceServers,
    isReconnecting,
    adjustBandwidth,
    // ðŸŽšï¸ YENÄ°: Noise Gate
    noiseGateThreshold,
    isNoiseGateEnabled,
    toggleNoiseGate,
    updateNoiseGateThreshold,
    // ðŸ“Š YENÄ°: Audio Visualizer
    audioVisualizerData,
    isVisualizerEnabled,
    toggleVisualizer,
    startVisualizer,
    stopVisualizer,
    // ðŸ–¥ï¸ Voice Panel UI
    useNewVoicePanel,
    showVoiceIsland,
    setShowVoiceIsland,
    isVoicePanelMinimized,
    setIsVoicePanelMinimized,
    focusedStream,
    setFocusedStream,
    islandState,
    setIslandState
  }, children });
}, "VoiceProvider");
const useVoice = /* @__PURE__ */ __name(() => reactExports.useContext(VoiceContext), "useVoice");
const GlobalWebSocketContext = reactExports.createContext(null);
const GlobalWebSocketProvider = /* @__PURE__ */ __name(({ children }) => {
  const [isConnected, setIsConnected] = reactExports.useState(false);
  const [globalData, setGlobalData] = reactExports.useState(null);
  const [unreadGlobal, setUnreadGlobal] = reactExports.useState(0);
  const handleGlobalData = reactExports.useCallback((data) => {
    setGlobalData(data);
    if (data.type === "chat_message_handler" && data.username === "âš¡ Signal Bot") {
      if (typeof Notification !== "undefined" && Notification.permission === "granted" && document.hidden) {
        new Notification("ðŸš¨ YENÄ° KRÄ°PTO SÄ°NYALÄ°!", {
          body: `${data.content.split("\n")[2]}`,
          icon: "/logo192.png"
        });
      }
      setUnreadGlobal((prev) => prev + 1);
    }
  }, []);
  const contextValue = reactExports.useMemo(() => ({
    isConnected,
    setIsConnected,
    globalData,
    setGlobalData: handleGlobalData,
    unreadGlobal,
    setUnreadGlobal
  }), [isConnected, globalData, unreadGlobal, handleGlobalData]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GlobalWebSocketContext.Provider, { value: contextValue, children });
}, "GlobalWebSocketProvider");
const useGlobalWebSocket = /* @__PURE__ */ __name(() => reactExports.useContext(GlobalWebSocketContext), "useGlobalWebSocket");
const MaintenanceBanner = /* @__PURE__ */ __name(({ message, endTime, level = "info", onDismiss }) => {
  const [timeLeft, setTimeLeft] = reactExports.useState("");
  reactExports.useEffect(() => {
    if (!endTime) return;
    const updateTimer = /* @__PURE__ */ __name(() => {
      const now = /* @__PURE__ */ new Date();
      const end = new Date(endTime);
      const diff = end - now;
      if (diff <= 0) {
        setTimeLeft("Ending soon...");
        setTimeout(() => window.location.reload(), 5e3);
        return;
      }
      const hours = Math.floor(diff / (1e3 * 60 * 60));
      const minutes = Math.floor(diff % (1e3 * 60 * 60) / (1e3 * 60));
      setTimeLeft(`${hours}h ${minutes}m remaining`);
    }, "updateTimer");
    updateTimer();
    const interval = setInterval(updateTimer, 6e4);
    return () => clearInterval(interval);
  }, [endTime]);
  const colors = {
    info: { bg: "rgba(88, 101, 242, 0.1)", border: "#5865f2", text: "#5865f2" },
    warning: { bg: "rgba(250, 166, 26, 0.1)", border: "#faa61a", text: "#faa61a" },
    critical: { bg: "rgba(240, 71, 71, 0.1)", border: "#f04747", text: "#f04747" }
  };
  const color = colors[level] || colors.info;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
    position: "fixed",
    top: 0,
    left: 0,
    right: 0,
    backgroundColor: color.bg,
    borderBottom: `2px solid ${color.border}`,
    padding: "12px 20px",
    display: "flex",
    alignItems: "center",
    justifyContent: "space-between",
    zIndex: 9999,
    animation: "slideDown 0.3s ease"
  }, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", gap: "12px" }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(FaTools, { style: { color: color.text, fontSize: "18px" } }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { color: color.text, fontWeight: "bold" }, children: level === "critical" ? "ðŸš¨ Critical Maintenance" : level === "warning" ? "âš ï¸ Scheduled Maintenance" : "â„¹ï¸ Maintenance Notice" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { color: "#dcddde", fontSize: "14px", marginTop: "2px" }, children: [
          message,
          timeLeft && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { style: { marginLeft: "10px", opacity: 0.7 }, children: [
            "(",
            timeLeft,
            ")"
          ] })
        ] })
      ] })
    ] }),
    onDismiss && /* @__PURE__ */ jsxRuntimeExports.jsx(
      "button",
      {
        onClick: onDismiss,
        style: {
          background: "none",
          border: "none",
          color: "#b9bbbe",
          cursor: "pointer",
          padding: "8px",
          borderRadius: "4px",
          transition: "background 0.2s"
        },
        onMouseEnter: /* @__PURE__ */ __name((e) => e.target.style.background = "rgba(255,255,255,0.1)", "onMouseEnter"),
        onMouseLeave: /* @__PURE__ */ __name((e) => e.target.style.background = "none", "onMouseLeave"),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(FaTimes, {})
      }
    )
  ] });
}, "MaintenanceBanner");
const LoadingSpinner = /* @__PURE__ */ __name(({ size = "medium", text = "YÃ¼kleniyor...", fullscreen = false }) => {
  const sizes = {
    small: { spinner: 24, text: "12px" },
    medium: { spinner: 40, text: "14px" },
    large: { spinner: 60, text: "16px" }
  };
  const config = sizes[size] || sizes.medium;
  const containerStyle = fullscreen ? styles$9.fullscreenContainer : styles$9.inlineContainer;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: containerStyle, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { ...styles$9.spinnerWrapper, width: config.spinner, height: config.spinner }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: styles$9.spinnerOuter }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: styles$9.spinnerInner })
    ] }),
    text && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { ...styles$9.loadingText, fontSize: config.text }, children: text })
  ] });
}, "LoadingSpinner");
const styles$9 = {
  fullscreenContainer: {
    position: "fixed",
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    display: "flex",
    flexDirection: "column",
    alignItems: "center",
    justifyContent: "center",
    backgroundColor: "#36393f",
    zIndex: 9999,
    gap: "16px"
  },
  inlineContainer: {
    display: "flex",
    flexDirection: "column",
    alignItems: "center",
    justifyContent: "center",
    gap: "12px",
    padding: "20px",
    minHeight: "100px"
  },
  spinnerWrapper: {
    position: "relative",
    display: "flex",
    alignItems: "center",
    justifyContent: "center"
  },
  spinnerOuter: {
    position: "absolute",
    width: "100%",
    height: "100%",
    border: "3px solid rgba(88, 101, 242, 0.2)",
    borderTop: "3px solid #5865f2",
    borderRadius: "50%",
    animation: "spin 1s linear infinite"
  },
  spinnerInner: {
    position: "absolute",
    width: "70%",
    height: "70%",
    border: "3px solid rgba(88, 101, 242, 0.1)",
    borderBottom: "3px solid #7289da",
    borderRadius: "50%",
    animation: "spin 0.7s linear infinite reverse"
  },
  loadingText: {
    color: "#b5bac1",
    fontWeight: 500,
    textAlign: "center",
    animation: "pulse 1.5s ease-in-out infinite"
  }
};
if (typeof document !== "undefined") {
  const styleSheet2 = document.createElement("style");
  styleSheet2.innerText = `
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 1; }
        }
    `;
  if (!document.head.querySelector("[data-loading-spinner-styles]")) {
    styleSheet2.setAttribute("data-loading-spinner-styles", "true");
    document.head.appendChild(styleSheet2);
  }
}
const getApiBaseUrl = /* @__PURE__ */ __name(() => {
  {
    return "https://api.pawscord.com";
  }
}, "getApiBaseUrl");
const API_BASE = getApiBaseUrl();
const getMediaBaseUrl = /* @__PURE__ */ __name(() => {
  const apiBase = getApiBaseUrl();
  return apiBase.replace("/api", "/media");
}, "getMediaBaseUrl");
const getApiBase = getApiBaseUrl;
const getMediaBase = getMediaBaseUrl;
const API_BASE_URL$1 = `${API_BASE}/api`;
const API_URL_BASE = getApiBase();
const isElectron = typeof window !== "undefined" && typeof window.require === "function";
const isNative = typeof window !== "undefined" && window.Capacitor && window.Capacitor.isNativePlatform();
const API_URL_BASE_STRING = API_URL_BASE;
const MEDIA_BASE_URL = (() => {
  if (isElectron || isNative) return "https://www.pawscord.com";
  return API_URL_BASE_STRING;
})();
const API_BASE_URL = `${API_URL_BASE_STRING}/api`;
const ABSOLUTE_HOST_URL = API_URL_BASE_STRING;
const WS_PROTOCOL = API_URL_BASE_STRING.startsWith("https") ? "wss" : "ws";
const API_HOST = API_URL_BASE_STRING.replace(/^https?:\/\//, "");
const MESSAGE_HISTORY_ROOM_URL = `${API_BASE_URL}/messages/history/room/`;
const MESSAGE_HISTORY_DM_URL = `${API_BASE_URL}/messages/history/dm/`;
const ROOM_LIST_URL = `${API_BASE_URL}/rooms/list_with_categories/`;
const CONVERSATION_LIST_URL = `${API_BASE_URL}/conversations/`;
const GET_OR_CREATE_CONVERSATION_URL = `${API_BASE_URL}/conversations/find_or_create/`;
const UPDATE_PROFILE_URL = `${API_BASE_URL}/users/update_profile/`;
const CHANGE_USERNAME_URL = `${API_BASE_URL}/users/change_username/`;
const LOCAL_GIF_LIST_URL = `${API_BASE_URL}/gifs/list_local/`;
const DRAFT_STORAGE_KEY = "chat_drafts_v1";
const getTemporaryId = /* @__PURE__ */ __name(() => (Date.now() + Math.floor(Math.random() * 1e3)).toString(), "getTemporaryId");
const calculateFileHash = /* @__PURE__ */ __name(async (file) => {
  const SparkMD5 = (await __vitePreload(async () => {
    const { default: __vite_default__ } = await import("./crypto-vendor-NANfm9jb.js").then((n) => n.s);
    return { default: __vite_default__ };
  }, true ? __vite__mapDeps([0,1]) : void 0)).default;
  return new Promise((resolve, reject) => {
    const chunkSize = 2 * 1024 * 1024;
    const totalChunks = Math.ceil(file.size / chunkSize);
    let currentChunk = 0;
    const spark = new SparkMD5.ArrayBuffer();
    const fileReader = new FileReader();
    fileReader.onload = (e) => {
      spark.append(e.target.result);
      currentChunk++;
      if (currentChunk < totalChunks) loadNextChunk();
      else resolve(spark.end());
    };
    fileReader.onerror = (err) => reject(err);
    function loadNextChunk() {
      const start = currentChunk * chunkSize;
      const end = Math.min(start + chunkSize, file.size);
      fileReader.readAsArrayBuffer(file.slice(start, end));
    }
    __name(loadNextChunk, "loadNextChunk");
    loadNextChunk();
  });
}, "calculateFileHash");
const CinemaModal = React.lazy(() => __vitePreload(() => import("./CinemaModal-BvqRSqV8.js"), true ? __vite__mapDeps([2,3,1,4]) : void 0));
const CryptoChartModal = React.lazy(() => __vitePreload(() => import("./CryptoChartModal-DVo8Azj1.js"), true ? __vite__mapDeps([5,1,4]) : void 0));
const GifPicker = React.lazy(() => __vitePreload(() => import("./GifPicker-DRHla4ZE.js"), true ? __vite__mapDeps([6,1]) : void 0));
const StickerPicker = React.lazy(() => __vitePreload(() => import("./StickerPicker-D4KgwPIx.js"), true ? __vite__mapDeps([7,1]) : void 0));
const UserProfilePanel = React.lazy(() => __vitePreload(() => import("./UserProfilePanel-D7peylHI.js"), true ? __vite__mapDeps([8,1,9,10,11,12,13,3,14,15,0,4,16,17]) : void 0));
const AdminAnalyticsPanel = React.lazy(() => __vitePreload(() => import("./AdminAnalyticsPanel-CeHNI74W.js"), true ? __vite__mapDeps([18,1,4,19,16]) : void 0));
const AdminPanelModal = React.lazy(() => __vitePreload(() => import("./AdminPanelModal-CprLW31R.js"), true ? __vite__mapDeps([20,1,4,3,14,15,0,16]) : void 0));
const APIUsagePanel = React.lazy(() => __vitePreload(() => import("./APIUsagePanel-BhDcZw3C.js"), true ? __vite__mapDeps([21,1,4,3,14,15,0,16]) : void 0));
const AutoModerationDashboard = React.lazy(() => __vitePreload(() => import("./AutoModerationDashboard-Db2Mj8kJ.js"), true ? __vite__mapDeps([22,1,4,3,14,15,0,16]) : void 0));
const AuditLogPanel = React.lazy(() => __vitePreload(() => import("./AuditLogPanel-DKJ2GZ5a.js"), true ? __vite__mapDeps([23,1,4]) : void 0));
const BookmarkPanel = React.lazy(() => __vitePreload(() => import("./BookmarkPanel-kyNJY0U5.js"), true ? __vite__mapDeps([24,1,4,3,14,15,0,16]) : void 0));
const ChannelPermissionsPanel = React.lazy(() => __vitePreload(() => import("./ChannelPermissionsPanel-EZYXCMYg.js"), true ? __vite__mapDeps([25,1,4,3,14,15,0,16]) : void 0));
const CodeSnippetModal = React.lazy(() => __vitePreload(() => import("./CodeSnippetModal-C61Oq3Pi.js"), true ? __vite__mapDeps([26,1,4]) : void 0));
const ConnectionsPanel = React.lazy(() => __vitePreload(() => import("./ConnectionsPanel-DzEFgQYY.js"), true ? __vite__mapDeps([27,1,4,3,14,15,0,16,28]) : void 0));
const CreateGroupModal = React.lazy(() => __vitePreload(() => import("./CreateGroupModal-D_BiSitZ.js"), true ? __vite__mapDeps([29,1,4,3,14,15,0,16]) : void 0));
const CustomStatusModal = React.lazy(() => __vitePreload(() => import("./CustomStatusModal-BWrL755S.js"), true ? __vite__mapDeps([30,1,4,3,14,15,0,16]) : void 0));
const DJModal = React.lazy(() => __vitePreload(() => import("./DJModal-CAGaD54L.js"), true ? __vite__mapDeps([31,3,1,4]) : void 0));
const DailyRewardsModal = React.lazy(() => __vitePreload(() => import("./DailyRewardsModal-DQvOn490.js"), true ? __vite__mapDeps([32,1,4,3,14,15,0,16]) : void 0));
const DownloadModal = React.lazy(() => __vitePreload(() => import("./DownloadModal-BmcJJ7ja.js"), true ? __vite__mapDeps([33,1,4,3,14,15,0,16]) : void 0));
const EncryptionKeyModal = React.lazy(() => __vitePreload(() => import("./EncryptionKeyModal-C_s13e4y.js"), true ? __vite__mapDeps([34,1,4]) : void 0));
const ExportJobsPanel = React.lazy(() => __vitePreload(() => import("./ExportJobsPanel-BObQVuFH.js"), true ? __vite__mapDeps([35,1,4,3,14,15,0,16]) : void 0));
const MentionsInboxPanel = React.lazy(() => __vitePreload(() => import("./MentionsInboxPanel-DZelkw8n.js"), true ? __vite__mapDeps([36,1,4,3,14,15,0,16]) : void 0));
const PasswordSetupModal = React.lazy(() => __vitePreload(() => import("./PasswordSetupModal-BTysGNpv.js"), true ? __vite__mapDeps([37,1,4,3,14,15,0,16,38]) : void 0));
const PaymentPanel = React.lazy(() => __vitePreload(() => import("./PaymentPanel-By60yAWw.js"), true ? __vite__mapDeps([39,1,4,3,14,15,0,16]) : void 0));
const PollCreateModal = React.lazy(() => __vitePreload(() => import("./PollCreateModal-C0kTUS7Q.js"), true ? __vite__mapDeps([40,1,4]) : void 0));
const PremiumStoreModal = React.lazy(() => __vitePreload(() => import("./PremiumStoreModal-B9JTzr57.js"), true ? __vite__mapDeps([41,1,4,42,3,14,15,0,16]) : void 0));
const RaidProtectionPanel = React.lazy(() => __vitePreload(() => import("./RaidProtectionPanel-DhzCOH3b.js"), true ? __vite__mapDeps([43,1,4,3,14,15,0,16]) : void 0));
const ReadLaterPanel = React.lazy(() => __vitePreload(() => import("./ReadLaterPanel-Bv7aDtH4.js"), true ? __vite__mapDeps([44,1,4,45]) : void 0));
const ReportSystemPanel = React.lazy(() => __vitePreload(() => import("./ReportSystemPanel-C0VgbCF_.js"), true ? __vite__mapDeps([46,1,4,3,14,15,0,16]) : void 0));
const ScheduledAnnouncementsPanel = React.lazy(() => __vitePreload(() => import("./ScheduledAnnouncementsPanel-CyYd5qX7.js"), true ? __vite__mapDeps([47,1,4,3,14,15,0,16]) : void 0));
const ServerSettingsModal = React.lazy(() => __vitePreload(() => import("./ServerSettingsModal-DMBbz04j.js"), true ? __vite__mapDeps([48,1,4,49,50,3,14,15,0,16]) : void 0));
const SoundboardModal = React.lazy(() => __vitePreload(() => import("./SoundboardModal-BALiP7O-.js"), true ? __vite__mapDeps([51,1,4]) : void 0));
const StoreModal = React.lazy(() => __vitePreload(() => import("./StoreModal-Di58Ahiv.js"), true ? __vite__mapDeps([52,1,4,3,14,15,0,16]) : void 0));
const UserWarningsPanel = React.lazy(() => __vitePreload(() => import("./UserWarningsPanel-BPP8cjTU.js"), true ? __vite__mapDeps([53,1,4,3,14,15,0,16]) : void 0));
const VanityURLManager = React.lazy(() => __vitePreload(() => import("./VanityURLManager-DYHHPB97.js"), true ? __vite__mapDeps([50,1,4,3,14,15,0,16]) : void 0));
const WebhooksPanel = React.lazy(() => __vitePreload(() => import("./WebhooksPanel-boei-7OV.js"), true ? __vite__mapDeps([54,1,16,3,14,15,0,4,55]) : void 0));
const WhiteboardModal = React.lazy(() => __vitePreload(() => import("./WhiteboardModal-BmKnXb_l.js"), true ? __vite__mapDeps([56,1,4]) : void 0));
const AppModalsCore = /* @__PURE__ */ __name(({
  modals,
  openModal,
  closeModal,
  fetchWithAuth,
  activeChat,
  username,
  sendMessage,
  sendSignal,
  ws,
  currentUserProfile,
  setCurrentUserProfile,
  soundSettings,
  setSoundSettings,
  encryptionKeys,
  currentKeyId,
  setEncryptionKey,
  chartSymbol,
  setChartSymbol,
  serverToEdit,
  setServerToEdit,
  serverMembers,
  friendsList,
  conversations,
  zoomedImage,
  setZoomedImage,
  logout,
  getDeterministicAvatar,
  handleSendSnippet,
  setActiveChat,
  setConversations
}) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingSpinner, { size: "medium", text: "Modal yÃ¼kleniyor..." }), children: [
    modals.profilePanel && /* @__PURE__ */ jsxRuntimeExports.jsx(UserProfilePanel, { user: currentUserProfile, onClose: /* @__PURE__ */ __name(() => closeModal("profilePanel"), "onClose"), onProfileUpdate: /* @__PURE__ */ __name((updatedUser) => setCurrentUserProfile(updatedUser), "onProfileUpdate"), onLogout: logout, fetchWithAuth, getDeterministicAvatar, updateProfileUrl: UPDATE_PROFILE_URL, changeUsernameUrl: CHANGE_USERNAME_URL, soundSettings, onUpdateSoundSettings: setSoundSettings, onImageClick: setZoomedImage, apiBaseUrl: ABSOLUTE_HOST_URL }),
    modals.store && /* @__PURE__ */ jsxRuntimeExports.jsx(PremiumStoreModal, { onClose: /* @__PURE__ */ __name(() => closeModal("store"), "onClose") }),
    modals.analytics && /* @__PURE__ */ jsxRuntimeExports.jsx(AdminAnalyticsPanel, { onClose: /* @__PURE__ */ __name(() => closeModal("analytics"), "onClose"), fetchWithAuth, apiBaseUrl: ABSOLUTE_HOST_URL }),
    modals.adminPanel && /* @__PURE__ */ jsxRuntimeExports.jsx(
      AdminPanelModal,
      {
        onClose: /* @__PURE__ */ __name(() => closeModal("adminPanel"), "onClose"),
        onOpenAnalytics: /* @__PURE__ */ __name(() => openModal("analytics"), "onOpenAnalytics"),
        onOpenWebhooks: /* @__PURE__ */ __name(() => openModal("webhooks"), "onOpenWebhooks"),
        onOpenModTools: /* @__PURE__ */ __name(() => openModal("modTools"), "onOpenModTools"),
        onOpenAuditLogs: /* @__PURE__ */ __name(() => openModal("auditLog"), "onOpenAuditLogs"),
        onOpenReports: /* @__PURE__ */ __name(() => openModal("reportSystem"), "onOpenReports"),
        onOpenVanityURL: /* @__PURE__ */ __name(() => openModal("vanityURL"), "onOpenVanityURL"),
        onOpenAutoResponder: /* @__PURE__ */ __name(() => openModal("autoResponder"), "onOpenAutoResponder"),
        fetchWithAuth,
        apiBaseUrl: ABSOLUTE_HOST_URL
      }
    ),
    modals.paymentPanel && /* @__PURE__ */ jsxRuntimeExports.jsx(
      PaymentPanel,
      {
        fetchWithAuth,
        apiBaseUrl: ABSOLUTE_HOST_URL,
        onClose: /* @__PURE__ */ __name(() => closeModal("paymentPanel"), "onClose"),
        username
      }
    ),
    modals.storeModal && /* @__PURE__ */ jsxRuntimeExports.jsx(
      StoreModal,
      {
        fetchWithAuth,
        apiBaseUrl: ABSOLUTE_HOST_URL,
        onClose: /* @__PURE__ */ __name(() => closeModal("storeModal"), "onClose"),
        username
      }
    ),
    modals.dailyRewards && /* @__PURE__ */ jsxRuntimeExports.jsx(
      DailyRewardsModal,
      {
        fetchWithAuth,
        apiBaseUrl: ABSOLUTE_HOST_URL,
        onClose: /* @__PURE__ */ __name(() => closeModal("dailyRewards"), "onClose"),
        username
      }
    ),
    modals.aPIUsagePanel && /* @__PURE__ */ jsxRuntimeExports.jsx(
      APIUsagePanel,
      {
        fetchWithAuth,
        apiBaseUrl: ABSOLUTE_HOST_URL,
        onClose: /* @__PURE__ */ __name(() => closeModal("aPIUsagePanel"), "onClose"),
        username
      }
    ),
    modals.exportJobsPanel && /* @__PURE__ */ jsxRuntimeExports.jsx(
      ExportJobsPanel,
      {
        fetchWithAuth,
        apiBaseUrl: ABSOLUTE_HOST_URL,
        onClose: /* @__PURE__ */ __name(() => closeModal("exportJobsPanel"), "onClose"),
        username
      }
    ),
    modals.scheduledAnnouncements && /* @__PURE__ */ jsxRuntimeExports.jsx(
      ScheduledAnnouncementsPanel,
      {
        fetchWithAuth,
        apiBaseUrl: ABSOLUTE_HOST_URL,
        onClose: /* @__PURE__ */ __name(() => closeModal("scheduledAnnouncements"), "onClose"),
        serverId: activeChat?.type === "room" ? activeChat.server_id : null
      }
    ),
    modals.connectionsPanel && /* @__PURE__ */ jsxRuntimeExports.jsx(
      ConnectionsPanel,
      {
        onClose: /* @__PURE__ */ __name(() => closeModal("connectionsPanel"), "onClose")
      }
    ),
    modals.passwordSetupModal && /* @__PURE__ */ jsxRuntimeExports.jsx(
      PasswordSetupModal,
      {
        onClose: /* @__PURE__ */ __name(() => closeModal("passwordSetupModal"), "onClose"),
        apiBaseUrl: ABSOLUTE_HOST_URL
      }
    ),
    modals.autoModeration && /* @__PURE__ */ jsxRuntimeExports.jsx(
      AutoModerationDashboard,
      {
        serverId: activeChat?.type === "room" ? activeChat.server_id : null,
        fetchWithAuth,
        apiBaseUrl: ABSOLUTE_HOST_URL,
        onClose: /* @__PURE__ */ __name(() => closeModal("autoModeration"), "onClose")
      }
    ),
    modals.raidProtection && /* @__PURE__ */ jsxRuntimeExports.jsx(
      RaidProtectionPanel,
      {
        serverId: activeChat?.type === "room" ? activeChat.server_id : null,
        fetchWithAuth,
        apiBaseUrl: ABSOLUTE_HOST_URL,
        onClose: /* @__PURE__ */ __name(() => closeModal("raidProtection"), "onClose")
      }
    ),
    modals.reportSystem && /* @__PURE__ */ jsxRuntimeExports.jsx(
      ReportSystemPanel,
      {
        serverId: activeChat?.type === "room" ? activeChat.server_id : null,
        fetchWithAuth,
        apiBaseUrl: ABSOLUTE_HOST_URL,
        onClose: /* @__PURE__ */ __name(() => closeModal("reportSystem"), "onClose")
      }
    ),
    modals.auditLog && /* @__PURE__ */ jsxRuntimeExports.jsx(
      AuditLogPanel,
      {
        fetchWithAuth,
        apiBaseUrl: ABSOLUTE_HOST_URL,
        onClose: /* @__PURE__ */ __name(() => closeModal("auditLog"), "onClose")
      }
    ),
    modals.userWarnings && /* @__PURE__ */ jsxRuntimeExports.jsx(
      UserWarningsPanel,
      {
        fetchWithAuth,
        apiBaseUrl: ABSOLUTE_HOST_URL,
        onClose: /* @__PURE__ */ __name(() => closeModal("userWarnings"), "onClose")
      }
    ),
    modals.webhooks && /* @__PURE__ */ jsxRuntimeExports.jsx(
      WebhooksPanel,
      {
        fetchWithAuth,
        apiBaseUrl: ABSOLUTE_HOST_URL,
        serverId: activeChat?.type === "room" ? activeChat.server_id : null,
        onClose: /* @__PURE__ */ __name(() => closeModal("webhooks"), "onClose")
      }
    ),
    modals.vanityURL && activeChat?.type === "room" && activeChat.server_id && /* @__PURE__ */ jsxRuntimeExports.jsx(
      VanityURLManager,
      {
        fetchWithAuth,
        apiBaseUrl: ABSOLUTE_HOST_URL,
        serverId: activeChat.server_id,
        onClose: /* @__PURE__ */ __name(() => closeModal("vanityURL"), "onClose")
      }
    ),
    modals.bookmarks && /* @__PURE__ */ jsxRuntimeExports.jsx(
      BookmarkPanel,
      {
        fetchWithAuth,
        apiBaseUrl: ABSOLUTE_HOST_URL,
        onClose: /* @__PURE__ */ __name(() => closeModal("bookmarks"), "onClose"),
        onMessageClick: /* @__PURE__ */ __name((msg) => {
          if (msg.room) {
            setActiveChat({ type: "room", slug: msg.room });
          }
          closeModal("bookmarks");
        }, "onMessageClick")
      }
    ),
    modals.readLater && /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "YÃ¼kleniyor..." }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      ReadLaterPanel,
      {
        fetchWithAuth,
        apiBaseUrl: ABSOLUTE_HOST_URL,
        onClose: /* @__PURE__ */ __name(() => closeModal("readLater"), "onClose"),
        onMessageClick: /* @__PURE__ */ __name((msg) => {
          if (msg.room) {
            setActiveChat({ type: "room", slug: msg.room });
          } else if (msg.conversation) {
            setActiveChat({ type: "dm", slug: msg.conversation });
          }
          closeModal("readLater");
        }, "onMessageClick")
      }
    ) }),
    modals.mentionsInbox && /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "YÃ¼kleniyor..." }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      MentionsInboxPanel,
      {
        isOpen: modals.mentionsInbox,
        onClose: /* @__PURE__ */ __name(() => closeModal("mentionsInbox"), "onClose"),
        currentUsername: currentUserProfile?.username || username,
        onNavigateToMessage: /* @__PURE__ */ __name((msg) => {
          if (msg.room_id) {
            setActiveChat({ type: "room", id: msg.room_id });
          }
          closeModal("mentionsInbox");
        }, "onNavigateToMessage")
      }
    ) }),
    modals.customStatus && /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "YÃ¼kleniyor..." }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      CustomStatusModal,
      {
        isOpen: modals.customStatus,
        onClose: /* @__PURE__ */ __name(() => closeModal("customStatus"), "onClose"),
        onStatusChange: /* @__PURE__ */ __name((status) => {
          if (currentUserProfile) {
            setCurrentUserProfile((prev) => ({ ...prev, customStatus: status }));
          }
        }, "onStatusChange")
      }
    ) }),
    modals.channelPermissions && activeChat?.type === "room" && /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "YÃ¼kleniyor..." }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      ChannelPermissionsPanel,
      {
        fetchWithAuth,
        apiBaseUrl: ABSOLUTE_HOST_URL,
        channelSlug: activeChat.slug,
        onClose: /* @__PURE__ */ __name(() => closeModal("channelPermissions"), "onClose")
      }
    ) }),
    chartSymbol && /* @__PURE__ */ jsxRuntimeExports.jsx(CryptoChartModal, { symbol: chartSymbol, onClose: /* @__PURE__ */ __name(() => setChartSymbol(null), "onClose") }),
    modals.cinema && /* @__PURE__ */ jsxRuntimeExports.jsx(CinemaModal, { onClose: /* @__PURE__ */ __name(() => closeModal("cinema"), "onClose"), ws, username }),
    modals.snippetModal && /* @__PURE__ */ jsxRuntimeExports.jsx(CodeSnippetModal, { onClose: /* @__PURE__ */ __name(() => closeModal("snippetModal"), "onClose"), onSend: handleSendSnippet }),
    serverToEdit && /* @__PURE__ */ jsxRuntimeExports.jsx(ServerSettingsModal, { onClose: /* @__PURE__ */ __name(() => setServerToEdit(null), "onClose"), server: serverToEdit, currentUsername: username, fetchWithAuth, apiBaseUrl: API_BASE_URL, serverMembers }),
    modals.encModal && /* @__PURE__ */ jsxRuntimeExports.jsx(EncryptionKeyModal, { onClose: /* @__PURE__ */ __name(() => closeModal("encModal"), "onClose"), onSetKey: /* @__PURE__ */ __name((key) => setEncryptionKey(currentKeyId, key), "onSetKey"), existingKey: encryptionKeys[currentKeyId] }),
    modals.downloadModal && /* @__PURE__ */ jsxRuntimeExports.jsx(DownloadModal, { onClose: /* @__PURE__ */ __name(() => closeModal("downloadModal"), "onClose"), apiBaseUrl: ABSOLUTE_HOST_URL }),
    modals.groupModal && /* @__PURE__ */ jsxRuntimeExports.jsx(CreateGroupModal, { onClose: /* @__PURE__ */ __name(() => closeModal("groupModal"), "onClose"), friendsList, fetchWithAuth, apiBaseUrl: ABSOLUTE_HOST_URL, onGroupCreated: /* @__PURE__ */ __name((newConv) => {
      setConversations((prev) => [newConv, ...prev]);
      setActiveChat("dm", newConv.id, "Grup Sohbeti");
    }, "onGroupCreated") }),
    modals.whiteboard && (activeChat.type === "room" || activeChat.type === "dm") && /* @__PURE__ */ jsxRuntimeExports.jsx(WhiteboardModal, { roomSlug: activeChat.type === "room" ? activeChat.id : `dm_${activeChat.id}`, onClose: /* @__PURE__ */ __name(() => closeModal("whiteboard"), "onClose"), wsProtocol: WS_PROTOCOL, apiHost: API_HOST }),
    modals.soundboard && /* @__PURE__ */ jsxRuntimeExports.jsx(SoundboardModal, { onClose: /* @__PURE__ */ __name(() => closeModal("soundboard"), "onClose"), fetchWithAuth, apiBaseUrl: ABSOLUTE_HOST_URL, sendSignal, absoluteHostUrl: ABSOLUTE_HOST_URL }),
    modals.dJ && /* @__PURE__ */ jsxRuntimeExports.jsx(DJModal, { onClose: /* @__PURE__ */ __name(() => closeModal("dJ"), "onClose"), ws, roomSlug: activeChat.id }),
    modals.gifPicker && /* @__PURE__ */ jsxRuntimeExports.jsx(GifPicker, { onSelect: /* @__PURE__ */ __name((url) => {
      const full = url.startsWith("http") ? url : ABSOLUTE_HOST_URL + url;
      sendMessage(full);
      closeModal("gifPicker");
    }, "onSelect"), onClose: /* @__PURE__ */ __name(() => closeModal("gifPicker"), "onClose"), localGifListUrl: LOCAL_GIF_LIST_URL, absoluteHostUrl: ABSOLUTE_HOST_URL, fetchWithAuth }),
    modals.stickerPicker && /* @__PURE__ */ jsxRuntimeExports.jsx(StickerPicker, { onClose: /* @__PURE__ */ __name(() => closeModal("stickerPicker"), "onClose"), onSelect: /* @__PURE__ */ __name((url) => {
      sendMessage(url);
      closeModal("stickerPicker");
    }, "onSelect"), fetchWithAuth, apiBaseUrl: ABSOLUTE_HOST_URL }),
    modals.pollModal && /* @__PURE__ */ jsxRuntimeExports.jsx(PollCreateModal, { onClose: /* @__PURE__ */ __name(() => closeModal("pollModal"), "onClose"), fetchWithAuth, apiBaseUrl: ABSOLUTE_HOST_URL, activeRoomSlug: activeChat.id })
  ] }) });
}, "AppModalsCore");
const AdvancedSearchPanel = React.lazy(() => __vitePreload(() => import("./AdvancedSearchPanel-CWVX6Gip.js"), true ? __vite__mapDeps([57,1,4,3,14,15,0,16]) : void 0));
const AutoRespondersPanel = React.lazy(() => __vitePreload(() => import("./AutoRespondersPanel-Dtllx_ff.js"), true ? __vite__mapDeps([58,1,4,3,14,15,0,16]) : void 0));
const AvatarStudioPanel = React.lazy(() => __vitePreload(() => import("./AvatarStudioPanel-BrYOZdmz.js"), true ? __vite__mapDeps([59,1,4,3,14,15,0,16]) : void 0));
const ContentScannerPanel = React.lazy(() => __vitePreload(() => import("./ContentScannerPanel-Jxgf5LVl.js"), true ? __vite__mapDeps([60,1,4,3,14,15,0,16]) : void 0));
const DataRetentionPanel = React.lazy(() => __vitePreload(() => import("./DataRetentionPanel-Cbh_IIND.js"), true ? __vite__mapDeps([61,1,4,3,14,15,0,16]) : void 0));
const DraftsPanel = React.lazy(() => __vitePreload(() => import("./DraftsPanel-C-IbIfeO.js"), true ? __vite__mapDeps([62,1,4,3,14,15,0,16]) : void 0));
const EnhancedPollsPanel = React.lazy(() => __vitePreload(() => import("./EnhancedPollsPanel-BJ8sk77f.js"), true ? __vite__mapDeps([63,1,4,3,14,15,0,16]) : void 0));
const EphemeralMessagesPanel = React.lazy(() => __vitePreload(() => import("./EphemeralMessagesPanel-C8rcuC5s.js"), true ? __vite__mapDeps([64,1,4,3,14,15,0,16]) : void 0));
const FieldChangeTrackingPanel = React.lazy(() => __vitePreload(() => import("./FieldChangeTrackingPanel--c_3LXa0.js"), true ? __vite__mapDeps([65,1,4,3,14,15,0,16]) : void 0));
const GDPRExportPanel = React.lazy(() => __vitePreload(() => import("./GDPRExportPanel-qSc0bx78.js"), true ? __vite__mapDeps([66,1,4,3,14,15,0,16]) : void 0));
const GrowthMetricsPanel = React.lazy(() => __vitePreload(() => import("./GrowthMetricsPanel-BSJUjD9b.js"), true ? __vite__mapDeps([67,1,4,3,14,15,0,16]) : void 0));
const InventoryPanel = React.lazy(() => __vitePreload(() => import("./InventoryPanel-B2sfU6fc.js"), true ? __vite__mapDeps([68,1,4,3,14,15,0,16]) : void 0));
const InviteAnalyticsPanel = React.lazy(() => __vitePreload(() => import("./InviteAnalyticsPanel-BBESM7ym.js"), true ? __vite__mapDeps([69,1,4,3,14,15,0,16]) : void 0));
const InviteExportPanel = React.lazy(() => __vitePreload(() => import("./InviteExportPanel-BeoQqWK9.js"), true ? __vite__mapDeps([70,1,4,3,14,15,0,16]) : void 0));
const JoinLeaveLogsPanel = React.lazy(() => __vitePreload(() => import("./JoinLeaveLogsPanel-Dtt005vw.js"), true ? __vite__mapDeps([71,1,4,3,14,15,0,16]) : void 0));
const LinkClickTrackingPanel = React.lazy(() => __vitePreload(() => import("./LinkClickTrackingPanel-6FH16-Tn.js"), true ? __vite__mapDeps([72,1,4,3,14,15,0,16]) : void 0));
const LinkPreviewRenderer = React.lazy(() => __vitePreload(() => import("./LinkPreviewRenderer-C2LxW31e.js"), true ? __vite__mapDeps([73,1,4]) : void 0));
const MiniGamesPanel = React.lazy(() => __vitePreload(() => import("./MiniGamesPanel-C4JjnWMa.js"), true ? __vite__mapDeps([74,1,4,3,14,15,0,16]) : void 0));
const NicknameHistoryPanel = React.lazy(() => __vitePreload(() => import("./NicknameHistoryPanel-B-Wz69Sw.js"), true ? __vite__mapDeps([75,1,4,3,14,15,0,16]) : void 0));
const OAuthAppsPanel = React.lazy(() => __vitePreload(() => import("./OAuthAppsPanel-Bu2YklTp.js"), true ? __vite__mapDeps([76,1,4,3,14,15,0,16]) : void 0));
const ProjectCollaborationPanel = React.lazy(() => __vitePreload(() => import("./ProjectCollaborationPanel-DPbhuILk.js"), true ? __vite__mapDeps([77,1,4,3,14,15,0,16]) : void 0));
const ReactionAnalyticsPanel = React.lazy(() => __vitePreload(() => import("./ReactionAnalyticsPanel-BCFjvPIf.js"), true ? __vite__mapDeps([78,1,4,3,14,15,0,16]) : void 0));
const ReferralRewardsPanel = React.lazy(() => __vitePreload(() => import("./ReferralRewardsPanel-BbCOHbxH.js"), true ? __vite__mapDeps([79,1,4,3,14,15,0,16]) : void 0));
const RoomWebhooksPanel = React.lazy(() => __vitePreload(() => import("./RoomWebhooksPanel-B_fsIFRY.js"), true ? __vite__mapDeps([80,1,4,3,14,15,0,16]) : void 0));
const ServerBoostPanel = React.lazy(() => __vitePreload(() => import("./ServerBoostPanel-CEJjoMfa.js"), true ? __vite__mapDeps([81,1,4,3,14,15,0,16]) : void 0));
const ServerNicknamesPanel = React.lazy(() => __vitePreload(() => import("./ServerNicknamesPanel-GPlrKIyh.js"), true ? __vite__mapDeps([82,1,4,3,14,15,0,16]) : void 0));
const SessionManagementPanel = React.lazy(() => __vitePreload(() => import("./SessionManagementPanel-CMnZlXbZ.js"), true ? __vite__mapDeps([83,1,4,3,14,15,0,16]) : void 0));
const TopicHistoryPanel = React.lazy(() => __vitePreload(() => import("./TopicHistoryPanel-C2MBkrQu.js"), true ? __vite__mapDeps([84,1,4,3,14,15,0,16]) : void 0));
const TwoFactorSetupWizard = React.lazy(() => __vitePreload(() => import("./TwoFactorSetupWizard-CK1qKlxA.js"), true ? __vite__mapDeps([85,1,4,3,14,15,0,16]) : void 0));
const UserActivityPanel = React.lazy(() => __vitePreload(() => import("./UserActivityPanel-CD0qRsam.js"), true ? __vite__mapDeps([86,1,4,3,14,15,0,16]) : void 0));
const VoiceTranscriptsPanel = React.lazy(() => __vitePreload(() => import("./VoiceTranscriptsPanel-CTXnGgYn.js"), true ? __vite__mapDeps([87,1,4,3,14,15,0,16]) : void 0));
const WaitlistPanel = React.lazy(() => __vitePreload(() => import("./WaitlistPanel-B1K8-3rl.js"), true ? __vite__mapDeps([88,1,4,3,14,15,0,16]) : void 0));
const AppModalsBatch1to8 = /* @__PURE__ */ __name(({
  modals,
  closeModal,
  fetchWithAuth,
  activeChat,
  username,
  currentUserProfile,
  setCurrentUserProfile,
  setActiveChat
}) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    modals.reactionAnalytics && activeChat?.type === "room" && /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "YÃ¼kleniyor..." }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      ReactionAnalyticsPanel,
      {
        fetchWithAuth,
        apiBaseUrl: ABSOLUTE_HOST_URL,
        roomSlug: activeChat.slug,
        onClose: /* @__PURE__ */ __name(() => closeModal("reactionAnalytics"), "onClose")
      }
    ) }),
    modals.linkClickTracking && activeChat?.type === "room" && /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "YÃ¼kleniyor..." }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      LinkClickTrackingPanel,
      {
        fetchWithAuth,
        apiBaseUrl: ABSOLUTE_HOST_URL,
        roomSlug: activeChat.slug,
        onClose: /* @__PURE__ */ __name(() => closeModal("linkClickTracking"), "onClose")
      }
    ) }),
    modals.joinLeaveLogs && activeChat?.type === "room" && activeChat.server_id && /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "YÃ¼kleniyor..." }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      JoinLeaveLogsPanel,
      {
        fetchWithAuth,
        apiBaseUrl: ABSOLUTE_HOST_URL,
        serverId: activeChat.server_id,
        onClose: /* @__PURE__ */ __name(() => closeModal("joinLeaveLogs"), "onClose")
      }
    ) }),
    modals.userActivity && /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "YÃ¼kleniyor..." }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      UserActivityPanel,
      {
        fetchWithAuth,
        apiBaseUrl: ABSOLUTE_HOST_URL,
        username,
        onClose: /* @__PURE__ */ __name(() => closeModal("userActivity"), "onClose")
      }
    ) }),
    modals.nicknameHistory && /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "YÃ¼kleniyor..." }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      NicknameHistoryPanel,
      {
        fetchWithAuth,
        apiBaseUrl: ABSOLUTE_HOST_URL,
        username,
        onClose: /* @__PURE__ */ __name(() => closeModal("nicknameHistory"), "onClose")
      }
    ) }),
    modals.fieldChangeTracking && /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "YÃ¼kleniyor..." }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      FieldChangeTrackingPanel,
      {
        fetchWithAuth,
        apiBaseUrl: ABSOLUTE_HOST_URL,
        onClose: /* @__PURE__ */ __name(() => closeModal("fieldChangeTracking"), "onClose")
      }
    ) }),
    modals.inviteAnalytics && activeChat?.type === "room" && activeChat.server_id && /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "YÃ¼kleniyor..." }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      InviteAnalyticsPanel,
      {
        fetchWithAuth,
        apiBaseUrl: ABSOLUTE_HOST_URL,
        serverId: activeChat.server_id,
        onClose: /* @__PURE__ */ __name(() => closeModal("inviteAnalytics"), "onClose")
      }
    ) }),
    modals.contentScanner && /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "YÃ¼kleniyor..." }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      ContentScannerPanel,
      {
        fetchWithAuth,
        apiBaseUrl: ABSOLUTE_HOST_URL,
        onClose: /* @__PURE__ */ __name(() => closeModal("contentScanner"), "onClose")
      }
    ) }),
    modals.ephemeralMessages && activeChat?.type === "room" && /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "YÃ¼kleniyor..." }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      EphemeralMessagesPanel,
      {
        fetchWithAuth,
        apiBaseUrl: ABSOLUTE_HOST_URL,
        roomSlug: activeChat.slug,
        onClose: /* @__PURE__ */ __name(() => closeModal("ephemeralMessages"), "onClose")
      }
    ) }),
    modals.topicHistory && activeChat?.type === "room" && /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "YÃ¼kleniyor..." }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      TopicHistoryPanel,
      {
        fetchWithAuth,
        apiBaseUrl: ABSOLUTE_HOST_URL,
        roomSlug: activeChat.slug,
        onClose: /* @__PURE__ */ __name(() => closeModal("topicHistory"), "onClose")
      }
    ) }),
    modals.drafts && /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "YÃ¼kleniyor..." }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      DraftsPanel,
      {
        fetchWithAuth,
        apiBaseUrl: ABSOLUTE_HOST_URL,
        onClose: /* @__PURE__ */ __name(() => closeModal("drafts"), "onClose"),
        onLoadDraft: /* @__PURE__ */ __name((draft) => {
          if (draft.room) {
            setActiveChat({ type: "room", slug: draft.room });
          }
          closeModal("drafts");
        }, "onLoadDraft")
      }
    ) }),
    modals.serverNicknames && activeChat?.type === "room" && activeChat.server_id && /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "YÃ¼kleniyor..." }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      ServerNicknamesPanel,
      {
        fetchWithAuth,
        apiBaseUrl: ABSOLUTE_HOST_URL,
        serverId: activeChat.server_id,
        onClose: /* @__PURE__ */ __name(() => closeModal("serverNicknames"), "onClose")
      }
    ) }),
    modals.serverBoost && activeChat?.type === "room" && activeChat.server_id && /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "YÃ¼kleniyor..." }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      ServerBoostPanel,
      {
        fetchWithAuth,
        apiBaseUrl: ABSOLUTE_HOST_URL,
        serverId: activeChat.server_id,
        currentUsername: username,
        onClose: /* @__PURE__ */ __name(() => closeModal("serverBoost"), "onClose")
      }
    ) }),
    modals.roomWebhooks && activeChat?.type === "room" && /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "YÃ¼kleniyor..." }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      RoomWebhooksPanel,
      {
        fetchWithAuth,
        apiBaseUrl: ABSOLUTE_HOST_URL,
        roomSlug: activeChat.slug,
        onClose: /* @__PURE__ */ __name(() => closeModal("roomWebhooks"), "onClose")
      }
    ) }),
    modals.oAuthApps && /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "YÃ¼kleniyor..." }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      OAuthAppsPanel,
      {
        fetchWithAuth,
        apiBaseUrl: ABSOLUTE_HOST_URL,
        onClose: /* @__PURE__ */ __name(() => closeModal("oAuthApps"), "onClose")
      }
    ) }),
    modals.autoResponders && activeChat?.type === "room" && activeChat.server_id && /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "YÃ¼kleniyor..." }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      AutoRespondersPanel,
      {
        fetchWithAuth,
        apiBaseUrl: ABSOLUTE_HOST_URL,
        serverId: activeChat.server_id,
        onClose: /* @__PURE__ */ __name(() => closeModal("autoResponders"), "onClose")
      }
    ) }),
    modals.sessionManagement && /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "YÃ¼kleniyor..." }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      SessionManagementPanel,
      {
        fetchWithAuth,
        apiBaseUrl: ABSOLUTE_HOST_URL,
        onClose: /* @__PURE__ */ __name(() => closeModal("sessionManagement"), "onClose")
      }
    ) }),
    modals.gDPRExport && /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "YÃ¼kleniyor..." }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      GDPRExportPanel,
      {
        fetchWithAuth,
        apiBaseUrl: ABSOLUTE_HOST_URL,
        onClose: /* @__PURE__ */ __name(() => closeModal("gDPRExport"), "onClose")
      }
    ) }),
    modals.dataRetention && activeChat?.type === "room" && activeChat.server_id && /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "YÃ¼kleniyor..." }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      DataRetentionPanel,
      {
        fetchWithAuth,
        apiBaseUrl: ABSOLUTE_HOST_URL,
        serverId: activeChat.server_id,
        onClose: /* @__PURE__ */ __name(() => closeModal("dataRetention"), "onClose")
      }
    ) }),
    modals.twoFactorSetup && /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "YÃ¼kleniyor..." }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      TwoFactorSetupWizard,
      {
        fetchWithAuth,
        apiBaseUrl: ABSOLUTE_HOST_URL,
        onClose: /* @__PURE__ */ __name(() => closeModal("twoFactorSetup"), "onClose"),
        onSuccess: /* @__PURE__ */ __name(() => {
          y.success("2FA baÅŸarÄ±yla etkinleÅŸtirildi!");
          closeModal("twoFactorSetup");
        }, "onSuccess")
      }
    ) }),
    modals.enhancedPolls && activeChat?.type === "room" && /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "YÃ¼kleniyor..." }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      EnhancedPollsPanel,
      {
        fetchWithAuth,
        apiBaseUrl: ABSOLUTE_HOST_URL,
        roomSlug: activeChat.slug,
        onClose: /* @__PURE__ */ __name(() => closeModal("enhancedPolls"), "onClose")
      }
    ) }),
    modals.voiceTranscripts && /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "YÃ¼kleniyor..." }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      VoiceTranscriptsPanel,
      {
        fetchWithAuth,
        apiBaseUrl: ABSOLUTE_HOST_URL,
        onClose: /* @__PURE__ */ __name(() => closeModal("voiceTranscripts"), "onClose")
      }
    ) }),
    modals.inviteExport && activeChat?.type === "room" && activeChat.server_id && /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "YÃ¼kleniyor..." }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      InviteExportPanel,
      {
        fetchWithAuth,
        apiBaseUrl: ABSOLUTE_HOST_URL,
        serverId: activeChat.server_id,
        onClose: /* @__PURE__ */ __name(() => closeModal("inviteExport"), "onClose")
      }
    ) }),
    modals.advancedSearch && /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "YÃ¼kleniyor..." }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      AdvancedSearchPanel,
      {
        fetchWithAuth,
        apiBaseUrl: ABSOLUTE_HOST_URL,
        onClose: /* @__PURE__ */ __name(() => closeModal("advancedSearch"), "onClose"),
        onMessageClick: /* @__PURE__ */ __name((msg) => {
          if (msg.room) {
            setActiveChat({ type: "room", slug: msg.room });
          }
          closeModal("advancedSearch");
        }, "onMessageClick")
      }
    ) }),
    modals.growthMetrics && activeChat?.type === "room" && activeChat.server_id && /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "YÃ¼kleniyor..." }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      GrowthMetricsPanel,
      {
        fetchWithAuth,
        apiBaseUrl: ABSOLUTE_HOST_URL,
        serverId: activeChat.server_id,
        onClose: /* @__PURE__ */ __name(() => closeModal("growthMetrics"), "onClose")
      }
    ) }),
    modals.linkPreview && /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "YÃ¼kleniyor..." }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      LinkPreviewRenderer,
      {
        fetchWithAuth,
        apiBaseUrl: ABSOLUTE_HOST_URL,
        url: null,
        onClose: /* @__PURE__ */ __name(() => closeModal("linkPreview"), "onClose")
      }
    ) }),
    modals.inventory && /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "YÃ¼kleniyor..." }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      InventoryPanel,
      {
        fetchWithAuth,
        apiBaseUrl: ABSOLUTE_HOST_URL,
        onClose: /* @__PURE__ */ __name(() => closeModal("inventory"), "onClose")
      }
    ) }),
    modals.waitlist && activeChat?.type === "room" && activeChat.server_id && /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "YÃ¼kleniyor..." }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      WaitlistPanel,
      {
        fetchWithAuth,
        apiBaseUrl: ABSOLUTE_HOST_URL,
        serverId: activeChat.server_id,
        onClose: /* @__PURE__ */ __name(() => closeModal("waitlist"), "onClose")
      }
    ) }),
    modals.referralRewards && /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "YÃ¼kleniyor..." }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      ReferralRewardsPanel,
      {
        fetchWithAuth,
        apiBaseUrl: ABSOLUTE_HOST_URL,
        onClose: /* @__PURE__ */ __name(() => closeModal("referralRewards"), "onClose")
      }
    ) }),
    modals.miniGames && /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "ðŸŽ® Oyunlar YÃ¼kleniyor..." }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      MiniGamesPanel,
      {
        fetchWithAuth,
        apiBaseUrl: ABSOLUTE_HOST_URL,
        serverId: activeChat?.server_id,
        currentUser: username,
        onClose: /* @__PURE__ */ __name(() => closeModal("miniGames"), "onClose")
      }
    ) }),
    modals.projectCollaboration && /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "ðŸ“‚ Projeler YÃ¼kleniyor..." }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      ProjectCollaborationPanel,
      {
        fetchWithAuth,
        apiBaseUrl: ABSOLUTE_HOST_URL,
        serverId: activeChat?.server_id,
        currentUser: username,
        onClose: /* @__PURE__ */ __name(() => closeModal("projectCollaboration"), "onClose")
      }
    ) }),
    modals.avatarStudio && /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "ðŸŽ¨ Avatar Studio YÃ¼kleniyor..." }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      AvatarStudioPanel,
      {
        fetchWithAuth,
        apiBaseUrl: ABSOLUTE_HOST_URL,
        currentUser: username,
        onClose: /* @__PURE__ */ __name(() => closeModal("avatarStudio"), "onClose"),
        onAvatarChange: /* @__PURE__ */ __name((newAvatarUrl) => {
          if (currentUserProfile) {
            setCurrentUserProfile({ ...currentUserProfile, avatar_url: newAvatarUrl });
          }
          y.success("ðŸŽ¨ Avatar gÃ¼ncellendi!");
        }, "onAvatarChange")
      }
    ) })
  ] });
}, "AppModalsBatch1to8");
const AccountDeletionModal = React.lazy(() => __vitePreload(() => import("./AccountDeletionModal-Bw4ik5gg.js"), true ? __vite__mapDeps([89,1,4,3,14,15,0,16]) : void 0));
const AchievementsPanel = React.lazy(() => __vitePreload(() => import("./AchievementsPanel-B8dUoq52.js"), true ? __vite__mapDeps([90,1,3,14,15,0,4,16,91]) : void 0));
const AppearanceSettingsPanel = React.lazy(() => __vitePreload(() => import("./AppearanceSettingsPanel-Bxj7cLbI.js"), true ? __vite__mapDeps([92,1,16,3,14,15,0,4,93]) : void 0));
const AutoRolesPanel = React.lazy(() => __vitePreload(() => import("./AutoRolesPanel-B28K5HKh.js"), true ? __vite__mapDeps([94,1,16,3,14,15,0,4,95]) : void 0));
const BanAppealsPanel = React.lazy(() => __vitePreload(() => import("./BanAppealsPanel-BmWzFlW5.js"), true ? __vite__mapDeps([96,1,4,97]) : void 0));
const BirthdaySystemPanel = React.lazy(() => __vitePreload(() => import("./BirthdaySystemPanel-2i_s6nJU.js"), true ? __vite__mapDeps([98,1,16,3,14,15,0,4,99]) : void 0));
const BlockListPanel = React.lazy(() => __vitePreload(() => import("./BlockListPanel-fyPAXRqO.js"), true ? __vite__mapDeps([100,1,16,3,14,15,0,4,101]) : void 0));
const BotMarketplace = React.lazy(() => __vitePreload(() => import("./BotMarketplace-DecUc5NP.js"), true ? __vite__mapDeps([102,1,3,14,15,0,4,16,103]) : void 0));
const ChangelogPanel = React.lazy(() => __vitePreload(() => import("./ChangelogPanel-Ch212w6j.js"), true ? __vite__mapDeps([104,1,4,105]) : void 0));
const CommandPalette = React.lazy(() => __vitePreload(() => import("./CommandPalette-DEX-h-w2.js"), true ? __vite__mapDeps([106,1,4,3,14,15,0,16,107]) : void 0));
const CustomCommandsPanel = React.lazy(() => __vitePreload(() => import("./CustomCommandsPanel-HP4Ptsd_.js"), true ? __vite__mapDeps([108,1,16,3,14,15,0,4,109]) : void 0));
const CustomEmbedPanel = React.lazy(() => __vitePreload(() => import("./CustomEmbedPanel-B2YjOp0-.js"), true ? __vite__mapDeps([110,1,16,3,14,15,0,4,111]) : void 0));
const E2EESettingsPanel = React.lazy(() => __vitePreload(() => import("./E2EESettingsPanel-Bu2xjuVt.js"), true ? __vite__mapDeps([112,3,1,4,14,15,0,16]) : void 0));
const EventCalendar = React.lazy(() => __vitePreload(() => import("./EventCalendar-CqWzHANE.js"), true ? __vite__mapDeps([113,1,4]) : void 0));
const ForumPanel = React.lazy(() => __vitePreload(() => import("./ForumPanel-Cg4YKtbe.js"), true ? __vite__mapDeps([114,1,3,14,15,0,4,16,115]) : void 0));
const GiveawayPanel = React.lazy(() => __vitePreload(() => import("./GiveawayPanel-WTAKnx-f.js"), true ? __vite__mapDeps([116,1,16,3,14,15,0,4,117]) : void 0));
const HighlightsPanel = React.lazy(() => __vitePreload(() => import("./HighlightsPanel-cZ0rYJ9P.js"), true ? __vite__mapDeps([118,1,16,119,3,14,15,0,4,120]) : void 0));
const IntegrationHubPanel = React.lazy(() => __vitePreload(() => import("./IntegrationHubPanel-DvU2UgBp.js"), true ? __vite__mapDeps([121,1,4,16,3,14,15,0,122]) : void 0));
const KeyboardShortcutsModal = React.lazy(() => __vitePreload(() => import("./KeyboardShortcutsModal-D5GaGFa_.js"), true ? __vite__mapDeps([123,1,4]) : void 0));
const LanguageSelector = React.lazy(() => __vitePreload(() => import("./LanguageSelector-O70Km-tX.js"), true ? __vite__mapDeps([124,1,0,3,14,15,4,16,125]) : void 0));
const LevelingSystemPanel = React.lazy(() => __vitePreload(() => import("./LevelingSystemPanel-D_GpIthE.js"), true ? __vite__mapDeps([126,1,16,3,14,15,0,4,127]) : void 0));
const LiveStreamPanel = React.lazy(() => __vitePreload(() => import("./LiveStreamPanel-Bs4ri7Ey.js"), true ? __vite__mapDeps([128,1,4]) : void 0));
const LoginHistory = React.lazy(() => __vitePreload(() => import("./LoginHistory-C2fgibfc.js"), true ? __vite__mapDeps([129,1,4]) : void 0));
const LogoutModal = React.lazy(() => __vitePreload(() => import("./LogoutModal-B4uPtFZv.js"), true ? __vite__mapDeps([11,1,12]) : void 0));
const MessageSearchPanel = React.lazy(() => __vitePreload(() => import("./MessageSearchPanel-BgdC1osD.js"), true ? __vite__mapDeps([130,1,4,3,14,15,0,16,131]) : void 0));
const MusicPlayer = React.lazy(() => __vitePreload(() => import("./MusicPlayer-DGaj7k61.js"), true ? __vite__mapDeps([132,1,4,3,14,15,0,16,133]) : void 0));
const NotificationSoundSettings = React.lazy(() => __vitePreload(() => import("./NotificationSoundSettings-DWpAJxaO.js"), true ? __vite__mapDeps([134,1,4]) : void 0));
const PremiumModal = React.lazy(() => __vitePreload(() => import("./PremiumModal-CFE1Dd0q.js"), true ? __vite__mapDeps([135,1,3,14,15,0,4,16]) : void 0));
const PrivacySettingsPanel = React.lazy(() => __vitePreload(() => import("./PrivacySettingsPanel-CfZaaSFf.js"), true ? __vite__mapDeps([136,1,16,3,14,15,0,4,137]) : void 0));
const ProfileCustomization = React.lazy(() => __vitePreload(() => import("./ProfileCustomization-BJfYgMpH.js"), true ? __vite__mapDeps([138,1,4,3,14,15,0,16]) : void 0));
const QuickSwitcher = React.lazy(() => __vitePreload(() => import("./QuickSwitcher-XwmF63EV.js"), true ? __vite__mapDeps([139,1,4,140]) : void 0));
const ReactionRolesPanel = React.lazy(() => __vitePreload(() => import("./ReactionRolesPanel-D9_ZU0aX.js"), true ? __vite__mapDeps([141,1,16,3,14,15,0,4,142]) : void 0));
const ReminderPanel = React.lazy(() => __vitePreload(() => import("./ReminderPanel-Dkvw-jRV.js"), true ? __vite__mapDeps([143,1,16,3,14,15,0,4,144]) : void 0));
const ScheduledMessagesPanel = React.lazy(() => __vitePreload(() => import("./ScheduledMessagesPanel-D2KwFkyN.js"), true ? __vite__mapDeps([145,1,3,14,15,0,4,16,146]) : void 0));
const SecuritySettingsPanel = React.lazy(() => __vitePreload(() => import("./SecuritySettingsPanel-DVstCrkd.js"), true ? __vite__mapDeps([147,1,16,3,14,15,0,4,148]) : void 0));
const ServerBackupPanel = React.lazy(() => __vitePreload(() => import("./ServerBackupPanel-CJnjsjcp.js"), true ? __vite__mapDeps([149,1,16,3,14,15,0,4,150]) : void 0));
const ServerClonePanel = React.lazy(() => __vitePreload(() => import("./ServerClonePanel-BD8f7Ard.js"), true ? __vite__mapDeps([151,1,4,3,14,15,0,16,152]) : void 0));
const ServerDiscoveryPage = React.lazy(() => __vitePreload(() => import("./ServerDiscoveryPage-hE-IdVfX.js"), true ? __vite__mapDeps([153,1,3,14,15,0,4,16,154]) : void 0));
const SpotifyIntegrationPanel = React.lazy(() => __vitePreload(() => import("./SpotifyIntegrationPanel-Bx1vw9y7.js"), true ? __vite__mapDeps([155,1,4,156]) : void 0));
const StageChannelPanel = React.lazy(() => __vitePreload(() => import("./StageChannelPanel-B0CEZ-9H.js"), true ? __vite__mapDeps([157,1,3,14,15,0,4,16,158]) : void 0));
const StarboardPanel = React.lazy(() => __vitePreload(() => import("./StarboardPanel-BIXtfAjI.js"), true ? __vite__mapDeps([159,1,16,3,14,15,0,4,160]) : void 0));
const ThreadView = React.lazy(() => __vitePreload(() => import("./ThreadView-709GrGDB.js"), true ? __vite__mapDeps([161,1,4]) : void 0));
const TicketSystemPanel = React.lazy(() => __vitePreload(() => import("./TicketSystemPanel-BPfHSwkW.js"), true ? __vite__mapDeps([162,1,16,3,14,15,0,4,163]) : void 0));
const TournamentSystem = React.lazy(() => __vitePreload(() => import("./TournamentSystem-DSbIJJ6b.js"), true ? __vite__mapDeps([164,1,4,3,14,15,0,16]) : void 0));
const UserSettingsModal = React.lazy(() => __vitePreload(() => import("./UserSettingsModal-d0UikIEa.js"), true ? __vite__mapDeps([165,1,4,3,14,15,0,16]) : void 0));
const VideoCallModal = React.lazy(() => __vitePreload(() => import("./VideoCallModal-BCiQHGBX.js"), true ? __vite__mapDeps([166,1,4]) : void 0));
const VoiceSettingsPanel = React.lazy(() => __vitePreload(() => import("./VoiceSettingsPanel-C5MXlqa8.js"), true ? __vite__mapDeps([167,1,4,16,3,14,15,0,168]) : void 0));
const WatchTogether = React.lazy(() => __vitePreload(() => import("./index-CKlHPrBa.js"), true ? __vite__mapDeps([169,1,4,3,14,15,0,16,170]) : void 0));
const WeeklyChallengesPanel = React.lazy(() => __vitePreload(() => import("./WeeklyChallengesPanel-B-Lahrgc.js"), true ? __vite__mapDeps([171,1,4]) : void 0));
const WelcomeMessagesPanel = React.lazy(() => __vitePreload(() => import("./WelcomeMessagesPanel-DRgKL7i_.js"), true ? __vite__mapDeps([172,1,16,3,14,15,0,4,173]) : void 0));
const isServer = /* @__PURE__ */ __name((c) => c.activeChat?.type === "room" && c.activeChat?.server_id, "isServer");
const api$2 = /* @__PURE__ */ __name((c) => ({ fetchWithAuth: c.fetchWithAuth, apiBaseUrl: ABSOLUTE_HOST_URL }), "api$2");
const BATCH10_MODALS = [
  // === SETTINGS & NAVIGATION (1-10) ===
  {
    key: "userSettings",
    C: UserSettingsModal,
    fb: "âš™ï¸ Ayarlar YÃ¼kleniyor...",
    props: /* @__PURE__ */ __name((c) => ({
      ...api$2(c),
      currentUser: c.currentUserProfile,
      username: c.username,
      onOpenAppearance: /* @__PURE__ */ __name(() => c.openModal("appearanceSettings"), "onOpenAppearance"),
      onOpenPrivacy: /* @__PURE__ */ __name(() => c.openModal("privacySettings"), "onOpenPrivacy"),
      onOpenSecurity: /* @__PURE__ */ __name(() => c.openModal("securitySettings"), "onOpenSecurity"),
      onOpenNotifications: /* @__PURE__ */ __name(() => c.openModal("notificationSounds"), "onOpenNotifications"),
      onOpenConnections: /* @__PURE__ */ __name(() => c.openModal("connectionsPanel"), "onOpenConnections"),
      onOpenLanguage: /* @__PURE__ */ __name(() => c.openModal("languageSelector"), "onOpenLanguage"),
      onLogout: /* @__PURE__ */ __name(() => c.openModal("logoutConfirm"), "onLogout")
    }), "props")
  },
  { key: "keyboardShortcuts", C: KeyboardShortcutsModal },
  {
    key: "commandPalette",
    C: CommandPalette,
    props: /* @__PURE__ */ __name((c) => ({
      categories: c.categories,
      conversations: c.conversations,
      allUsers: c.allUsers,
      onNavigate: /* @__PURE__ */ __name((t) => {
        if (t.type === "room") c.setActiveChat({ type: "room", slug: t.slug });
        else if (t.type === "dm") c.setActiveChat({ type: "dm", id: t.id });
        c.closeModal("commandPalette");
      }, "onNavigate")
    }), "props")
  },
  {
    key: "serverDiscovery",
    C: ServerDiscoveryPage,
    fb: "ðŸŒ Sunucu KeÅŸfet YÃ¼kleniyor...",
    props: /* @__PURE__ */ __name((c) => ({
      ...api$2(c),
      currentUsername: c.username,
      onJoinServer: /* @__PURE__ */ __name((s) => {
        y.success(`${s.name} sunucusuna katÄ±ldÄ±n!`);
        c.closeModal("serverDiscovery");
      }, "onJoinServer")
    }), "props")
  },
  {
    key: "appearanceSettings",
    C: AppearanceSettingsPanel,
    props: /* @__PURE__ */ __name((c) => ({ currentTheme: c.currentTheme, onThemeChange: c.setCurrentTheme }), "props")
  },
  { key: "languageSelector", C: LanguageSelector },
  { key: "changelog", C: ChangelogPanel, props: api$2 },
  {
    key: "logoutConfirm",
    C: LogoutModal,
    props: /* @__PURE__ */ __name((c) => ({ onConfirm: /* @__PURE__ */ __name(() => {
      c.logout();
      c.closeModal("logoutConfirm");
    }, "onConfirm") }), "props")
  },
  {
    key: "notificationSounds",
    C: NotificationSoundSettings,
    props: /* @__PURE__ */ __name((c) => ({ soundSettings: c.soundSettings, onUpdateSettings: c.setSoundSettings }), "props")
  },
  {
    key: "quickSwitcher",
    C: QuickSwitcher,
    props: /* @__PURE__ */ __name((c) => ({
      categories: c.categories,
      conversations: c.conversations,
      onSelect: /* @__PURE__ */ __name((item) => {
        if (item.type === "room") c.setActiveChat({ type: "room", slug: item.slug });
        else if (item.type === "dm") c.setActiveChat({ type: "dm", id: item.id });
        c.closeModal("quickSwitcher");
      }, "onSelect")
    }), "props")
  },
  // === SECURITY & PRIVACY (11-16) ===
  { key: "loginHistory", C: LoginHistory, props: api$2 },
  {
    key: "securitySettings",
    C: SecuritySettingsPanel,
    props: /* @__PURE__ */ __name((c) => ({
      ...api$2(c),
      username: c.username,
      onOpen2FA: /* @__PURE__ */ __name(() => c.openModal("twoFactorSetup"), "onOpen2FA"),
      onOpenLoginHistory: /* @__PURE__ */ __name(() => c.openModal("loginHistory"), "onOpenLoginHistory")
    }), "props")
  },
  {
    key: "privacySettings",
    C: PrivacySettingsPanel,
    props: /* @__PURE__ */ __name((c) => ({ ...api$2(c), username: c.username, onOpenBlockList: /* @__PURE__ */ __name(() => c.openModal("blockList"), "onOpenBlockList") }), "props")
  },
  {
    key: "accountDeletion",
    C: AccountDeletionModal,
    props: /* @__PURE__ */ __name((c) => ({
      ...api$2(c),
      username: c.username,
      onConfirm: /* @__PURE__ */ __name(() => {
        c.logout();
        c.closeModal("accountDeletion");
      }, "onConfirm")
    }), "props")
  },
  { key: "blockList", C: BlockListPanel, props: api$2 },
  {
    key: "e2EESettings",
    C: E2EESettingsPanel,
    props: /* @__PURE__ */ __name((c) => ({ ...api$2(c), encryptionKeys: c.encryptionKeys }), "props")
  },
  // === COMMUNICATION (17-25) ===
  { key: "threadView", C: ThreadView, props: /* @__PURE__ */ __name((c) => ({ ...api$2(c), roomSlug: c.activeChat?.slug }), "props") },
  { key: "scheduledMessages", C: ScheduledMessagesPanel, props: /* @__PURE__ */ __name((c) => ({ ...api$2(c), username: c.username }), "props") },
  { key: "reminders", C: ReminderPanel, props: /* @__PURE__ */ __name((c) => ({ ...api$2(c), username: c.username }), "props") },
  {
    key: "forum",
    C: ForumPanel,
    fb: "ðŸ“‹ Forum YÃ¼kleniyor...",
    cond: isServer,
    props: /* @__PURE__ */ __name((c) => ({ ...api$2(c), roomSlug: c.activeChat.slug, serverId: c.activeChat.server_id, currentUser: c.username }), "props")
  },
  {
    key: "stageChannel",
    C: StageChannelPanel,
    fb: "ðŸŽ¤ Sahne YÃ¼kleniyor...",
    props: /* @__PURE__ */ __name((c) => ({ ...api$2(c), roomSlug: c.activeChat?.slug, currentUser: c.username }), "props")
  },
  {
    key: "videoCall",
    C: VideoCallModal,
    fb: "ðŸ“¹ Video Arama YÃ¼kleniyor...",
    props: /* @__PURE__ */ __name((c) => ({
      ...api$2(c),
      currentUser: c.username,
      targetUser: c.activeChat?.type === "dm" ? c.activeChat.name : null
    }), "props")
  },
  {
    key: "voiceSettings",
    C: VoiceSettingsPanel,
    props: /* @__PURE__ */ __name((c) => ({
      isMuted: c.isMuted,
      isDeafened: c.isDeafened,
      onToggleMute: c.toggleMute,
      onToggleDeafened: c.toggleDeafened
    }), "props")
  },
  {
    key: "messageSearch",
    C: MessageSearchPanel,
    props: /* @__PURE__ */ __name((c) => ({
      ...api$2(c),
      roomSlug: c.activeChat?.slug,
      onMessageClick: /* @__PURE__ */ __name((msg) => {
        if (msg.room) c.setActiveChat({ type: "room", slug: msg.room });
        c.closeModal("messageSearch");
      }, "onMessageClick")
    }), "props")
  },
  {
    key: "watchTogether",
    C: WatchTogether,
    fb: "ðŸŽ¬ Birlikte Ä°zle YÃ¼kleniyor...",
    props: /* @__PURE__ */ __name((c) => ({ ...api$2(c), roomSlug: c.activeChat?.slug, currentUser: c.username }), "props")
  },
  // === SERVER MANAGEMENT (26-35) ===
  { key: "autoRoles", C: AutoRolesPanel, cond: isServer, props: /* @__PURE__ */ __name((c) => ({ ...api$2(c), serverId: c.activeChat.server_id }), "props") },
  { key: "reactionRoles", C: ReactionRolesPanel, cond: isServer, props: /* @__PURE__ */ __name((c) => ({ ...api$2(c), serverId: c.activeChat.server_id }), "props") },
  { key: "welcomeMessages", C: WelcomeMessagesPanel, cond: isServer, props: /* @__PURE__ */ __name((c) => ({ ...api$2(c), serverId: c.activeChat.server_id }), "props") },
  {
    key: "eventCalendar",
    C: EventCalendar,
    fb: "ðŸ“… Etkinlikler YÃ¼kleniyor...",
    cond: isServer,
    props: /* @__PURE__ */ __name((c) => ({ ...api$2(c), serverId: c.activeChat.server_id, currentUser: c.username }), "props")
  },
  {
    key: "giveaway",
    C: GiveawayPanel,
    fb: "ðŸŽ‰ Ã‡ekiliÅŸ YÃ¼kleniyor...",
    cond: isServer,
    props: /* @__PURE__ */ __name((c) => ({ ...api$2(c), serverId: c.activeChat.server_id, currentUser: c.username }), "props")
  },
  {
    key: "ticketSystem",
    C: TicketSystemPanel,
    fb: "ðŸŽ« Destek Sistemi YÃ¼kleniyor...",
    cond: isServer,
    props: /* @__PURE__ */ __name((c) => ({ ...api$2(c), serverId: c.activeChat.server_id, currentUser: c.username }), "props")
  },
  { key: "starboard", C: StarboardPanel, cond: isServer, props: /* @__PURE__ */ __name((c) => ({ ...api$2(c), serverId: c.activeChat.server_id }), "props") },
  { key: "serverBackup", C: ServerBackupPanel, cond: isServer, props: /* @__PURE__ */ __name((c) => ({ ...api$2(c), serverId: c.activeChat.server_id }), "props") },
  { key: "banAppeals", C: BanAppealsPanel, cond: isServer, props: /* @__PURE__ */ __name((c) => ({ ...api$2(c), serverId: c.activeChat.server_id }), "props") },
  { key: "customCommands", C: CustomCommandsPanel, cond: isServer, props: /* @__PURE__ */ __name((c) => ({ ...api$2(c), serverId: c.activeChat.server_id }), "props") },
  // === GAMIFICATION & SOCIAL (36-50) ===
  {
    key: "levelingSystem",
    C: LevelingSystemPanel,
    fb: "ðŸ“Š Seviye Sistemi YÃ¼kleniyor...",
    cond: isServer,
    props: /* @__PURE__ */ __name((c) => ({ ...api$2(c), serverId: c.activeChat.server_id, currentUser: c.username }), "props")
  },
  {
    key: "liveStream",
    C: LiveStreamPanel,
    fb: "ðŸ“º CanlÄ± YayÄ±n YÃ¼kleniyor...",
    props: /* @__PURE__ */ __name((c) => ({ ...api$2(c), roomSlug: c.activeChat?.slug, currentUser: c.username }), "props")
  },
  {
    key: "achievements",
    C: AchievementsPanel,
    fb: "ðŸ† BaÅŸarÄ±mlar YÃ¼kleniyor...",
    props: /* @__PURE__ */ __name((c) => ({ ...api$2(c), username: c.username }), "props")
  },
  {
    key: "birthdaySystem",
    C: BirthdaySystemPanel,
    cond: isServer,
    props: /* @__PURE__ */ __name((c) => ({ ...api$2(c), serverId: c.activeChat.server_id }), "props")
  },
  {
    key: "premium",
    C: PremiumModal,
    fb: "ðŸ’Ž Premium YÃ¼kleniyor...",
    props: /* @__PURE__ */ __name((c) => ({ ...api$2(c), username: c.username }), "props")
  },
  {
    key: "musicPlayer",
    C: MusicPlayer,
    fb: "ðŸŽµ MÃ¼zik YÃ¼kleniyor...",
    props: /* @__PURE__ */ __name((c) => ({ ...api$2(c), roomSlug: c.activeChat?.slug }), "props")
  },
  {
    key: "botMarketplace",
    C: BotMarketplace,
    fb: "ðŸ¤– Bot MaÄŸazasÄ± YÃ¼kleniyor...",
    props: /* @__PURE__ */ __name((c) => ({ ...api$2(c), serverId: c.activeChat?.server_id }), "props")
  },
  {
    key: "profileCustomization",
    C: ProfileCustomization,
    props: /* @__PURE__ */ __name((c) => ({
      ...api$2(c),
      currentUser: c.currentUserProfile,
      onProfileUpdate: /* @__PURE__ */ __name((updated) => c.setCurrentUserProfile(updated), "onProfileUpdate")
    }), "props")
  },
  { key: "integrationHub", C: IntegrationHubPanel, fb: "ðŸ”— Entegrasyonlar YÃ¼kleniyor...", props: api$2 },
  {
    key: "tournaments",
    C: TournamentSystem,
    fb: "ðŸ† Turnuvalar YÃ¼kleniyor...",
    cond: isServer,
    props: /* @__PURE__ */ __name((c) => ({ ...api$2(c), serverId: c.activeChat.server_id, currentUser: c.username }), "props")
  },
  { key: "highlights", C: HighlightsPanel, props: api$2 },
  { key: "customEmbed", C: CustomEmbedPanel, props: /* @__PURE__ */ __name((c) => ({ ...api$2(c), roomSlug: c.activeChat?.slug }), "props") },
  { key: "spotifyIntegration", C: SpotifyIntegrationPanel, fb: "ðŸŽµ Spotify YÃ¼kleniyor...", props: api$2 },
  { key: "serverClone", C: ServerClonePanel, cond: isServer, props: /* @__PURE__ */ __name((c) => ({ ...api$2(c), serverId: c.activeChat.server_id }), "props") },
  {
    key: "weeklyChallenges",
    C: WeeklyChallengesPanel,
    fb: "ðŸŽ¯ HaftalÄ±k GÃ¶revler YÃ¼kleniyor...",
    props: /* @__PURE__ */ __name((c) => ({ ...api$2(c), username: c.username }), "props")
  }
];
const AppModalsBatch10 = /* @__PURE__ */ __name((props) => {
  const { modals, closeModal } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: BATCH10_MODALS.map(({ key, C, fb, cond, props: getProps }) => {
    if (!modals[key]) return null;
    if (cond && !cond(props)) return null;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: fb || "YÃ¼kleniyor..." }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      C,
      {
        onClose: /* @__PURE__ */ __name(() => closeModal(key), "onClose"),
        ...getProps ? getProps(props) : {}
      }
    ) }, key);
  }) });
}, "AppModalsBatch10");
const hexToRgba = /* @__PURE__ */ __name((hex, alpha) => {
  const r = parseInt(hex.slice(1, 3), 16);
  const g = parseInt(hex.slice(3, 5), 16);
  const b = parseInt(hex.slice(5, 7), 16);
  return `rgba(${r},${g},${b},${alpha})`;
}, "hexToRgba");
const getHoverBg = /* @__PURE__ */ __name((color) => hexToRgba(color, 0.2), "getHoverBg");
const FEATURE_SECTIONS = [
  {
    title: "âš™ï¸ Genel Ayarlar",
    color: "#7289da",
    items: [
      { icon: "âš™ï¸", label: "KullanÄ±cÄ± AyarlarÄ±", modal: "userSettings" },
      { icon: "âŒ¨ï¸", label: "KÄ±sayol TuÅŸlarÄ±", modal: "keyboardShortcuts" },
      { icon: "ðŸ”", label: "Komut Paleti", modal: "commandPalette" },
      { icon: "ðŸŒ", label: "Sunucu KeÅŸfet", modal: "serverDiscovery" },
      { icon: "ðŸŽ¨", label: "GÃ¶rÃ¼nÃ¼m", modal: "appearanceSettings" },
      { icon: "ðŸŒ", label: "Dil SeÃ§imi", modal: "languageSelector" },
      { icon: "ðŸ“‹", label: "DeÄŸiÅŸiklik GÃ¼nlÃ¼ÄŸÃ¼", modal: "changelog" },
      { icon: "ðŸ”Š", label: "Bildirim Sesleri", modal: "notificationSounds" },
      { icon: "âš¡", label: "HÄ±zlÄ± GeÃ§iÅŸ", modal: "quickSwitcher" },
      { icon: "ðŸšª", label: "Ã‡Ä±kÄ±ÅŸ Yap", modal: "logoutConfirm" }
    ]
  },
  {
    title: "ðŸ” GÃ¼venlik & Gizlilik",
    color: "#ed4245",
    items: [
      { icon: "ðŸ”", label: "GiriÅŸ GeÃ§miÅŸi", modal: "loginHistory" },
      { icon: "ðŸ›¡ï¸", label: "GÃ¼venlik AyarlarÄ±", modal: "securitySettings" },
      { icon: "ðŸ”’", label: "Gizlilik AyarlarÄ±", modal: "privacySettings" },
      { icon: "ðŸš«", label: "Engel Listesi", modal: "blockList" },
      { icon: "ðŸ”", label: "E2E Åžifreleme", modal: "e2EESettings" },
      { icon: "âŒ", label: "Hesap Silme", modal: "accountDeletion" }
    ]
  },
  {
    title: "ðŸ’¬ Ä°letiÅŸim",
    color: "#3ba55d",
    items: [
      { icon: "ðŸ’¬", label: "Mesaj KonularÄ±", modal: "threadView" },
      { icon: "â°", label: "ZamanlanmÄ±ÅŸ Mesajlar", modal: "scheduledMessages" },
      { icon: "â°", label: "HatÄ±rlatÄ±cÄ±lar", modal: "reminders" },
      { icon: "ðŸ“‹", label: "Forum", modal: "forum" },
      { icon: "ðŸŽ¤", label: "Sahne KanalÄ±", modal: "stageChannel" },
      { icon: "ðŸ“¹", label: "GÃ¶rÃ¼ntÃ¼lÃ¼ Arama", modal: "videoCall" },
      { icon: "ðŸŽ™ï¸", label: "Ses AyarlarÄ±", modal: "voiceSettings" },
      { icon: "ðŸ”", label: "Mesaj Arama", modal: "messageSearch" },
      { icon: "ðŸŽ¬", label: "Birlikte Ä°zle", modal: "watchTogether" }
    ]
  },
  {
    title: "ðŸ  Sunucu YÃ¶netimi",
    color: "#faa61a",
    items: [
      { icon: "ðŸ¤–", label: "Otomatik Roller", modal: "autoRoles" },
      { icon: "ðŸŽ­", label: "Tepki Rolleri", modal: "reactionRoles" },
      { icon: "ðŸ‘‹", label: "HoÅŸ Geldin MesajlarÄ±", modal: "welcomeMessages" },
      { icon: "ðŸ“…", label: "Etkinlik Takvimi", modal: "eventCalendar" },
      { icon: "ðŸŽ‰", label: "Ã‡ekiliÅŸ", modal: "giveaway" },
      { icon: "ðŸŽ«", label: "Destek Sistemi", modal: "ticketSystem" },
      { icon: "â­", label: "YÄ±ldÄ±z Panosu", modal: "starboard" },
      { icon: "ðŸ’¾", label: "Sunucu Yedekleme", modal: "serverBackup" },
      { icon: "âš–ï¸", label: "Ban Ä°tirazlarÄ±", modal: "banAppeals" },
      { icon: "ðŸ¤–", label: "Ã–zel Komutlar", modal: "customCommands" },
      { icon: "ðŸ“Š", label: "Seviye Sistemi", modal: "levelingSystem" },
      { icon: "ðŸ“º", label: "CanlÄ± YayÄ±n", modal: "liveStream" }
    ]
  },
  {
    title: "ðŸŽ® EÄŸlence & Sosyal",
    color: "#9b59b6",
    items: [
      { icon: "ðŸ†", label: "BaÅŸarÄ±mlar", modal: "achievements" },
      { icon: "ðŸŽ‚", label: "DoÄŸum GÃ¼nleri", modal: "birthdaySystem" },
      { icon: "ðŸ’Ž", label: "Premium", modal: "premium" },
      { icon: "ðŸŽµ", label: "MÃ¼zik Ã‡alar", modal: "musicPlayer" },
      { icon: "ðŸ¤–", label: "Bot MaÄŸazasÄ±", modal: "botMarketplace" },
      { icon: "ðŸ‘¤", label: "Profil Ã–zelleÅŸtir", modal: "profileCustomization" },
      { icon: "ðŸ”—", label: "Entegrasyonlar", modal: "integrationHub" },
      { icon: "ðŸ†", label: "Turnuvalar", modal: "tournaments" }
    ]
  },
  {
    title: "ðŸ”§ GeliÅŸmiÅŸ",
    color: "#e67e22",
    items: [
      { icon: "ðŸ’¡", label: "Ã–ne Ã‡Ä±kanlar", modal: "highlights" },
      { icon: "ðŸ“¦", label: "Ã–zel Embed", modal: "customEmbed" },
      { icon: "ðŸŽµ", label: "Spotify BaÄŸlantÄ±sÄ±", modal: "spotifyIntegration" },
      { icon: "ðŸ“‹", label: "Sunucu Klonla", modal: "serverClone" },
      { icon: "ðŸŽ¯", label: "HaftalÄ±k GÃ¶revler", modal: "weeklyChallenges" },
      { icon: "ðŸ¤–", label: "AI Chatbot", modal: "aIChatbot" },
      { icon: "ðŸ‘¨â€ðŸ’»", label: "Kod EditÃ¶rÃ¼", modal: "codeEditor" },
      { icon: "ðŸ–¥ï¸", label: "Ekran PaylaÅŸÄ±mÄ±", modal: "screenShare" },
      { icon: "ðŸ“º", label: "CanlÄ± YayÄ±n", modal: "liveStreamModal" },
      { icon: "ðŸ“ˆ", label: "GeliÅŸmiÅŸ Analitik", modal: "advancedAnalytics" },
      { icon: "ðŸ“", label: "Dosya YÃ¶neticisi", modal: "fileManager" },
      { icon: "ðŸ“Š", label: "Raporlar", modal: "reports" },
      { icon: "ðŸ›", label: "Hata Raporlama", modal: "errorReporting" }
    ]
  },
  {
    title: "ðŸ”° Moderasyon & YÃ¶netim",
    color: "#e74c3c",
    items: [
      { icon: "ðŸ›¡ï¸", label: "Moderasyon AraÃ§larÄ±", modal: "moderatorTools" },
      { icon: "ðŸ¤–", label: "AI Moderasyon", modal: "aIModeration" },
      { icon: "ðŸš«", label: "Spam KorumasÄ±", modal: "spamDetection" },
      { icon: "ðŸ“‹", label: "Denetim KayÄ±tlarÄ±", modal: "auditLogs" },
      { icon: "â›”", label: "Ban GeÃ§miÅŸi", modal: "banHistory" },
      { icon: "ðŸ“œ", label: "Moderasyon LoglarÄ±", modal: "moderationLogs" },
      { icon: "ðŸ›¡ï¸", label: "BaskÄ±n KorumasÄ±", modal: "raidProtection" },
      { icon: "ðŸš¨", label: "GÃ¼venlik UyarÄ±larÄ±", modal: "securityAlerts" }
    ]
  },
  {
    title: "ðŸ’¬ MesajlaÅŸma & Medya",
    color: "#1abc9c",
    items: [
      { icon: "ðŸ”–", label: "Yer Ä°mleri", modal: "bookmarks" },
      { icon: "ðŸŽžï¸", label: "GIF SeÃ§ici", modal: "gIFPicker" },
      { icon: "ðŸ“Š", label: "Anket OluÅŸtur", modal: "pollCreator" },
      { icon: "ðŸŽ¨", label: "Ã‡Ä±kartmalar", modal: "stickers" },
      { icon: "ðŸ’¾", label: "KayÄ±tlÄ± Mesajlar", modal: "savedMessages" },
      { icon: "ðŸ””", label: "Bildirim Merkezi", modal: "notificationsCenter" },
      { icon: "ðŸ“", label: "Mesaj Ã–zeti", modal: "messageSummary" },
      { icon: "ðŸŒ", label: "Ã‡eviri Paneli", modal: "translation" }
    ]
  },
  {
    title: "ðŸ  Sunucu YÃ¶netimi (GeniÅŸletilmiÅŸ)",
    color: "#2ecc71",
    items: [
      { icon: "âš™ï¸", label: "Kanal AyarlarÄ±", modal: "channelSettings" },
      { icon: "ðŸ“¨", label: "Davet YÃ¶netimi", modal: "inviteModal" },
      { icon: "ðŸ“‹", label: "Sunucu ÅžablonlarÄ±", modal: "serverTemplates" },
      { icon: "ðŸ“Š", label: "Sunucu AnalitiÄŸi", modal: "serverAnalytics" },
      { icon: "ðŸ‘‘", label: "Rol YÃ¶neticisi", modal: "rolesManager" },
      { icon: "ðŸ‘‹", label: "KarÅŸÄ±lama EkranÄ±", modal: "welcomeScreenEditor" },
      { icon: "ðŸ˜ï¸", label: "Topluluk AyarlarÄ±", modal: "communitySettings" },
      { icon: "ðŸ”—", label: "Davet Linkleri", modal: "inviteLinkManager" }
    ]
  },
  {
    title: "ðŸ¤– Bot & GeliÅŸtirici",
    color: "#3498db",
    items: [
      { icon: "ðŸ¤–", label: "Bot OluÅŸturucu", modal: "botBuilder" },
      { icon: "ðŸ§‘â€ðŸ’»", label: "GeliÅŸtirici PortalÄ±", modal: "botDevPortal" },
      { icon: "ðŸ”—", label: "Webhook YÃ¶neticisi", modal: "webhookManager" },
      { icon: "ðŸ”‘", label: "API AnahtarlarÄ±", modal: "aPIKeys" },
      { icon: "âš¡", label: "Slash KomutlarÄ±", modal: "slashCommands" },
      { icon: "ðŸ’»", label: "Kod Ã‡alÄ±ÅŸtÄ±rÄ±cÄ±", modal: "codeRunner" }
    ]
  },
  {
    title: "ðŸ‘¤ Profil & Sosyal",
    color: "#e91e63",
    items: [
      { icon: "ðŸ‘¤", label: "Profil KartÄ±", modal: "profileCard" },
      { icon: "ðŸ“", label: "KullanÄ±cÄ± NotlarÄ±", modal: "userNotes" },
      { icon: "ðŸŸ¢", label: "Durum SeÃ§ici", modal: "statusPicker" },
      { icon: "ðŸ‘¥", label: "Ortak ArkadaÅŸlar", modal: "mutuals" },
      { icon: "ðŸ…", label: "Profil Vitrini", modal: "profileShowcase" },
      { icon: "ðŸ“±", label: "Oturum YÃ¶neticisi", modal: "sessionManager" }
    ]
  },
  {
    title: "ðŸ’Ž Premium & Ekonomi",
    color: "#f1c40f",
    items: [
      { icon: "ðŸª™", label: "Coin MaÄŸazasÄ±", modal: "coinStore" },
      { icon: "ðŸ’Ž", label: "Premium YÃ¶netimi", modal: "premiumManagement" },
      { icon: "ðŸ“‹", label: "Abonelik YÃ¶netimi", modal: "subscriptionManager" },
      { icon: "ðŸŽ", label: "Premium Hediye Et", modal: "giftPremium" },
      { icon: "ðŸ›’", label: "Premium MaÄŸazasÄ±", modal: "premiumMarketplace" },
      { icon: "ðŸŽ¨", label: "Tema MaÄŸazasÄ±", modal: "themeMarketplace" }
    ]
  }
];
const styles$8 = {
  overlay: {
    position: "fixed",
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    backgroundColor: "rgba(0,0,0,0.85)",
    zIndex: 9999,
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    backdropFilter: "blur(8px)"
  },
  container: {
    backgroundColor: "#2f3136",
    borderRadius: "16px",
    width: "90%",
    maxWidth: "900px",
    maxHeight: "85vh",
    overflow: "auto",
    padding: "32px",
    boxShadow: "0 20px 60px rgba(0,0,0,0.5)",
    border: "1px solid rgba(255,255,255,0.1)"
  },
  header: {
    display: "flex",
    justifyContent: "space-between",
    alignItems: "center",
    marginBottom: "24px"
  },
  title: {
    margin: 0,
    fontSize: "1.5em",
    color: "#fff"
  },
  closeBtn: {
    background: "none",
    border: "none",
    color: "#b9bbbe",
    fontSize: "1.5em",
    cursor: "pointer"
  },
  section: {
    marginBottom: "20px"
  },
  sectionTitle: /* @__PURE__ */ __name((color) => ({
    color,
    fontSize: "0.85em",
    textTransform: "uppercase",
    letterSpacing: "1px",
    marginBottom: "12px"
  }), "sectionTitle"),
  grid: {
    display: "grid",
    gridTemplateColumns: "repeat(auto-fill, minmax(200px, 1fr))",
    gap: "8px"
  },
  button: {
    display: "flex",
    alignItems: "center",
    gap: "10px",
    padding: "10px 14px",
    backgroundColor: "rgba(255,255,255,0.05)",
    border: "1px solid rgba(255,255,255,0.08)",
    borderRadius: "8px",
    color: "#dcddde",
    cursor: "pointer",
    fontSize: "13px",
    transition: "all 0.2s",
    textAlign: "left"
  },
  buttonIcon: {
    fontSize: "16px"
  }
};
const FeatureHubModal = /* @__PURE__ */ __name(() => {
  const { openModal, closeModal } = useUIStore();
  const handleSelect = /* @__PURE__ */ __name((modal) => {
    openModal(modal);
    closeModal("featureHub");
  }, "handleSelect");
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: styles$8.overlay, onClick: /* @__PURE__ */ __name((e) => {
    if (e.target === e.currentTarget) closeModal("featureHub");
  }, "onClick"), children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: styles$8.container, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: styles$8.header, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("h2", { style: styles$8.title, children: [
        "ðŸš€",
        " TÃ¼m Ã–zellikler"
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: /* @__PURE__ */ __name(() => closeModal("featureHub"), "onClick"), style: styles$8.closeBtn, children: "âœ•" })
    ] }),
    FEATURE_SECTIONS.map((section, sIdx) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: sIdx < FEATURE_SECTIONS.length - 1 ? styles$8.section : void 0, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { style: styles$8.sectionTitle(section.color), children: section.title }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: styles$8.grid, children: section.items.map((item, i) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "button",
        {
          onClick: /* @__PURE__ */ __name(() => handleSelect(item.modal), "onClick"),
          style: styles$8.button,
          onMouseEnter: /* @__PURE__ */ __name((e) => {
            e.currentTarget.style.backgroundColor = getHoverBg(section.color);
            e.currentTarget.style.borderColor = section.color;
          }, "onMouseEnter"),
          onMouseLeave: /* @__PURE__ */ __name((e) => {
            e.currentTarget.style.backgroundColor = "rgba(255,255,255,0.05)";
            e.currentTarget.style.borderColor = "rgba(255,255,255,0.08)";
          }, "onMouseLeave"),
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: styles$8.buttonIcon, children: item.icon }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: item.label })
          ]
        },
        i
      )) })
    ] }, sIdx))
  ] }) });
}, "FeatureHubModal");
const AIChatbotPanel = React.lazy(() => __vitePreload(() => import("./AIChatbotPanel-v3Gxxsz6.js"), true ? __vite__mapDeps([174,1,4,3,14,15,0,16,175]) : void 0));
const AIModerationPanel = React.lazy(() => __vitePreload(() => import("./AIModerationPanel-vfmBCrZG.js"), true ? __vite__mapDeps([176,1,4,13,3,14,15,0,16]) : void 0));
const APIKeysPanel = React.lazy(() => __vitePreload(() => import("./APIKeysPanel-CPNZkykh.js"), true ? __vite__mapDeps([177,1,4,3,14,15,0,16]) : void 0));
const AdvancedAnalyticsDashboard = React.lazy(() => __vitePreload(() => import("./AdvancedAnalyticsDashboard-D9W-7shq.js"), true ? __vite__mapDeps([178,1,4,3,14,15,0,16,179]) : void 0));
const AuditLogsPanel = React.lazy(() => __vitePreload(() => import("./AuditLogsPanel-CtPAYxni.js"), true ? __vite__mapDeps([180,1,16,3,14,15,0,4,181]) : void 0));
const BanHistoryPanel = React.lazy(() => __vitePreload(() => import("./BanHistoryPanel-D1pPc2TA.js"), true ? __vite__mapDeps([182,1,4,16,183]) : void 0));
const BotBuilder = React.lazy(() => __vitePreload(() => import("./BotBuilder-DGAydBnn.js"), true ? __vite__mapDeps([184,1,4,13,3,14,15,0,16]) : void 0));
const BotDeveloperPortal = React.lazy(() => __vitePreload(() => import("./BotDeveloperPortal-B00QB35w.js"), true ? __vite__mapDeps([185,1,4,3,14,15,0,16,186]) : void 0));
const ChannelSettingsModal = React.lazy(() => __vitePreload(() => import("./ChannelSettingsModal-DwVgGmfD.js"), true ? __vite__mapDeps([187,1,4,3,14,15,0,16]) : void 0));
const CodeRunnerPanel = React.lazy(() => __vitePreload(() => import("./CodeRunnerPanel-D6xXG7GF.js"), true ? __vite__mapDeps([188,1,4,16,189]) : void 0));
const CoinStoreModal = React.lazy(() => __vitePreload(() => import("./CoinStoreModal-BXmYuior.js"), true ? __vite__mapDeps([42,1,4,3,14,15,0,16]) : void 0));
const CollaborativeCodeEditor = React.lazy(() => __vitePreload(() => import("./CollaborativeCodeEditor-BOj76Z7l.js"), true ? __vite__mapDeps([190,1,4,3,14,15,0,16]) : void 0));
const CommunitySettingsPanel = React.lazy(() => __vitePreload(() => import("./CommunitySettingsPanel-BGghaQk8.js"), true ? __vite__mapDeps([191,1,4,3,14,15,0,16,192]) : void 0));
const ErrorReportingPanel = React.lazy(() => __vitePreload(() => import("./ErrorReportingPanel-8oIX-fRe.js"), true ? __vite__mapDeps([193,1,3,14,15,0,4,16,194]) : void 0));
const FileManagerPanel = React.lazy(() => __vitePreload(() => import("./FileManagerPanel-6a83_Su6.js"), true ? __vite__mapDeps([195,1,4]) : void 0));
const GIFPickerPanel = React.lazy(() => __vitePreload(() => import("./GIFPickerPanel-DISPZZsY.js"), true ? __vite__mapDeps([196,1,4,197]) : void 0));
const GiftPremiumPanel = React.lazy(() => __vitePreload(() => import("./GiftPremiumPanel-l_N0_Kh-.js"), true ? __vite__mapDeps([198,1,4,199]) : void 0));
const InviteLinkManager = React.lazy(() => __vitePreload(() => import("./InviteLinkManager-wWUK3P0I.js"), true ? __vite__mapDeps([200,1,4]) : void 0));
const InviteModal = React.lazy(() => __vitePreload(() => import("./InviteModal-DPRjeSOT.js"), true ? __vite__mapDeps([201,1,4,3,14,15,0,16]) : void 0));
const LiveStreamModal = React.lazy(() => __vitePreload(() => import("./LiveStreamModal-BwuP4i75.js"), true ? __vite__mapDeps([202,1,4,3,14,15,0,16]) : void 0));
const MessageSummaryPanel = React.lazy(() => __vitePreload(() => import("./MessageSummaryPanel-BTf00WRi.js"), true ? __vite__mapDeps([203,1,4,119,204]) : void 0));
const ModerationLogsPanel = React.lazy(() => __vitePreload(() => import("./ModerationLogsPanel-D51Q_nGQ.js"), true ? __vite__mapDeps([205,1,4,16,3,14,15,0,206]) : void 0));
const ModeratorTools = React.lazy(() => __vitePreload(() => import("./ModeratorTools-CH2elA1l.js"), true ? __vite__mapDeps([207,1,4,3,14,15,0,16]) : void 0));
const MutualsPanel = React.lazy(() => __vitePreload(() => import("./MutualsPanel-_u7esGII.js"), true ? __vite__mapDeps([208,1,4,16,209]) : void 0));
const NotificationsCenter = React.lazy(() => __vitePreload(() => import("./NotificationsCenter-DHIfAzy6.js"), true ? __vite__mapDeps([210,1,4,3,14,15,0,16,211]) : void 0));
const PollCreator = React.lazy(() => __vitePreload(() => import("./PollCreator-DXbc-BVW.js"), true ? __vite__mapDeps([212,1,13,3,14,15,0,4,16]) : void 0));
const PremiumManagementPanel = React.lazy(() => __vitePreload(() => import("./PremiumManagementPanel-BVE-3EVU.js"), true ? __vite__mapDeps([213,1,16,3,14,15,0,4,214]) : void 0));
const PremiumMarketplace = React.lazy(() => __vitePreload(() => import("./PremiumMarketplace-S1HoIffv.js"), true ? __vite__mapDeps([215,1,13,3,14,15,0,4,16,216]) : void 0));
const ProfileCard = React.lazy(() => __vitePreload(() => import("./ProfileCard-C32OLjCf.js"), true ? __vite__mapDeps([217,1,3,14,15,0,4,16,218]) : void 0));
const ProfileShowcasePanel = React.lazy(() => __vitePreload(() => import("./ProfileShowcasePanel-U803Ucns.js"), true ? __vite__mapDeps([219,1,4,16,3,14,15,0,220]) : void 0));
const ReportsPanel = React.lazy(() => __vitePreload(() => import("./ReportsPanel-Df1R0ORo.js"), true ? __vite__mapDeps([221,1,3,14,15,0,4,16,222]) : void 0));
const RolesManager = React.lazy(() => __vitePreload(() => import("./RolesManager-i2vrls0B.js"), true ? __vite__mapDeps([223,1,3,14,15,0,4,16,224]) : void 0));
const SavedMessagesModal = React.lazy(() => __vitePreload(() => import("./SavedMessagesModal-CIhVFKdF.js"), true ? __vite__mapDeps([225,1,4]) : void 0));
const ScreenShareModal = React.lazy(() => __vitePreload(() => import("./ScreenShareModal-CYX7LCLg.js"), true ? __vite__mapDeps([226,1,4]) : void 0));
const SecurityAlertsPanel = React.lazy(() => __vitePreload(() => import("./SecurityAlertsPanel-BW_fsW-w.js"), true ? __vite__mapDeps([227,1,4,3,14,15,0,16,228]) : void 0));
const ServerAnalyticsDashboard = React.lazy(() => __vitePreload(() => import("./ServerAnalyticsDashboard-B7OUNCl_.js"), true ? __vite__mapDeps([229,1,4]) : void 0));
const ServerTemplates = React.lazy(() => __vitePreload(() => import("./ServerTemplates-BM2E9hRL.js"), true ? __vite__mapDeps([230,1,4,3,14,15,0,16,231]) : void 0));
const SessionManagerModal = React.lazy(() => __vitePreload(() => import("./SessionManagerModal-DbQklqjF.js"), true ? __vite__mapDeps([232,1,4,3,14,15,0,16]) : void 0));
const SlashCommandsPanel = React.lazy(() => __vitePreload(() => import("./SlashCommandsPanel-DflqoU2n.js"), true ? __vite__mapDeps([233,1,4,234]) : void 0));
const SpamDetectionPanel = React.lazy(() => __vitePreload(() => import("./SpamDetectionPanel-DPIcJaa7.js"), true ? __vite__mapDeps([235,1,4,3,14,15,0,16]) : void 0));
const StatusPicker = React.lazy(() => __vitePreload(() => import("./StatusPicker-DD16Tr_4.js"), true ? __vite__mapDeps([236,1,4]) : void 0));
const StickersPanel = React.lazy(() => __vitePreload(() => import("./StickersPanel-BVRtOuAz.js"), true ? __vite__mapDeps([237,1,3,14,15,0,4,16,238]) : void 0));
const SubscriptionManager = React.lazy(() => __vitePreload(() => import("./SubscriptionManager-DDD3tnnb.js"), true ? __vite__mapDeps([239,1,4,3,14,15,0,16]) : void 0));
const ThemeMarketplace = React.lazy(() => __vitePreload(() => import("./ThemeMarketplace-DGpr98_G.js"), true ? __vite__mapDeps([240,1,13,3,14,15,0,4,16,241]) : void 0));
const TranslationPanel = React.lazy(() => __vitePreload(() => import("./TranslationPanel-0kP4NZJX.js"), true ? __vite__mapDeps([242,1,16,3,14,15,0,4,243]) : void 0));
const UserNotesModal = React.lazy(() => __vitePreload(() => import("./UserNotesModal-CGi7VG1X.js"), true ? __vite__mapDeps([244,1,4]) : void 0));
const WebhookManager = React.lazy(() => __vitePreload(() => import("./WebhookManager-Bm_F0_iZ.js"), true ? __vite__mapDeps([245,1,4,3,14,15,0,16]) : void 0));
const WelcomeScreenEditor = React.lazy(() => __vitePreload(() => import("./WelcomeScreenEditor-BjqJuHeB.js"), true ? __vite__mapDeps([246,1,4]) : void 0));
const API = ABSOLUTE_HOST_URL;
const api$1 = /* @__PURE__ */ __name((c) => ({ fetchWithAuth: c.fetchWithAuth, apiBaseUrl: API }), "api$1");
const BATCH11_MODALS = [
  // 1. Moderator Tools
  {
    key: "moderatorTools",
    C: ModeratorTools,
    fb: "ðŸ›¡ï¸ Moderasyon AraÃ§larÄ± YÃ¼kleniyor...",
    props: /* @__PURE__ */ __name((c) => ({ ...api$1(c), serverId: c.activeChat?.server_id, roomSlug: c.activeChat?.slug }), "props")
  },
  // 2. AI Moderation
  {
    key: "aIModeration",
    C: AIModerationPanel,
    fb: "ðŸ¤– AI Moderasyon YÃ¼kleniyor...",
    props: /* @__PURE__ */ __name((c) => ({ ...api$1(c), serverId: c.activeChat?.server_id }), "props")
  },
  // 3. Spam Detection
  {
    key: "spamDetection",
    C: SpamDetectionPanel,
    fb: "ðŸš« Spam KorumasÄ± YÃ¼kleniyor...",
    props: /* @__PURE__ */ __name((c) => ({ ...api$1(c), serverId: c.activeChat?.server_id }), "props")
  },
  // 4. Audit Logs
  {
    key: "auditLogs",
    C: AuditLogsPanel,
    fb: "ðŸ“‹ Denetim KayÄ±tlarÄ± YÃ¼kleniyor...",
    props: /* @__PURE__ */ __name((c) => ({ ...api$1(c), serverId: c.activeChat?.server_id }), "props")
  },
  // 5. Ban History
  {
    key: "banHistory",
    C: BanHistoryPanel,
    fb: "â›” Ban GeÃ§miÅŸi YÃ¼kleniyor...",
    props: /* @__PURE__ */ __name((c) => ({ ...api$1(c), serverId: c.activeChat?.server_id }), "props")
  },
  // 6. Moderation Logs
  {
    key: "moderationLogs",
    C: ModerationLogsPanel,
    fb: "ðŸ“œ Moderasyon LoglarÄ± YÃ¼kleniyor...",
    props: /* @__PURE__ */ __name((c) => ({ ...api$1(c), serverId: c.activeChat?.server_id }), "props")
  },
  // 8. Security Alerts
  {
    key: "securityAlerts",
    C: SecurityAlertsPanel,
    fb: "ðŸš¨ GÃ¼venlik UyarÄ±larÄ± YÃ¼kleniyor...",
    props: api$1
  },
  // 10. GIF Picker
  {
    key: "gIFPicker",
    C: GIFPickerPanel,
    fb: "ðŸŽžï¸ GIF SeÃ§ici YÃ¼kleniyor...",
    props: /* @__PURE__ */ __name((c) => ({ ...api$1(c), onSelect: /* @__PURE__ */ __name(() => {
      c.closeModal("gIFPicker");
    }, "onSelect") }), "props")
  },
  // 11. Poll Creator
  {
    key: "pollCreator",
    C: PollCreator,
    fb: "ðŸ“Š Anket OluÅŸturucu YÃ¼kleniyor...",
    props: /* @__PURE__ */ __name((c) => ({ ...api$1(c), roomSlug: c.activeChat?.slug }), "props")
  },
  // 12. Stickers
  {
    key: "stickers",
    C: StickersPanel,
    fb: "ðŸŽ¨ Ã‡Ä±kartmalar YÃ¼kleniyor...",
    props: /* @__PURE__ */ __name((c) => ({ ...api$1(c), onSelect: /* @__PURE__ */ __name(() => {
      c.closeModal("stickers");
    }, "onSelect") }), "props")
  },
  // 13. Saved Messages
  {
    key: "savedMessages",
    C: SavedMessagesModal,
    fb: "ðŸ’¾ KayÄ±tlÄ± Mesajlar YÃ¼kleniyor...",
    props: /* @__PURE__ */ __name((c) => ({ ...api$1(c), username: c.username }), "props")
  },
  // 14. Notifications Center
  {
    key: "notificationsCenter",
    C: NotificationsCenter,
    fb: "ðŸ”” Bildirimler YÃ¼kleniyor...",
    props: /* @__PURE__ */ __name((c) => ({ ...api$1(c), username: c.username }), "props")
  },
  // 15. Message Summary
  {
    key: "messageSummary",
    C: MessageSummaryPanel,
    fb: "ðŸ“ Ã–zet YÃ¼kleniyor...",
    props: /* @__PURE__ */ __name((c) => ({ ...api$1(c), roomSlug: c.activeChat?.slug }), "props")
  },
  // 16. Translation
  {
    key: "translation",
    C: TranslationPanel,
    fb: "ðŸŒ Ã‡eviri YÃ¼kleniyor...",
    props: api$1
  },
  // 17. Channel Settings (room only)
  {
    key: "channelSettings",
    C: ChannelSettingsModal,
    fb: "âš™ï¸ Kanal AyarlarÄ± YÃ¼kleniyor...",
    cond: /* @__PURE__ */ __name((c) => c.activeChat?.type === "room", "cond"),
    props: /* @__PURE__ */ __name((c) => ({ ...api$1(c), roomSlug: c.activeChat.slug, serverId: c.activeChat.server_id }), "props")
  },
  // 18. Invite Modal (room only, uses API_BASE_URL)
  {
    key: "inviteModal",
    C: InviteModal,
    fb: "ðŸ“¨ Davet YÃ¼kleniyor...",
    cond: /* @__PURE__ */ __name((c) => c.activeChat?.type === "room", "cond"),
    props: /* @__PURE__ */ __name((c) => ({
      fetchWithAuth: c.fetchWithAuth,
      apiBaseUrl: API_BASE_URL,
      server: (() => {
        for (const srv of c.categories || []) {
          for (const cat of srv.categories || []) {
            if (cat.rooms?.some((r) => r.slug === c.activeChat.id)) {
              return { id: srv.id, name: srv.name, avatar: srv.avatar };
            }
          }
        }
        return { id: c.activeChat.server_id, name: "Sunucu" };
      })(),
      currentUser: c.username
    }), "props")
  },
  // 19. Server Templates
  {
    key: "serverTemplates",
    C: ServerTemplates,
    fb: "ðŸ“‹ Åžablonlar YÃ¼kleniyor...",
    props: api$1
  },
  // 20. Server Analytics
  {
    key: "serverAnalytics",
    C: ServerAnalyticsDashboard,
    fb: "ðŸ“Š Analitik YÃ¼kleniyor...",
    props: /* @__PURE__ */ __name((c) => ({ ...api$1(c), serverId: c.activeChat?.server_id }), "props")
  },
  // 21. Roles Manager (room only)
  {
    key: "rolesManager",
    C: RolesManager,
    fb: "ðŸ‘‘ Rol YÃ¶neticisi YÃ¼kleniyor...",
    cond: /* @__PURE__ */ __name((c) => c.activeChat?.type === "room", "cond"),
    props: /* @__PURE__ */ __name((c) => ({ ...api$1(c), serverId: c.activeChat.server_id }), "props")
  },
  // 22. Welcome Screen Editor
  {
    key: "welcomeScreenEditor",
    C: WelcomeScreenEditor,
    fb: "ðŸ‘‹ KarÅŸÄ±lama EkranÄ± YÃ¼kleniyor...",
    props: /* @__PURE__ */ __name((c) => ({ ...api$1(c), serverId: c.activeChat?.server_id }), "props")
  },
  // 23. Community Settings
  {
    key: "communitySettings",
    C: CommunitySettingsPanel,
    fb: "ðŸ˜ï¸ Topluluk AyarlarÄ± YÃ¼kleniyor...",
    props: /* @__PURE__ */ __name((c) => ({ ...api$1(c), serverId: c.activeChat?.server_id }), "props")
  },
  // 24. Invite Link Manager
  {
    key: "inviteLinkManager",
    C: InviteLinkManager,
    fb: "ðŸ”— Davet Linkleri YÃ¼kleniyor...",
    props: /* @__PURE__ */ __name((c) => ({ ...api$1(c), serverId: c.activeChat?.server_id }), "props")
  },
  // 25. Bot Builder
  {
    key: "botBuilder",
    C: BotBuilder,
    fb: "ðŸ¤– Bot OluÅŸturucu YÃ¼kleniyor...",
    props: api$1
  },
  // 26. Bot Developer Portal
  {
    key: "botDevPortal",
    C: BotDeveloperPortal,
    fb: "ðŸ§‘â€ðŸ’» GeliÅŸtirici PortalÄ± YÃ¼kleniyor...",
    props: api$1
  },
  // 27. Webhook Manager
  {
    key: "webhookManager",
    C: WebhookManager,
    fb: "ðŸ”— Webhook YÃ¶neticisi YÃ¼kleniyor...",
    props: /* @__PURE__ */ __name((c) => ({ ...api$1(c), serverId: c.activeChat?.server_id }), "props")
  },
  // 28. API Keys
  {
    key: "aPIKeys",
    C: APIKeysPanel,
    fb: "ðŸ”‘ API AnahtarlarÄ± YÃ¼kleniyor...",
    props: api$1
  },
  // 29. Slash Commands
  {
    key: "slashCommands",
    C: SlashCommandsPanel,
    fb: "âš¡ Komut YÃ¶neticisi YÃ¼kleniyor...",
    props: /* @__PURE__ */ __name((c) => ({ ...api$1(c), serverId: c.activeChat?.server_id }), "props")
  },
  // 30. Code Runner
  {
    key: "codeRunner",
    C: CodeRunnerPanel,
    fb: "ðŸ’» Kod Ã‡alÄ±ÅŸtÄ±rÄ±cÄ± YÃ¼kleniyor...",
    props: api$1
  },
  // 31. Profile Card
  {
    key: "profileCard",
    C: ProfileCard,
    fb: "ðŸ‘¤ Profil KartÄ± YÃ¼kleniyor...",
    props: /* @__PURE__ */ __name((c) => ({ ...api$1(c), username: c.username, currentUser: c.currentUserProfile }), "props")
  },
  // 32. User Notes
  {
    key: "userNotes",
    C: UserNotesModal,
    fb: "ðŸ“ Notlar YÃ¼kleniyor...",
    props: /* @__PURE__ */ __name((c) => ({ ...api$1(c), username: c.username }), "props")
  },
  // 33. Status Picker
  {
    key: "statusPicker",
    C: StatusPicker,
    fb: "ðŸŸ¢ Durum SeÃ§ici YÃ¼kleniyor...",
    props: /* @__PURE__ */ __name((c) => ({ ...api$1(c), currentUser: c.currentUserProfile }), "props")
  },
  // 34. Mutuals Panel
  {
    key: "mutuals",
    C: MutualsPanel,
    fb: "ðŸ‘¥ Ortak ArkadaÅŸlar YÃ¼kleniyor...",
    props: /* @__PURE__ */ __name((c) => ({ ...api$1(c), username: c.username }), "props")
  },
  // 35. Profile Showcase
  {
    key: "profileShowcase",
    C: ProfileShowcasePanel,
    fb: "ðŸ… Profil Vitrini YÃ¼kleniyor...",
    props: /* @__PURE__ */ __name((c) => ({ ...api$1(c), username: c.username, currentUser: c.currentUserProfile }), "props")
  },
  // 36. Session Manager
  {
    key: "sessionManager",
    C: SessionManagerModal,
    fb: "ðŸ“± Oturum YÃ¶neticisi YÃ¼kleniyor...",
    props: api$1
  },
  // 37. Coin Store
  {
    key: "coinStore",
    C: CoinStoreModal,
    fb: "ðŸª™ MaÄŸaza YÃ¼kleniyor...",
    props: /* @__PURE__ */ __name((c) => ({ ...api$1(c), username: c.username }), "props")
  },
  // 38. Premium Management
  {
    key: "premiumManagement",
    C: PremiumManagementPanel,
    fb: "ðŸ’Ž Premium YÃ¶netimi YÃ¼kleniyor...",
    props: /* @__PURE__ */ __name((c) => ({ ...api$1(c), username: c.username }), "props")
  },
  // 39. Subscription Manager
  {
    key: "subscriptionManager",
    C: SubscriptionManager,
    fb: "ðŸ“‹ Abonelikler YÃ¼kleniyor...",
    props: /* @__PURE__ */ __name((c) => ({ ...api$1(c), username: c.username }), "props")
  },
  // 40. Gift Premium
  {
    key: "giftPremium",
    C: GiftPremiumPanel,
    fb: "ðŸŽ Hediye Premium YÃ¼kleniyor...",
    props: /* @__PURE__ */ __name((c) => ({ ...api$1(c), username: c.username }), "props")
  },
  // 41. Premium Marketplace
  {
    key: "premiumMarketplace",
    C: PremiumMarketplace,
    fb: "ðŸ›’ Premium MaÄŸaza YÃ¼kleniyor...",
    props: api$1
  },
  // 42. Theme Marketplace
  {
    key: "themeMarketplace",
    C: ThemeMarketplace,
    fb: "ðŸŽ¨ Tema MaÄŸazasÄ± YÃ¼kleniyor...",
    props: api$1
  },
  // 43. AI Chatbot
  {
    key: "aIChatbot",
    C: AIChatbotPanel,
    fb: "ðŸ¤– AI Chatbot YÃ¼kleniyor...",
    props: /* @__PURE__ */ __name((c) => ({ ...api$1(c), username: c.username }), "props")
  },
  // 44. Collaborative Code Editor
  {
    key: "codeEditor",
    C: CollaborativeCodeEditor,
    fb: "ðŸ‘¨â€ðŸ’» Kod EditÃ¶rÃ¼ YÃ¼kleniyor...",
    props: /* @__PURE__ */ __name((c) => ({ ...api$1(c), roomSlug: c.activeChat?.slug, username: c.username }), "props")
  },
  // 45. Screen Share
  {
    key: "screenShare",
    C: ScreenShareModal,
    fb: "ðŸ–¥ï¸ Ekran PaylaÅŸÄ±mÄ± YÃ¼kleniyor...",
    props: /* @__PURE__ */ __name((c) => ({ ...api$1(c), roomSlug: c.activeChat?.slug }), "props")
  },
  // 46. Live Stream
  {
    key: "liveStreamModal",
    C: LiveStreamModal,
    fb: "ðŸ“º CanlÄ± YayÄ±n YÃ¼kleniyor...",
    props: /* @__PURE__ */ __name((c) => ({ ...api$1(c), roomSlug: c.activeChat?.slug, username: c.username }), "props")
  },
  // 47. Advanced Analytics
  {
    key: "advancedAnalytics",
    C: AdvancedAnalyticsDashboard,
    fb: "ðŸ“ˆ GeliÅŸmiÅŸ Analitik YÃ¼kleniyor...",
    props: /* @__PURE__ */ __name((c) => ({ ...api$1(c), serverId: c.activeChat?.server_id }), "props")
  },
  // 48. File Manager
  {
    key: "fileManager",
    C: FileManagerPanel,
    fb: "ðŸ“ Dosya YÃ¶neticisi YÃ¼kleniyor...",
    props: /* @__PURE__ */ __name((c) => ({ ...api$1(c), roomSlug: c.activeChat?.slug }), "props")
  },
  // 49. Reports
  {
    key: "reports",
    C: ReportsPanel,
    fb: "ðŸ“Š Raporlar YÃ¼kleniyor...",
    props: /* @__PURE__ */ __name((c) => ({ ...api$1(c), serverId: c.activeChat?.server_id }), "props")
  },
  // 50. Error Reporting
  {
    key: "errorReporting",
    C: ErrorReportingPanel,
    fb: "ðŸ› Hata Raporlama YÃ¼kleniyor...",
    props: api$1
  },
  // Feature Hub (not lazy, no suspense needed)
  { key: "featureHub", C: FeatureHubModal, noSuspense: true }
];
const AppModalsBatch11 = /* @__PURE__ */ __name((props) => {
  const { modals, closeModal } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: BATCH11_MODALS.map(({ key, C, fb, cond, props: getProps, noSuspense }) => {
    if (!modals[key]) return null;
    if (cond && !cond(props)) return null;
    const modalProps = getProps ? { ...getProps({ ...props, closeModal }), onClose: /* @__PURE__ */ __name(() => closeModal(key), "onClose") } : {};
    if (noSuspense) return /* @__PURE__ */ jsxRuntimeExports.jsx(C, { ...modalProps }, key);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: fb || "YÃ¼kleniyor..." }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(C, { ...modalProps }) }, key);
  }) });
}, "AppModalsBatch11");
const ImageLightbox = React.lazy(() => __vitePreload(() => import("./ImageLightbox-Bd9djm77.js"), true ? __vite__mapDeps([247,1,4]) : void 0));
const MessageTemplateModal = React.lazy(() => __vitePreload(() => import("./MessageTemplateModal-CnWeDgQg.js"), true ? __vite__mapDeps([248,1,4,3,14,15,0,16]) : void 0));
const PinnedMessages = React.lazy(() => __vitePreload(() => import("./PinnedMessages-Bg4Z9VnI.js"), true ? __vite__mapDeps([249,1,250,3,4,251,252,253,254,14,15,0,16]) : void 0));
const SummaryModal = React.lazy(() => __vitePreload(() => import("./SummaryModal-BUIQMbK3.js"), true ? __vite__mapDeps([255,1,4]) : void 0));
const ThemeStoreModal = React.lazy(() => __vitePreload(() => import("./ThemeStoreModal-CduloDLv.js"), true ? __vite__mapDeps([256,1,4,3,14,15,0,16]) : void 0));
const UserProfileModal = React.lazy(() => __vitePreload(() => import("./UserProfileModal-nuerxjra.js"), true ? __vite__mapDeps([257,1,4,232,3,14,15,0,16,244]) : void 0));
const AppModalsStandard = /* @__PURE__ */ __name(({
  modals,
  closeModal,
  fetchWithAuth,
  activeChat,
  username,
  currentTheme,
  setCurrentTheme,
  pinnedMessages,
  zoomedImage,
  setZoomedImage,
  galleryData,
  setGalleryData,
  viewingProfile,
  setViewingProfile,
  isAdmin,
  richTextRef,
  getDeterministicAvatar,
  handleDMClick,
  friendsList
}) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    zoomedImage && /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: null, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ImageLightbox, { imageUrl: zoomedImage, onClose: /* @__PURE__ */ __name(() => setZoomedImage(null), "onClose") }) }),
    galleryData && /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: null, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ImageLightbox, { images: galleryData.images, startIndex: galleryData.startIndex, onClose: /* @__PURE__ */ __name(() => setGalleryData(null), "onClose") }) }),
    modals.pinned && /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingSpinner, { size: "small", text: "SabitlenmiÅŸ mesajlar yÃ¼kleniyor..." }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(PinnedMessages, { messages: pinnedMessages, onClose: /* @__PURE__ */ __name(() => closeModal("pinned"), "onClose") }) }),
    viewingProfile && /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: null, children: /* @__PURE__ */ jsxRuntimeExports.jsx(UserProfileModal, { user: viewingProfile, onClose: /* @__PURE__ */ __name(() => setViewingProfile(null), "onClose"), onStartDM: handleDMClick, onImageClick: setZoomedImage, getDeterministicAvatar, fetchWithAuth, apiBaseUrl: ABSOLUTE_HOST_URL, currentUser: username, friendsList }) }),
    modals.themeStore && /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingSpinner, { size: "medium", text: "Temalar yÃ¼kleniyor..." }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      ThemeStoreModal,
      {
        onClose: /* @__PURE__ */ __name(() => closeModal("themeStore"), "onClose"),
        currentTheme,
        onThemeChange: setCurrentTheme
      }
    ) }),
    modals.summary && /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingSpinner, { size: "medium", text: "Ã–zet hazÄ±rlanÄ±yor..." }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      SummaryModal,
      {
        roomSlug: activeChat.id,
        onClose: /* @__PURE__ */ __name(() => closeModal("summary"), "onClose"),
        fetchWithAuth,
        apiBaseUrl: ABSOLUTE_HOST_URL
      }
    ) }),
    modals.templateModal && /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingSpinner, { size: "small", text: "Åžablonlar yÃ¼kleniyor..." }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      MessageTemplateModal,
      {
        onClose: /* @__PURE__ */ __name(() => closeModal("templateModal"), "onClose"),
        onSelect: /* @__PURE__ */ __name((content) => {
          richTextRef.current?.appendText?.(content);
          closeModal("templateModal");
        }, "onSelect"),
        fetchWithAuth,
        apiBaseUrl: ABSOLUTE_HOST_URL,
        isAdmin
      }
    ) })
  ] });
}, "AppModalsStandard");
const AppModals = /* @__PURE__ */ __name((props) => {
  const { modals, openModal, closeModal, toggleModal } = useUIStore();
  const shared = { ...props, modals, openModal, closeModal, toggleModal };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(AppModalsCore, { ...shared }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(AppModalsBatch1to8, { ...shared }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(AppModalsBatch10, { ...shared }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(AppModalsBatch11, { ...shared }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(AppModalsStandard, { ...shared })
  ] });
}, "AppModals");
const R2_CDN_URL = MEDIA_BASE_URL$1;
const R2_ASSETS_URL = `${R2_CDN_URL}/assets`;
const LOGO_URL = `${R2_ASSETS_URL}/logo.png`;
const R2_LOGO_URL = LOGO_URL;
const PawLogoSVG = /* @__PURE__ */ __name(() => /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { className: "splash-logo", viewBox: "0 0 100 100", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
  /* @__PURE__ */ jsxRuntimeExports.jsx("ellipse", { cx: "50", cy: "62", rx: "22", ry: "18", fill: "white" }),
  /* @__PURE__ */ jsxRuntimeExports.jsx("ellipse", { cx: "28", cy: "38", rx: "10", ry: "12", fill: "white" }),
  /* @__PURE__ */ jsxRuntimeExports.jsx("ellipse", { cx: "72", cy: "38", rx: "10", ry: "12", fill: "white" }),
  /* @__PURE__ */ jsxRuntimeExports.jsx("ellipse", { cx: "22", cy: "55", rx: "8", ry: "10", fill: "white" }),
  /* @__PURE__ */ jsxRuntimeExports.jsx("ellipse", { cx: "78", cy: "55", rx: "8", ry: "10", fill: "white" })
] }), "PawLogoSVG");
const PawLogo = /* @__PURE__ */ __name(() => {
  const [imgError, setImgError] = reactExports.useState(false);
  if (imgError) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(PawLogoSVG, {});
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "img",
    {
      src: R2_LOGO_URL,
      alt: "Pawscord",
      className: "splash-logo",
      onError: /* @__PURE__ */ __name(() => setImgError(true), "onError")
    }
  );
}, "PawLogo");
const SplashScreen = /* @__PURE__ */ __name(({ animationState }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `splash-screen ${animationState}`, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "particles", children: [...Array(15)].map((_, i) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "particle", style: {
      "--delay": `${Math.random() * 2}s`,
      "--x": `${Math.random() * 100}%`,
      "--size": `${4 + Math.random() * 8}px`,
      "--duration": `${2 + Math.random() * 3}s`
    } }, i)) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rings-container", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "ring ring-1" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "ring ring-2" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "ring ring-3" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "logo-container", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "logo-glow" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(PawLogo, {})
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "brand-text", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "letter", style: { "--i": 0 }, children: "P" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "letter", style: { "--i": 1 }, children: "A" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "letter", style: { "--i": 2 }, children: "W" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "letter", style: { "--i": 3 }, children: "S" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "letter", style: { "--i": 4 }, children: "C" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "letter", style: { "--i": 5 }, children: "O" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "letter", style: { "--i": 6 }, children: "R" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "letter", style: { "--i": 7 }, children: "D" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "loading-bar", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "loading-progress" }) })
  ] });
}, "SplashScreen");
const SplashScreen$1 = React.memo(SplashScreen);
const ConnectionStatusBar = /* @__PURE__ */ __name(() => {
  const [status, setStatus] = reactExports.useState("online");
  const [visible, setVisible] = reactExports.useState(false);
  const [fadeOut, setFadeOut] = reactExports.useState(false);
  const handleOffline = reactExports.useCallback(() => {
    setStatus("offline");
    setVisible(true);
    setFadeOut(false);
  }, []);
  const handleOnline = reactExports.useCallback(() => {
    setStatus("reconnecting");
    setVisible(true);
    setFadeOut(false);
    setTimeout(() => {
      setStatus("online");
      setTimeout(() => {
        setFadeOut(true);
        setTimeout(() => setVisible(false), 500);
      }, 2e3);
    }, 1e3);
  }, []);
  reactExports.useEffect(() => {
    window.addEventListener("online", handleOnline);
    window.addEventListener("offline", handleOffline);
    if (!navigator.onLine) handleOffline();
    return () => {
      window.removeEventListener("online", handleOnline);
      window.removeEventListener("offline", handleOffline);
    };
  }, [handleOnline, handleOffline]);
  if (!visible) return null;
  const config = {
    offline: {
      bg: "linear-gradient(135deg, #da373c, #a12d2f)",
      icon: /* @__PURE__ */ jsxRuntimeExports.jsx(FaExclamationTriangle, {}),
      text: "Ä°nternet baÄŸlantÄ±sÄ± yok",
      pulse: false
    },
    reconnecting: {
      bg: "linear-gradient(135deg, #f0b232, #d4982a)",
      icon: /* @__PURE__ */ jsxRuntimeExports.jsx(FaSync, { className: "conn-status-spin" }),
      text: "Yeniden baÄŸlanÄ±lÄ±yor...",
      pulse: true
    },
    online: {
      bg: "linear-gradient(135deg, #23a559, #1e8e4a)",
      icon: /* @__PURE__ */ jsxRuntimeExports.jsx(FaWifi, {}),
      text: "BaÄŸlantÄ± saÄŸlandÄ±!",
      pulse: false
    }
  };
  const c = config[status];
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      style: {
        ...S$3.bar,
        background: c.bg,
        opacity: fadeOut ? 0 : 1,
        transform: fadeOut ? "translateY(-100%)" : "translateY(0)"
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: S$3.icon, children: c.icon }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: S$3.text, children: c.text })
      ]
    }
  );
}, "ConnectionStatusBar");
const S$3 = {
  bar: {
    position: "fixed",
    top: 0,
    left: 0,
    right: 0,
    height: 32,
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    gap: 8,
    zIndex: 99999,
    transition: "all 0.5s ease",
    boxShadow: "0 2px 8px rgba(0,0,0,0.3)"
  },
  icon: { color: "#fff", fontSize: 14, display: "flex", alignItems: "center" },
  text: { color: "#fff", fontSize: 13, fontWeight: 600 }
};
if (typeof document !== "undefined") {
  const id = "conn-status-css";
  if (!document.getElementById(id)) {
    const s = document.createElement("style");
    s.id = id;
    s.textContent = `@keyframes connSpin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
.conn-status-spin { animation: connSpin 1s linear infinite; }`;
    document.head.appendChild(s);
  }
}
const ConnectionStatusBar$1 = reactExports.memo(ConnectionStatusBar);
const ScrollToBottomButton = /* @__PURE__ */ __name(({ onClick, unreadCount = 0, visible = true }) => {
  if (!visible) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "button",
    {
      onClick,
      style: S$2.fab,
      className: "scroll-to-bottom-fab",
      title: "En alta git",
      children: [
        unreadCount > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: S$2.badge, children: unreadCount > 99 ? "99+" : unreadCount }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(FaChevronDown, { style: { fontSize: 16 } })
      ]
    }
  );
}, "ScrollToBottomButton");
const S$2 = {
  fab: {
    position: "absolute",
    bottom: 90,
    right: 20,
    width: 40,
    height: 40,
    borderRadius: "50%",
    backgroundColor: "#313338",
    border: "1px solid rgba(255,255,255,0.1)",
    color: "#dcddde",
    cursor: "pointer",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    boxShadow: "0 4px 12px rgba(0,0,0,0.4)",
    transition: "all 0.2s ease",
    zIndex: 50
  },
  badge: {
    position: "absolute",
    top: -8,
    right: -4,
    minWidth: 20,
    height: 20,
    borderRadius: 10,
    backgroundColor: "#5865f2",
    color: "#fff",
    fontSize: 11,
    fontWeight: 700,
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    padding: "0 5px",
    boxShadow: "0 2px 6px rgba(88,101,242,0.4)"
  }
};
if (typeof document !== "undefined") {
  const id = "scroll-bottom-fab-css";
  if (!document.getElementById(id)) {
    const s = document.createElement("style");
    s.id = id;
    s.textContent = `.scroll-to-bottom-fab:hover { background-color: #404249 !important; transform: scale(1.1); }`;
    document.head.appendChild(s);
  }
}
const ScrollToBottomButton$1 = reactExports.memo(ScrollToBottomButton);
const formatDateLabel = /* @__PURE__ */ __name((dateStr) => {
  const date = new Date(dateStr);
  const now = /* @__PURE__ */ new Date();
  const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
  const yesterday = new Date(today.getTime() - 864e5);
  const msgDate = new Date(date.getFullYear(), date.getMonth(), date.getDate());
  if (msgDate.getTime() === today.getTime()) return "BugÃ¼n";
  if (msgDate.getTime() === yesterday.getTime()) return "DÃ¼n";
  const diffDays = Math.floor((today.getTime() - msgDate.getTime()) / 864e5);
  if (diffDays < 7) {
    const days = ["Pazar", "Pazartesi", "SalÄ±", "Ã‡arÅŸamba", "PerÅŸembe", "Cuma", "Cumartesi"];
    return days[date.getDay()];
  }
  return date.toLocaleDateString("tr-TR", { day: "numeric", month: "long", year: "numeric" });
}, "formatDateLabel");
const MessageDateDivider = /* @__PURE__ */ __name(({ date }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: S$1.container, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: S$1.line }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: S$1.label, children: formatDateLabel(date) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: S$1.line })
  ] });
}, "MessageDateDivider");
const S$1 = {
  container: {
    display: "flex",
    alignItems: "center",
    gap: 12,
    padding: "16px 0 8px",
    userSelect: "none"
  },
  line: {
    flex: 1,
    height: 1,
    backgroundColor: "rgba(255,255,255,0.06)"
  },
  label: {
    color: "#949ba4",
    fontSize: 12,
    fontWeight: 600,
    whiteSpace: "nowrap",
    padding: "2px 8px",
    borderRadius: 12,
    backgroundColor: "rgba(255,255,255,0.03)"
  }
};
const MessageDateDivider$1 = reactExports.memo(MessageDateDivider);
const TypingIndicatorEnhanced = /* @__PURE__ */ __name(({ typingUsers = [], currentUser }) => {
  const filtered = reactExports.useMemo(
    () => typingUsers.filter((u) => u !== currentUser),
    [typingUsers, currentUser]
  );
  if (filtered.length === 0) return null;
  const text = reactExports.useMemo(() => {
    if (filtered.length === 1) return `${filtered[0]} yazÄ±yor`;
    if (filtered.length === 2) return `${filtered[0]} ve ${filtered[1]} yazÄ±yor`;
    if (filtered.length === 3) return `${filtered[0]}, ${filtered[1]} ve ${filtered[2]} yazÄ±yor`;
    return `${filtered[0]}, ${filtered[1]} ve ${filtered.length - 2} kiÅŸi daha yazÄ±yor`;
  }, [filtered]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: S.container, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: S.dots, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { ...S.dot, animationDelay: "0s" } }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { ...S.dot, animationDelay: "0.2s" } }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { ...S.dot, animationDelay: "0.4s" } })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: S.text, children: text })
  ] });
}, "TypingIndicatorEnhanced");
const S = {
  container: {
    display: "flex",
    alignItems: "center",
    gap: 8,
    padding: "4px 16px",
    height: 24,
    overflow: "hidden"
  },
  dots: {
    display: "flex",
    gap: 3,
    alignItems: "center"
  },
  dot: {
    width: 6,
    height: 6,
    borderRadius: "50%",
    backgroundColor: "#fff",
    animation: "typingDotBounce 1.2s infinite ease-in-out"
  },
  text: {
    color: "#949ba4",
    fontSize: 12,
    fontWeight: 500,
    whiteSpace: "nowrap",
    overflow: "hidden",
    textOverflow: "ellipsis"
  }
};
if (typeof document !== "undefined") {
  const id = "typing-enhanced-css";
  if (!document.getElementById(id)) {
    const s = document.createElement("style");
    s.id = id;
    s.textContent = `
            @keyframes typingDotBounce {
                0%, 60%, 100% { transform: translateY(0); opacity: 0.4; }
                30% { transform: translateY(-4px); opacity: 1; }
            }
        `;
    document.head.appendChild(s);
  }
}
const TypingIndicatorEnhanced$1 = reactExports.memo(TypingIndicatorEnhanced);
const ImageGalleryGroup = React.memo(({ messages, currentUser, absoluteHostUrl, isAdmin, onOpenGallery, onViewProfile, onDelete, allUsers, getDeterministicAvatar, fetchWithAuth, onVisible }) => {
  const firstMsg = messages[0];
  const userAvatarBase = (() => {
    let url = firstMsg.avatar;
    if (!url) {
      const userObj = allUsers?.find((u) => u.username === firstMsg.username);
      url = userObj?.avatar;
    }
    if (!url) url = getDeterministicAvatar(firstMsg.username);
    if (url && !url.startsWith("http") && !url.startsWith("blob:")) {
      url = `${absoluteHostUrl.replace(/\/$/, "")}/${url.replace(/^\//, "")}`;
    }
    return url;
  })();
  const getFullUrl = /* @__PURE__ */ __name((url) => {
    if (!url) return null;
    if (url.startsWith("http") || url.startsWith("blob:")) return url;
    return `${absoluteHostUrl.replace(/\/$/, "")}/${url.replace(/^\//, "")}`;
  }, "getFullUrl");
  const allImages = messages.map((msg) => {
    const imgUrl = msg.image_url || msg.image;
    if (imgUrl) return getFullUrl(imgUrl);
    const fileUrl = msg.file_url || msg.file;
    if (fileUrl && /\.(jpg|jpeg|png|gif|webp|bmp|svg)$/i.test(msg.file_name || "")) {
      return getFullUrl(fileUrl);
    }
    return null;
  }).filter(Boolean);
  const MAX_VISIBLE = 4;
  const totalCount = allImages.length;
  const visibleImages = allImages.slice(0, MAX_VISIBLE);
  const visibleCount = visibleImages.length;
  const extraCount = Math.max(0, totalCount - MAX_VISIBLE);
  const getGridStyle = /* @__PURE__ */ __name(() => {
    if (visibleCount === 1) return { gridTemplateColumns: "1fr", maxWidth: "300px" };
    if (visibleCount === 2) return { gridTemplateColumns: "1fr 1fr", maxWidth: "400px" };
    if (visibleCount === 3) return { gridTemplateColumns: "1fr 1fr", maxWidth: "400px" };
    return { gridTemplateColumns: "1fr 1fr", maxWidth: "400px" };
  }, "getGridStyle");
  const timestamp = firstMsg.timestamp ? new Date(firstMsg.timestamp) : null;
  const timeStr = timestamp ? timestamp.toDateString() === (/* @__PURE__ */ new Date()).toDateString() ? timestamp.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" }) : timestamp.toLocaleString([], { hour: "2-digit", minute: "2-digit" }) : "";
  const handleImageClick = /* @__PURE__ */ __name((clickedIndex) => {
    if (onOpenGallery) {
      onOpenGallery(allImages, clickedIndex);
    }
  }, "handleImageClick");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
    display: "flex",
    padding: "4px 48px 4px 16px",
    gap: "12px",
    position: "relative"
  }, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { flexShrink: 0, width: "40px", paddingTop: "2px" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "img",
      {
        src: userAvatarBase,
        alt: firstMsg.username,
        style: { width: "40px", height: "40px", borderRadius: "50%", cursor: "pointer", objectFit: "cover" },
        onClick: /* @__PURE__ */ __name(() => onViewProfile(firstMsg.username), "onClick")
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { flex: 1, minWidth: 0 }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", gap: "8px", marginBottom: "4px" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { style: {
          cursor: "pointer",
          color: isAdmin && firstMsg.username === currentUser ? "#f0b232" : "#fff",
          fontSize: "0.95em"
        }, onClick: /* @__PURE__ */ __name(() => onViewProfile(firstMsg.username), "onClick"), children: firstMsg.username }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { color: "#72767d", fontSize: "0.75em" }, children: timeStr }),
        totalCount > 1 && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { style: { color: "#5865f2", fontSize: "0.72em", fontWeight: 600 }, children: [
          "ðŸ“· ",
          totalCount,
          " fotoÄŸraf"
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
        display: "grid",
        ...getGridStyle(),
        gap: "3px",
        borderRadius: "12px",
        overflow: "hidden",
        boxShadow: "0 2px 10px rgba(0,0,0,0.3)"
      }, children: visibleImages.map((imgUrl, idx) => {
        const isLastWithExtra = idx === MAX_VISIBLE - 1 && extraCount > 0;
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            style: {
              aspectRatio: visibleCount === 1 ? "auto" : visibleCount === 3 && idx === 0 ? "2/1" : "1/1",
              overflow: "hidden",
              position: "relative",
              ...visibleCount === 3 && idx === 0 ? { gridColumn: "1 / -1" } : {},
              maxHeight: visibleCount === 1 ? "300px" : visibleCount === 3 && idx === 0 ? "200px" : "200px",
              cursor: "pointer"
            },
            onClick: /* @__PURE__ */ __name(() => handleImageClick(idx), "onClick"),
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "img",
                {
                  src: imgUrl,
                  alt: `gallery-${idx}`,
                  style: {
                    width: "100%",
                    height: "100%",
                    objectFit: "cover",
                    display: "block",
                    transition: "transform 0.2s, filter 0.2s",
                    filter: isLastWithExtra ? "brightness(0.4)" : "none"
                  },
                  loading: "lazy",
                  onMouseEnter: /* @__PURE__ */ __name((e) => {
                    e.target.style.transform = "scale(1.05)";
                    if (!isLastWithExtra) e.target.style.filter = "brightness(0.85)";
                  }, "onMouseEnter"),
                  onMouseLeave: /* @__PURE__ */ __name((e) => {
                    e.target.style.transform = "scale(1)";
                    if (!isLastWithExtra) e.target.style.filter = "none";
                    else e.target.style.filter = "brightness(0.4)";
                  }, "onMouseLeave")
                }
              ),
              isLastWithExtra && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
                position: "absolute",
                top: 0,
                left: 0,
                right: 0,
                bottom: 0,
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                pointerEvents: "none"
              }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { style: {
                color: "#fff",
                fontSize: "2rem",
                fontWeight: 700,
                textShadow: "0 2px 8px rgba(0,0,0,0.6)",
                letterSpacing: "1px"
              }, children: [
                "+",
                extraCount
              ] }) })
            ]
          },
          messages[idx]?.id || idx
        );
      }) })
    ] })
  ] });
});
const Message = React.lazy(() => __vitePreload(() => import("./Message-C6wc4GJi.js"), true ? __vite__mapDeps([250,3,1,4,251,252,253,254,14,15,0,16]) : void 0));
const VirtualMessageList = React.lazy(() => __vitePreload(() => import("./VirtualMessageList-C3qfbspt.js"), true ? __vite__mapDeps([258,1,254]) : void 0));
const MessageInput = React.lazy(() => __vitePreload(() => import("./MessageInput-BCyEfXGC.js"), true ? __vite__mapDeps([259,3,1,4,248,14,15,0,16,260,119,261]) : void 0));
React.lazy(() => __vitePreload(() => import("./UserVideoContainer-BJKkjClY.js"), true ? __vite__mapDeps([262,1]) : void 0));
const VoiceAudioController = React.lazy(() => __vitePreload(() => import("./VoiceAudioController-BynloBmG.js"), true ? __vite__mapDeps([263,1,3,14,15,0,4,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./RichTextEditor-CnydQuQx.js"), true ? __vite__mapDeps([264,1,265,19,16,4,266]) : void 0));
const StickyMessageBanner = React.lazy(() => __vitePreload(() => import("./StickyMessageBanner-BrhaUpuN.js"), true ? __vite__mapDeps([267,1,4]) : void 0));
const LoginPage = React.lazy(() => __vitePreload(() => import("./LoginPage-B5YRkoJw.js"), true ? __vite__mapDeps([268,1,4,269,0,3,14,15,16]) : void 0));
const WelcomeScreen = React.lazy(() => __vitePreload(() => import("./WelcomeScreen-CkaSQ0J1.js"), true ? __vite__mapDeps([270,1,4,33,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./ImageModal-BlJrc8Ul.js"), true ? __vite__mapDeps([271,1]) : void 0));
React.lazy(() => __vitePreload(() => import("./UserProfileModal-nuerxjra.js"), true ? __vite__mapDeps([257,1,4,232,3,14,15,0,16,244]) : void 0));
React.lazy(() => __vitePreload(() => import("./PollCreateModal-C0kTUS7Q.js"), true ? __vite__mapDeps([40,1,4]) : void 0));
React.lazy(() => __vitePreload(() => import("./CodeSnippetModal-C61Oq3Pi.js"), true ? __vite__mapDeps([26,1,4]) : void 0));
React.lazy(() => __vitePreload(() => import("./AvatarCropper-fmvEo3gX.js"), true ? __vite__mapDeps([9,1,10]) : void 0));
React.lazy(() => __vitePreload(() => import("./CryptoChartModal-DVo8Azj1.js"), true ? __vite__mapDeps([5,1,4]) : void 0));
React.lazy(() => __vitePreload(() => import("./CryptoStoreModal-r7SEacpu.js"), true ? __vite__mapDeps([272,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./PremiumStoreModal-B9JTzr57.js"), true ? __vite__mapDeps([41,1,4,42,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./WhiteboardModal-BmKnXb_l.js"), true ? __vite__mapDeps([56,1,4]) : void 0));
React.lazy(() => __vitePreload(() => import("./SoundboardModal-BALiP7O-.js"), true ? __vite__mapDeps([51,1,4]) : void 0));
const KanbanBoard = React.lazy(() => __vitePreload(() => import("./KanbanBoard-BohoWxkS.js"), true ? __vite__mapDeps([273,1,19,16,254,4,3,14,15,0]) : void 0));
React.lazy(() => __vitePreload(() => import("./SummaryModal-BUIQMbK3.js"), true ? __vite__mapDeps([255,1,4]) : void 0));
React.lazy(() => __vitePreload(() => import("./MessageTemplateModal-CnWeDgQg.js"), true ? __vite__mapDeps([248,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./CinemaModal-BvqRSqV8.js"), true ? __vite__mapDeps([2,3,1,4]) : void 0));
React.lazy(() => __vitePreload(() => import("./StickerPicker-D4KgwPIx.js"), true ? __vite__mapDeps([7,1]) : void 0));
React.lazy(() => __vitePreload(() => import("./GifPicker-DRHla4ZE.js"), true ? __vite__mapDeps([6,1]) : void 0));
React.lazy(() => __vitePreload(() => import("./DJModal-CAGaD54L.js"), true ? __vite__mapDeps([31,3,1,4]) : void 0));
React.lazy(() => __vitePreload(() => import("./ThemeStoreModal-CduloDLv.js"), true ? __vite__mapDeps([256,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./EncryptionKeyModal-C_s13e4y.js"), true ? __vite__mapDeps([34,1,4]) : void 0));
React.lazy(() => __vitePreload(() => import("./DownloadModal-BmcJJ7ja.js"), true ? __vite__mapDeps([33,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./ServerSettingsModal-DMBbz04j.js"), true ? __vite__mapDeps([48,1,4,49,50,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./CreateGroupModal-D_BiSitZ.js"), true ? __vite__mapDeps([29,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./AdminAnalyticsPanel-CeHNI74W.js"), true ? __vite__mapDeps([18,1,4,19,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./AdminPanelModal-CprLW31R.js"), true ? __vite__mapDeps([20,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./WebhooksPanel-boei-7OV.js"), true ? __vite__mapDeps([54,1,16,3,14,15,0,4,55]) : void 0));
React.lazy(() => __vitePreload(() => import("./VanityURLManager-DYHHPB97.js"), true ? __vite__mapDeps([50,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./AutoModerationDashboard-Db2Mj8kJ.js"), true ? __vite__mapDeps([22,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./AutoModerationPanel-DuXU2zwV.js"), true ? __vite__mapDeps([274,1,4,3,14,15,0,16,275]) : void 0));
React.lazy(() => __vitePreload(() => import("./RaidProtectionPanel-DhzCOH3b.js"), true ? __vite__mapDeps([43,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./ReportSystemPanel-C0VgbCF_.js"), true ? __vite__mapDeps([46,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./AuditLogPanel-DKJ2GZ5a.js"), true ? __vite__mapDeps([23,1,4]) : void 0));
React.lazy(() => __vitePreload(() => import("./UserWarningsPanel-BPP8cjTU.js"), true ? __vite__mapDeps([53,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./BookmarkPanel-kyNJY0U5.js"), true ? __vite__mapDeps([24,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./ReadLaterPanel-Bv7aDtH4.js"), true ? __vite__mapDeps([44,1,4,45]) : void 0));
React.lazy(() => __vitePreload(() => import("./ChannelPermissionsPanel-EZYXCMYg.js"), true ? __vite__mapDeps([25,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./MessageThreadsPanel-DpAuXz70.js"), true ? __vite__mapDeps([276,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./ModeratorNotesPanel-dqGeUu3u.js"), true ? __vite__mapDeps([277,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./ServerRolesPanel-BisIj6K9.js"), true ? __vite__mapDeps([278,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./NotificationPreferencesPanel-CaVDUB-m.js"), true ? __vite__mapDeps([279,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./MessageOCRPanel-B8_VVSnl.js"), true ? __vite__mapDeps([280,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./MassActionsPanel-DWwwNS2M.js"), true ? __vite__mapDeps([281,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./TimeoutMutePanel-BrbMWxwY.js"), true ? __vite__mapDeps([282,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./ServerThemesPanel-BDBsAMR6.js"), true ? __vite__mapDeps([283,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./KeywordMutesPanel-Ckz7PqjQ.js"), true ? __vite__mapDeps([284,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./WelcomeTemplatesPanel-B0HoOvPt.js"), true ? __vite__mapDeps([285,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./StickyMessagesPanel-Pvubzjnz.js"), true ? __vite__mapDeps([286,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./MessageTemplatesPanel-BFnjdJJ-.js"), true ? __vite__mapDeps([287,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./MessageExportPanel-CQF93cMI.js"), true ? __vite__mapDeps([288,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./ArchivedRoomsPanel-D9aIjFxJ.js"), true ? __vite__mapDeps([289,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./SlowModePanel-LIKu6G7T.js"), true ? __vite__mapDeps([290,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./EmojiManagementPanel-DXmZXZHM.js"), true ? __vite__mapDeps([291,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./MentionsInboxPanel-DZelkw8n.js"), true ? __vite__mapDeps([36,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./CustomStatusModal-BWrL755S.js"), true ? __vite__mapDeps([30,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./ReactionAnalyticsPanel-BCFjvPIf.js"), true ? __vite__mapDeps([78,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./LinkClickTrackingPanel-6FH16-Tn.js"), true ? __vite__mapDeps([72,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./JoinLeaveLogsPanel-Dtt005vw.js"), true ? __vite__mapDeps([71,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./UserActivityPanel-CD0qRsam.js"), true ? __vite__mapDeps([86,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./NicknameHistoryPanel-B-Wz69Sw.js"), true ? __vite__mapDeps([75,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./FieldChangeTrackingPanel--c_3LXa0.js"), true ? __vite__mapDeps([65,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./InviteAnalyticsPanel-BBESM7ym.js"), true ? __vite__mapDeps([69,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./ContentScannerPanel-Jxgf5LVl.js"), true ? __vite__mapDeps([60,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./EphemeralMessagesPanel-C8rcuC5s.js"), true ? __vite__mapDeps([64,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./TopicHistoryPanel-C2MBkrQu.js"), true ? __vite__mapDeps([84,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./DraftsPanel-C-IbIfeO.js"), true ? __vite__mapDeps([62,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./ServerNicknamesPanel-GPlrKIyh.js"), true ? __vite__mapDeps([82,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./ServerBoostPanel-CEJjoMfa.js"), true ? __vite__mapDeps([81,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./RoomWebhooksPanel-B_fsIFRY.js"), true ? __vite__mapDeps([80,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./OAuthAppsPanel-Bu2YklTp.js"), true ? __vite__mapDeps([76,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./VanityURLPanel-BoWpWS4Q.js"), true ? __vite__mapDeps([292,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./AutoRespondersPanel-Dtllx_ff.js"), true ? __vite__mapDeps([58,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./SessionManagementPanel-CMnZlXbZ.js"), true ? __vite__mapDeps([83,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./GDPRExportPanel-qSc0bx78.js"), true ? __vite__mapDeps([66,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./DataRetentionPanel-Cbh_IIND.js"), true ? __vite__mapDeps([61,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./TwoFactorSetupWizard-CK1qKlxA.js"), true ? __vite__mapDeps([85,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./EnhancedPollsPanel-BJ8sk77f.js"), true ? __vite__mapDeps([63,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./VoiceTranscriptsPanel-CTXnGgYn.js"), true ? __vite__mapDeps([87,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./PaymentPanel-By60yAWw.js"), true ? __vite__mapDeps([39,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./StoreModal-Di58Ahiv.js"), true ? __vite__mapDeps([52,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./DailyRewardsModal-DQvOn490.js"), true ? __vite__mapDeps([32,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./APIUsagePanel-BhDcZw3C.js"), true ? __vite__mapDeps([21,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./ExportJobsPanel-BObQVuFH.js"), true ? __vite__mapDeps([35,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./ScheduledAnnouncementsPanel-CyYd5qX7.js"), true ? __vite__mapDeps([47,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./InviteExportPanel-BeoQqWK9.js"), true ? __vite__mapDeps([70,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./AdvancedSearchPanel-CWVX6Gip.js"), true ? __vite__mapDeps([57,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./GrowthMetricsPanel-BSJUjD9b.js"), true ? __vite__mapDeps([67,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./LinkPreviewRenderer-C2LxW31e.js"), true ? __vite__mapDeps([73,1,4]) : void 0));
React.lazy(() => __vitePreload(() => import("./InventoryPanel-B2sfU6fc.js"), true ? __vite__mapDeps([68,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./WaitlistPanel-B1K8-3rl.js"), true ? __vite__mapDeps([88,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./ReferralRewardsPanel-BbCOHbxH.js"), true ? __vite__mapDeps([79,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./VerifyEmailPage-CPqjRClY.js"), true ? __vite__mapDeps([293,1,4,14]) : void 0));
React.lazy(() => __vitePreload(() => import("./ForgotPasswordPage-Dvi04eBr.js"), true ? __vite__mapDeps([294,1,4,269,14]) : void 0));
React.lazy(() => __vitePreload(() => import("./ResetPasswordPage-C9pWHncF.js"), true ? __vite__mapDeps([295,1,4,14]) : void 0));
React.lazy(() => __vitePreload(() => import("./TwoFactorLoginPage-DpZIJ5dO.js"), true ? __vite__mapDeps([296,1,14,4,3,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./TwoFactorSetup-BoCr7WMC.js"), true ? __vite__mapDeps([297,1,3,14,15,0,4,16,298]) : void 0));
React.lazy(() => __vitePreload(() => import("./TwoFactorLogin-Dzbvao0Q.js"), true ? __vite__mapDeps([299,1,300]) : void 0));
const VanityInviteScreen = React.lazy(() => __vitePreload(() => import("./VanityInviteScreen-B6hcNt_v.js"), true ? __vite__mapDeps([301,1,16]) : void 0));
const InviteCodeScreen = React.lazy(() => __vitePreload(() => import("./InviteCodeScreen-W1qOF0la.js"), true ? __vite__mapDeps([302,1,3,14,15,0,4,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./EmailVerification-CVo9AUBw.js"), true ? __vite__mapDeps([303,1,14,304]) : void 0));
React.lazy(() => __vitePreload(() => import("./MobileNav-C54fV4k3.js"), true ? __vite__mapDeps([305,1,306]) : void 0));
React.lazy(() => __vitePreload(() => import("./SwipeActions-CAWSugvZ.js"), true ? __vite__mapDeps([307,1,308]) : void 0));
React.lazy(() => __vitePreload(() => import("./VoiceMessage-D4-GrYKo.js"), true ? __vite__mapDeps([309,1,3,14,15,0,4,16,310]) : void 0));
const FriendsTab = React.lazy(() => __vitePreload(() => import("./FriendsTab-m19L3Oau.js"), true ? __vite__mapDeps([311,1,4,251,3,14,15,0,16]) : void 0));
const RoomList = React.lazy(() => __vitePreload(() => import("./RoomList-BtB_aped.js"), true ? __vite__mapDeps([312,1,4,0,313,201,3,14,15,16,225,260,245,207,50,49,187,251]) : void 0));
React.lazy(() => __vitePreload(() => import("./UserProfilePanel-D7peylHI.js"), true ? __vite__mapDeps([8,1,9,10,11,12,13,3,14,15,0,4,16,17]) : void 0));
const VoiceChatPanel = React.lazy(() => __vitePreload(() => import("./VoiceChatPanel-Dov42lJK.js"), true ? __vite__mapDeps([314,1,315,4,167,16,3,14,15,0,168,316]) : void 0));
const ChatUserList = React.lazy(() => __vitePreload(() => import("./ChatUserList-CltnwdLS.js"), true ? __vite__mapDeps([317,1,4,14]) : void 0));
React.lazy(() => __vitePreload(() => import("./PinnedMessages-Bg4Z9VnI.js"), true ? __vite__mapDeps([249,1,250,3,4,251,252,253,254,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./FloatingVoiceIsland-CK9oLub8.js"), true ? __vite__mapDeps([318,1,316,16,319]) : void 0));
React.lazy(() => __vitePreload(() => import("./CinemaPlayer-CIM5njaf.js"), true ? __vite__mapDeps([320,3,1,4,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./ConnectionsPanel-DzEFgQYY.js"), true ? __vite__mapDeps([27,1,4,3,14,15,0,16,28]) : void 0));
React.lazy(() => __vitePreload(() => import("./PasswordSetupModal-BTysGNpv.js"), true ? __vite__mapDeps([37,1,4,3,14,15,0,16,38]) : void 0));
const NotificationDropdown = React.lazy(() => __vitePreload(() => import("./NotificationDropdown-CDYtYqhu.js"), true ? __vite__mapDeps([321,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./ReactionStatsPanel-CRHDWfsY.js"), true ? __vite__mapDeps([322,1,4,3,14,15,0,16,323]) : void 0));
React.lazy(() => __vitePreload(() => import("./ServerHealthPanel-CGgmPc-y.js"), true ? __vite__mapDeps([324,1,4,3,14,15,0,16,325]) : void 0));
React.lazy(() => __vitePreload(() => import("./ChannelAnalyticsPanel-PPJhsZeU.js"), true ? __vite__mapDeps([326,1,4,3,14,15,0,16,327]) : void 0));
React.lazy(() => __vitePreload(() => import("./SmartSuggestionsPanel-ByLDopGD.js"), true ? __vite__mapDeps([328,1,4,3,14,15,0,16,329]) : void 0));
React.lazy(() => __vitePreload(() => import("./UserPresenceInsightsPanel-D-A48kV2.js"), true ? __vite__mapDeps([330,1,4,3,14,15,0,16,331]) : void 0));
React.lazy(() => __vitePreload(() => import("./UserFooter-CnbZqgnZ.js").then((n) => n.a), true ? __vite__mapDeps([313,1,4]) : void 0));
const UserContextMenu = React.lazy(() => __vitePreload(() => import("./UserContextMenu-D-FXCTVo.js"), true ? __vite__mapDeps([315,1,4]) : void 0));
React.lazy(() => __vitePreload(() => import("./MiniGamesPanel-C4JjnWMa.js"), true ? __vite__mapDeps([74,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./ProjectCollaborationPanel-DPbhuILk.js"), true ? __vite__mapDeps([77,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./AvatarStudioPanel-BrYOZdmz.js"), true ? __vite__mapDeps([59,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./ImageLightbox-Bd9djm77.js"), true ? __vite__mapDeps([247,1,4]) : void 0));
React.lazy(() => __vitePreload(() => import("./ChannelAboutPanel-C6PgjMXG.js"), true ? __vite__mapDeps([332,1,4]) : void 0));
React.lazy(() => __vitePreload(() => import("./MessageSchedulePicker-CXKNQyJv.js"), true ? __vite__mapDeps([333,1,4]) : void 0));
React.lazy(() => __vitePreload(() => import("./UserSettingsModal-d0UikIEa.js"), true ? __vite__mapDeps([165,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./KeyboardShortcutsModal-D5GaGFa_.js"), true ? __vite__mapDeps([123,1,4]) : void 0));
React.lazy(() => __vitePreload(() => import("./CommandPalette-DEX-h-w2.js"), true ? __vite__mapDeps([106,1,4,3,14,15,0,16,107]) : void 0));
React.lazy(() => __vitePreload(() => import("./ServerDiscoveryPage-hE-IdVfX.js"), true ? __vite__mapDeps([153,1,3,14,15,0,4,16,154]) : void 0));
React.lazy(() => __vitePreload(() => import("./AppearanceSettingsPanel-Bxj7cLbI.js"), true ? __vite__mapDeps([92,1,16,3,14,15,0,4,93]) : void 0));
React.lazy(() => __vitePreload(() => import("./LanguageSelector-O70Km-tX.js"), true ? __vite__mapDeps([124,1,0,3,14,15,4,16,125]) : void 0));
React.lazy(() => __vitePreload(() => import("./ChangelogPanel-Ch212w6j.js"), true ? __vite__mapDeps([104,1,4,105]) : void 0));
React.lazy(() => __vitePreload(() => import("./LogoutModal-B4uPtFZv.js"), true ? __vite__mapDeps([11,1,12]) : void 0));
React.lazy(() => __vitePreload(() => import("./NotificationSoundSettings-DWpAJxaO.js"), true ? __vite__mapDeps([134,1,4]) : void 0));
React.lazy(() => __vitePreload(() => import("./QuickSwitcher-XwmF63EV.js"), true ? __vite__mapDeps([139,1,4,140]) : void 0));
React.lazy(() => __vitePreload(() => import("./LoginHistory-C2fgibfc.js"), true ? __vite__mapDeps([129,1,4]) : void 0));
React.lazy(() => __vitePreload(() => import("./SecuritySettingsPanel-DVstCrkd.js"), true ? __vite__mapDeps([147,1,16,3,14,15,0,4,148]) : void 0));
React.lazy(() => __vitePreload(() => import("./PrivacySettingsPanel-CfZaaSFf.js"), true ? __vite__mapDeps([136,1,16,3,14,15,0,4,137]) : void 0));
React.lazy(() => __vitePreload(() => import("./AccountDeletionModal-Bw4ik5gg.js"), true ? __vite__mapDeps([89,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./BlockListPanel-fyPAXRqO.js"), true ? __vite__mapDeps([100,1,16,3,14,15,0,4,101]) : void 0));
React.lazy(() => __vitePreload(() => import("./E2EESettingsPanel-Bu2xjuVt.js"), true ? __vite__mapDeps([112,3,1,4,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./ThreadView-709GrGDB.js"), true ? __vite__mapDeps([161,1,4]) : void 0));
React.lazy(() => __vitePreload(() => import("./ScheduledMessagesPanel-D2KwFkyN.js"), true ? __vite__mapDeps([145,1,3,14,15,0,4,16,146]) : void 0));
React.lazy(() => __vitePreload(() => import("./ReminderPanel-Dkvw-jRV.js"), true ? __vite__mapDeps([143,1,16,3,14,15,0,4,144]) : void 0));
React.lazy(() => __vitePreload(() => import("./ForumPanel-Cg4YKtbe.js"), true ? __vite__mapDeps([114,1,3,14,15,0,4,16,115]) : void 0));
React.lazy(() => __vitePreload(() => import("./StageChannelPanel-B0CEZ-9H.js"), true ? __vite__mapDeps([157,1,3,14,15,0,4,16,158]) : void 0));
React.lazy(() => __vitePreload(() => import("./VideoCallModal-BCiQHGBX.js"), true ? __vite__mapDeps([166,1,4]) : void 0));
React.lazy(() => __vitePreload(() => import("./VoiceSettingsPanel-C5MXlqa8.js"), true ? __vite__mapDeps([167,1,4,16,3,14,15,0,168]) : void 0));
React.lazy(() => __vitePreload(() => import("./MessageSearchPanel-BgdC1osD.js"), true ? __vite__mapDeps([130,1,4,3,14,15,0,16,131]) : void 0));
React.lazy(() => __vitePreload(() => import("./index-CKlHPrBa.js"), true ? __vite__mapDeps([169,1,4,3,14,15,0,16,170]) : void 0));
React.lazy(() => __vitePreload(() => import("./AutoRolesPanel-B28K5HKh.js"), true ? __vite__mapDeps([94,1,16,3,14,15,0,4,95]) : void 0));
React.lazy(() => __vitePreload(() => import("./ReactionRolesPanel-D9_ZU0aX.js"), true ? __vite__mapDeps([141,1,16,3,14,15,0,4,142]) : void 0));
React.lazy(() => __vitePreload(() => import("./WelcomeMessagesPanel-DRgKL7i_.js"), true ? __vite__mapDeps([172,1,16,3,14,15,0,4,173]) : void 0));
React.lazy(() => __vitePreload(() => import("./EventCalendar-CqWzHANE.js"), true ? __vite__mapDeps([113,1,4]) : void 0));
React.lazy(() => __vitePreload(() => import("./GiveawayPanel-WTAKnx-f.js"), true ? __vite__mapDeps([116,1,16,3,14,15,0,4,117]) : void 0));
React.lazy(() => __vitePreload(() => import("./TicketSystemPanel-BPfHSwkW.js"), true ? __vite__mapDeps([162,1,16,3,14,15,0,4,163]) : void 0));
React.lazy(() => __vitePreload(() => import("./StarboardPanel-BIXtfAjI.js"), true ? __vite__mapDeps([159,1,16,3,14,15,0,4,160]) : void 0));
React.lazy(() => __vitePreload(() => import("./ServerBackupPanel-CJnjsjcp.js"), true ? __vite__mapDeps([149,1,16,3,14,15,0,4,150]) : void 0));
React.lazy(() => __vitePreload(() => import("./BanAppealsPanel-BmWzFlW5.js"), true ? __vite__mapDeps([96,1,4,97]) : void 0));
React.lazy(() => __vitePreload(() => import("./CustomCommandsPanel-HP4Ptsd_.js"), true ? __vite__mapDeps([108,1,16,3,14,15,0,4,109]) : void 0));
React.lazy(() => __vitePreload(() => import("./LevelingSystemPanel-D_GpIthE.js"), true ? __vite__mapDeps([126,1,16,3,14,15,0,4,127]) : void 0));
React.lazy(() => __vitePreload(() => import("./LiveStreamPanel-Bs4ri7Ey.js"), true ? __vite__mapDeps([128,1,4]) : void 0));
React.lazy(() => __vitePreload(() => import("./AchievementsPanel-B8dUoq52.js"), true ? __vite__mapDeps([90,1,3,14,15,0,4,16,91]) : void 0));
React.lazy(() => __vitePreload(() => import("./BirthdaySystemPanel-2i_s6nJU.js"), true ? __vite__mapDeps([98,1,16,3,14,15,0,4,99]) : void 0));
React.lazy(() => __vitePreload(() => import("./PremiumModal-CFE1Dd0q.js"), true ? __vite__mapDeps([135,1,3,14,15,0,4,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./MusicPlayer-DGaj7k61.js"), true ? __vite__mapDeps([132,1,4,3,14,15,0,16,133]) : void 0));
React.lazy(() => __vitePreload(() => import("./BotMarketplace-DecUc5NP.js"), true ? __vite__mapDeps([102,1,3,14,15,0,4,16,103]) : void 0));
React.lazy(() => __vitePreload(() => import("./ProfileCustomization-BJfYgMpH.js"), true ? __vite__mapDeps([138,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./IntegrationHubPanel-DvU2UgBp.js"), true ? __vite__mapDeps([121,1,4,16,3,14,15,0,122]) : void 0));
React.lazy(() => __vitePreload(() => import("./TournamentSystem-DSbIJJ6b.js"), true ? __vite__mapDeps([164,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./HighlightsPanel-cZ0rYJ9P.js"), true ? __vite__mapDeps([118,1,16,119,3,14,15,0,4,120]) : void 0));
React.lazy(() => __vitePreload(() => import("./CustomEmbedPanel-B2YjOp0-.js"), true ? __vite__mapDeps([110,1,16,3,14,15,0,4,111]) : void 0));
React.lazy(() => __vitePreload(() => import("./SpotifyIntegrationPanel-Bx1vw9y7.js"), true ? __vite__mapDeps([155,1,4,156]) : void 0));
React.lazy(() => __vitePreload(() => import("./ServerClonePanel-BD8f7Ard.js"), true ? __vite__mapDeps([151,1,4,3,14,15,0,16,152]) : void 0));
React.lazy(() => __vitePreload(() => import("./WeeklyChallengesPanel-B-Lahrgc.js"), true ? __vite__mapDeps([171,1,4]) : void 0));
React.lazy(() => __vitePreload(() => import("./ModeratorTools-CH2elA1l.js"), true ? __vite__mapDeps([207,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./AIModerationPanel-vfmBCrZG.js"), true ? __vite__mapDeps([176,1,4,13,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./SpamDetectionPanel-DPIcJaa7.js"), true ? __vite__mapDeps([235,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./AuditLogsPanel-CtPAYxni.js"), true ? __vite__mapDeps([180,1,16,3,14,15,0,4,181]) : void 0));
React.lazy(() => __vitePreload(() => import("./BanHistoryPanel-D1pPc2TA.js"), true ? __vite__mapDeps([182,1,4,16,183]) : void 0));
React.lazy(() => __vitePreload(() => import("./ModerationLogsPanel-D51Q_nGQ.js"), true ? __vite__mapDeps([205,1,4,16,3,14,15,0,206]) : void 0));
React.lazy(() => __vitePreload(() => import("./RaidProtectionDashboard-COiZkN6y.js"), true ? __vite__mapDeps([334,1,4,3,14,15,0,16,335]) : void 0));
React.lazy(() => __vitePreload(() => import("./SecurityAlertsPanel-BW_fsW-w.js"), true ? __vite__mapDeps([227,1,4,3,14,15,0,16,228]) : void 0));
React.lazy(() => __vitePreload(() => import("./BookmarksPanel-Cc20Q8JC.js"), true ? __vite__mapDeps([336,1,4]) : void 0));
React.lazy(() => __vitePreload(() => import("./GIFPickerPanel-DISPZZsY.js"), true ? __vite__mapDeps([196,1,4,197]) : void 0));
React.lazy(() => __vitePreload(() => import("./PollCreator-DXbc-BVW.js"), true ? __vite__mapDeps([212,1,13,3,14,15,0,4,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./StickersPanel-BVRtOuAz.js"), true ? __vite__mapDeps([237,1,3,14,15,0,4,16,238]) : void 0));
React.lazy(() => __vitePreload(() => import("./SavedMessagesModal-CIhVFKdF.js"), true ? __vite__mapDeps([225,1,4]) : void 0));
React.lazy(() => __vitePreload(() => import("./NotificationsCenter-DHIfAzy6.js"), true ? __vite__mapDeps([210,1,4,3,14,15,0,16,211]) : void 0));
React.lazy(() => __vitePreload(() => import("./MessageSummaryPanel-BTf00WRi.js"), true ? __vite__mapDeps([203,1,4,119,204]) : void 0));
React.lazy(() => __vitePreload(() => import("./TranslationPanel-0kP4NZJX.js"), true ? __vite__mapDeps([242,1,16,3,14,15,0,4,243]) : void 0));
React.lazy(() => __vitePreload(() => import("./ChannelSettingsModal-DwVgGmfD.js"), true ? __vite__mapDeps([187,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./InviteModal-DPRjeSOT.js"), true ? __vite__mapDeps([201,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./ServerTemplates-BM2E9hRL.js"), true ? __vite__mapDeps([230,1,4,3,14,15,0,16,231]) : void 0));
React.lazy(() => __vitePreload(() => import("./ServerAnalyticsDashboard-B7OUNCl_.js"), true ? __vite__mapDeps([229,1,4]) : void 0));
React.lazy(() => __vitePreload(() => import("./RolesManager-i2vrls0B.js"), true ? __vite__mapDeps([223,1,3,14,15,0,4,16,224]) : void 0));
React.lazy(() => __vitePreload(() => import("./WelcomeScreenEditor-BjqJuHeB.js"), true ? __vite__mapDeps([246,1,4]) : void 0));
React.lazy(() => __vitePreload(() => import("./CommunitySettingsPanel-BGghaQk8.js"), true ? __vite__mapDeps([191,1,4,3,14,15,0,16,192]) : void 0));
React.lazy(() => __vitePreload(() => import("./InviteLinkManager-wWUK3P0I.js"), true ? __vite__mapDeps([200,1,4]) : void 0));
React.lazy(() => __vitePreload(() => import("./BotBuilder-DGAydBnn.js"), true ? __vite__mapDeps([184,1,4,13,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./BotDeveloperPortal-B00QB35w.js"), true ? __vite__mapDeps([185,1,4,3,14,15,0,16,186]) : void 0));
React.lazy(() => __vitePreload(() => import("./WebhookManager-Bm_F0_iZ.js"), true ? __vite__mapDeps([245,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./APIKeysPanel-CPNZkykh.js"), true ? __vite__mapDeps([177,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./SlashCommandsPanel-DflqoU2n.js"), true ? __vite__mapDeps([233,1,4,234]) : void 0));
React.lazy(() => __vitePreload(() => import("./CodeRunnerPanel-D6xXG7GF.js"), true ? __vite__mapDeps([188,1,4,16,189]) : void 0));
React.lazy(() => __vitePreload(() => import("./ProfileCard-C32OLjCf.js"), true ? __vite__mapDeps([217,1,3,14,15,0,4,16,218]) : void 0));
React.lazy(() => __vitePreload(() => import("./UserNotesModal-CGi7VG1X.js"), true ? __vite__mapDeps([244,1,4]) : void 0));
React.lazy(() => __vitePreload(() => import("./StatusPicker-DD16Tr_4.js"), true ? __vite__mapDeps([236,1,4]) : void 0));
React.lazy(() => __vitePreload(() => import("./MutualsPanel-_u7esGII.js"), true ? __vite__mapDeps([208,1,4,16,209]) : void 0));
React.lazy(() => __vitePreload(() => import("./ProfileShowcasePanel-U803Ucns.js"), true ? __vite__mapDeps([219,1,4,16,3,14,15,0,220]) : void 0));
React.lazy(() => __vitePreload(() => import("./SessionManagerModal-DbQklqjF.js"), true ? __vite__mapDeps([232,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./CoinStoreModal-BXmYuior.js"), true ? __vite__mapDeps([42,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./PremiumManagementPanel-BVE-3EVU.js"), true ? __vite__mapDeps([213,1,16,3,14,15,0,4,214]) : void 0));
React.lazy(() => __vitePreload(() => import("./SubscriptionManager-DDD3tnnb.js"), true ? __vite__mapDeps([239,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./GiftPremiumPanel-l_N0_Kh-.js"), true ? __vite__mapDeps([198,1,4,199]) : void 0));
React.lazy(() => __vitePreload(() => import("./PremiumMarketplace-S1HoIffv.js"), true ? __vite__mapDeps([215,1,13,3,14,15,0,4,16,216]) : void 0));
React.lazy(() => __vitePreload(() => import("./ThemeMarketplace-DGpr98_G.js"), true ? __vite__mapDeps([240,1,13,3,14,15,0,4,16,241]) : void 0));
React.lazy(() => __vitePreload(() => import("./AIChatbotPanel-v3Gxxsz6.js"), true ? __vite__mapDeps([174,1,4,3,14,15,0,16,175]) : void 0));
React.lazy(() => __vitePreload(() => import("./CollaborativeCodeEditor-BOj76Z7l.js"), true ? __vite__mapDeps([190,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./ScreenShareModal-CYX7LCLg.js"), true ? __vite__mapDeps([226,1,4]) : void 0));
React.lazy(() => __vitePreload(() => import("./LiveStreamModal-BwuP4i75.js"), true ? __vite__mapDeps([202,1,4,3,14,15,0,16]) : void 0));
React.lazy(() => __vitePreload(() => import("./AdvancedAnalyticsDashboard-D9W-7shq.js"), true ? __vite__mapDeps([178,1,4,3,14,15,0,16,179]) : void 0));
React.lazy(() => __vitePreload(() => import("./FileManagerPanel-6a83_Su6.js"), true ? __vite__mapDeps([195,1,4]) : void 0));
React.lazy(() => __vitePreload(() => import("./ReportsPanel-Df1R0ORo.js"), true ? __vite__mapDeps([221,1,3,14,15,0,4,16,222]) : void 0));
React.lazy(() => __vitePreload(() => import("./ErrorReportingPanel-8oIX-fRe.js"), true ? __vite__mapDeps([193,1,3,14,15,0,4,16,194]) : void 0));
const styles$7 = {
  // âœ¨ GLASSMORPHISM - ANA PENCERE
  mainContainer: {
    display: "flex",
    width: "100%",
    height: "100dvh",
    backgroundColor: "#1E1F22",
    // Deep dark base
    backgroundImage: "radial-gradient(circle at 50% 10%, rgba(88, 101, 242, 0.05) 0%, transparent 40%)",
    // Subtle glow
    color: "white",
    overflow: "hidden",
    fontFamily: "'Inter', sans-serif"
  },
  // 2. YERLEÅžÄ°M DÃœZENÄ°
  chatLayout: {
    display: "flex",
    width: "100%",
    height: "100%",
    overflow: "hidden"
  },
  // 3. SOL MENÃœ (Sidebar)
  sidebarWrapper: {
    width: "312px",
    backgroundColor: "rgba(30, 31, 34, 0.6)",
    backdropFilter: "blur(10px)",
    display: "flex",
    flexDirection: "row",
    flexShrink: 0,
    height: "100%",
    borderRight: "1px solid rgba(255,255,255,0.05)"
  },
  // 4. SAÄž TARAFTAKÄ° ANA Ä°Ã‡ERÄ°K
  mainContent: {
    flex: 1,
    display: "flex",
    minWidth: 0,
    position: "relative",
    height: "100%",
    overflow: "hidden"
  },
  // 5. CHAT ALANI (BaÅŸlÄ±k + Mesajlar + Input)
  chatArea: {
    flex: 1,
    display: "flex",
    flexDirection: "column",
    backgroundColor: "transparent",
    minWidth: 0,
    height: "100%",
    overflow: "hidden",
    position: "relative"
  },
  chatHeader: {
    height: "54px",
    minHeight: "54px",
    borderBottom: "1px solid rgba(255,255,255,0.08)",
    display: "flex",
    alignItems: "center",
    padding: "0 20px",
    flexShrink: 0,
    backgroundColor: "rgba(20, 21, 24, 0.7)",
    backdropFilter: "blur(15px)",
    boxShadow: "0 1px 3px rgba(0,0,0,0.2)",
    zIndex: 10
  },
  // ðŸ”¥ DÃœZELTÄ°LEN MESAJ KUTUSU
  messageBox: {
    flex: 1,
    overflowY: "auto",
    padding: "20px 0",
    display: "flex",
    flexDirection: "column",
    gap: "4px",
    scrollBehavior: "smooth",
    minHeight: 0
  },
  // 7. INPUT ALANI (En altta sabit)
  inputContainer: {
    padding: "0 20px 24px 20px",
    backgroundColor: "transparent",
    position: "relative",
    flexShrink: 0,
    minHeight: "auto",
    zIndex: 20
  },
  // ... DiÄŸer stiller (Modernize)
  chatUserListPanel: {
    width: "240px",
    backgroundColor: "rgba(30, 31, 34, 0.6)",
    borderLeft: "1px solid rgba(255,255,255,0.08)",
    flexShrink: 0,
    height: "100%",
    backdropFilter: "blur(10px)"
  },
  mobileSidebar: { position: "fixed", zIndex: 100, top: 0, bottom: 0, left: 0, width: "85vw", maxWidth: "350px", boxShadow: "5px 0 15px rgba(0,0,0,0.5)", display: "flex", flexDirection: "column" },
  mobileRightSidebar: { position: "fixed", zIndex: 100, top: 0, bottom: 0, right: 0, width: "85vw", maxWidth: "300px", boxShadow: "-5px 0 15px rgba(0,0,0,0.5)", display: "flex", flexDirection: "column" },
  // ðŸ”¥ MOBÄ°L OVERLAY - Sidebar aÃ§Ä±ldÄ±ÄŸÄ±nda arka planÄ± karartÄ±r ve tÄ±klanabilir yapar
  mobileOverlay: {
    position: "fixed",
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    backgroundColor: "rgba(0, 0, 0, 0.6)",
    zIndex: 99,
    // Sidebar'Ä±n altÄ±nda
    backdropFilter: "blur(3px)"
  },
  mobileMenuButton: { background: "none", border: "none", color: "white", fontSize: "1.5em", marginRight: "10px", cursor: "pointer", padding: "6px", display: "flex", alignItems: "center", transition: "all 0.2s" },
  iconButton: {
    background: "none",
    border: "none",
    color: "#b9bbbe",
    fontSize: "1.3em",
    cursor: "pointer",
    padding: "6px",
    display: "flex",
    alignItems: "center",
    borderRadius: "50%",
    transition: "all 0.2s",
    ":hover": { backgroundColor: "rgba(255,255,255,0.1)", color: "#fff" }
  },
  systemMessage: { color: "#949ba4", textAlign: "center", fontSize: "0.85em", margin: "10px 0", fontStyle: "italic" },
  searchForm: {
    position: "relative",
    display: "flex",
    alignItems: "center",
    backgroundColor: "rgba(0,0,0,0.2)",
    borderRadius: "4px",
    padding: "0 8px",
    height: "32px",
    marginRight: "8px",
    border: "1px solid rgba(255,255,255,0.05)"
  },
  searchInput: { backgroundColor: "transparent", border: "none", color: "#dcddde", fontSize: "0.9em", width: "140px", outline: "none" },
  searchIcon: { color: "#949ba4", fontSize: "0.8em", cursor: "pointer" },
  connectionPillOnline: { marginLeft: "10px", padding: "4px 8px", borderRadius: "999px", backgroundColor: "rgba(59, 165, 93, 0.2)", border: "1px solid #3ba55d", color: "#3ba55d", fontSize: "0.75em", fontWeight: 700 },
  connectionPillOffline: { marginLeft: "10px", padding: "4px 8px", borderRadius: "999px", backgroundColor: "rgba(218, 55, 60, 0.2)", border: "1px solid #da373c", color: "#da373c", fontSize: "0.75em", fontWeight: 700 },
  // ðŸ”¥ MOBÄ°L KENAR Ã‡UBUÄžU HEADER STÄ°LÄ°
  mobileSidebarHeader: {
    display: "flex",
    alignItems: "center",
    justifyContent: "space-between",
    padding: "10px 15px",
    backgroundColor: "#202225",
    borderBottom: "1px solid #111214",
    minHeight: "54px",
    flexShrink: 0
  },
  closeSidebarButton: {
    background: "none",
    border: "none",
    color: "#b9bbbe",
    fontSize: "22px",
    cursor: "pointer",
    padding: "8px",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    borderRadius: "50%",
    transition: "background 0.2s, color 0.2s"
  }
};
let dialogContainer = null;
function confirmDialog(options) {
  return new Promise((resolve) => {
    const config = typeof options === "string" ? { message: options } : { ...options };
    const {
      title = "Emin misiniz?",
      message = "Bu iÅŸlemi gerÃ§ekleÅŸtirmek istediÄŸinizden emin misiniz?",
      confirmText = "Evet",
      cancelText = "VazgeÃ§",
      type = "warning",
      // 'warning', 'danger', 'info'
      details = null
    } = config;
    if (!dialogContainer) {
      dialogContainer = document.createElement("div");
      dialogContainer.id = "confirm-dialog-root";
      document.body.appendChild(dialogContainer);
    }
    const root2 = clientExports.createRoot(dialogContainer);
    const cleanup = /* @__PURE__ */ __name((result) => {
      root2.unmount();
      resolve(result);
    }, "cleanup");
    const typeConfig = {
      warning: {
        icon: /* @__PURE__ */ jsxRuntimeExports.jsx(FaExclamationTriangle, {}),
        color: "#f59e0b",
        gradient: "linear-gradient(135deg, #f59e0b 0%, #d97706 100%)",
        btnColor: "#f59e0b"
      },
      danger: {
        icon: /* @__PURE__ */ jsxRuntimeExports.jsx(FaTrash, {}),
        color: "#ef4444",
        gradient: "linear-gradient(135deg, #ef4444 0%, #dc2626 100%)",
        btnColor: "#ef4444"
      },
      info: {
        icon: /* @__PURE__ */ jsxRuntimeExports.jsx(FaQuestionCircle, {}),
        color: "#5865f2",
        gradient: "linear-gradient(135deg, #5865f2 0%, #4752c4 100%)",
        btnColor: "#5865f2"
      }
    };
    const tc = typeConfig[type] || typeConfig.warning;
    root2.render(
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          style: {
            position: "fixed",
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            backgroundColor: "rgba(0,0,0,0.7)",
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            zIndex: 1e5,
            animation: "confirmFadeIn 0.2s ease-out",
            backdropFilter: "blur(4px)"
          },
          onClick: /* @__PURE__ */ __name((e) => {
            if (e.target === e.currentTarget) cleanup(false);
          }, "onClick"),
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("style", { children: `
                    @keyframes confirmFadeIn { from { opacity: 0; } to { opacity: 1; } }
                    @keyframes confirmSlideIn { from { transform: scale(0.9) translateY(20px); opacity: 0; } to { transform: scale(1) translateY(0); opacity: 1; } }
                    .confirm-btn:hover { filter: brightness(1.1); transform: translateY(-1px); }
                    .confirm-btn:active { transform: translateY(0); }
                ` }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
              background: "#2b2d31",
              borderRadius: "16px",
              width: "420px",
              maxWidth: "90vw",
              boxShadow: "0 20px 60px rgba(0,0,0,0.5), 0 0 0 1px rgba(255,255,255,0.05)",
              overflow: "hidden",
              animation: "confirmSlideIn 0.25s ease-out"
            }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
                background: tc.gradient,
                padding: "20px 24px",
                display: "flex",
                alignItems: "center",
                gap: "12px"
              }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
                  width: "40px",
                  height: "40px",
                  borderRadius: "12px",
                  background: "rgba(255,255,255,0.2)",
                  display: "flex",
                  alignItems: "center",
                  justifyContent: "center",
                  fontSize: "18px",
                  color: "#fff",
                  flexShrink: 0
                }, children: tc.icon }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { style: {
                  margin: 0,
                  color: "#fff",
                  fontSize: "16px",
                  fontWeight: 600,
                  flex: 1
                }, children: title }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    onClick: /* @__PURE__ */ __name(() => cleanup(false), "onClick"),
                    style: {
                      background: "rgba(255,255,255,0.15)",
                      border: "none",
                      color: "#fff",
                      width: "32px",
                      height: "32px",
                      borderRadius: "8px",
                      cursor: "pointer",
                      display: "flex",
                      alignItems: "center",
                      justifyContent: "center",
                      fontSize: "14px",
                      flexShrink: 0,
                      transition: "background 0.15s"
                    },
                    onMouseEnter: /* @__PURE__ */ __name((e) => e.target.style.background = "rgba(255,255,255,0.25)", "onMouseEnter"),
                    onMouseLeave: /* @__PURE__ */ __name((e) => e.target.style.background = "rgba(255,255,255,0.15)", "onMouseLeave"),
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(FaTimes, {})
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { padding: "20px 24px" }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: {
                  color: "#dbdee1",
                  fontSize: "14px",
                  lineHeight: "1.6",
                  margin: "0 0 16px 0",
                  whiteSpace: "pre-line"
                }, children: message }),
                details && details.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
                  background: "rgba(255,255,255,0.03)",
                  border: "1px solid rgba(255,255,255,0.06)",
                  borderRadius: "10px",
                  padding: "12px 16px",
                  marginBottom: "16px"
                }, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { color: "#f59e0b", fontSize: "12px", fontWeight: 600, marginBottom: "8px" }, children: "âš ï¸ Bu iÅŸlem:" }),
                  details.map((d, i) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
                    color: "#b5bac1",
                    fontSize: "13px",
                    padding: "3px 0",
                    display: "flex",
                    gap: "8px"
                  }, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { color: tc.color }, children: "â€¢" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: d })
                  ] }, i))
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
                padding: "16px 24px",
                background: "rgba(0,0,0,0.15)",
                display: "flex",
                justifyContent: "flex-end",
                gap: "10px"
              }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    className: "confirm-btn",
                    onClick: /* @__PURE__ */ __name(() => cleanup(false), "onClick"),
                    style: {
                      background: "transparent",
                      border: "1px solid rgba(255,255,255,0.1)",
                      color: "#b5bac1",
                      padding: "10px 20px",
                      borderRadius: "8px",
                      cursor: "pointer",
                      fontSize: "14px",
                      fontWeight: 500,
                      transition: "all 0.15s"
                    },
                    onMouseEnter: /* @__PURE__ */ __name((e) => {
                      e.target.style.background = "rgba(255,255,255,0.05)";
                      e.target.style.color = "#fff";
                    }, "onMouseEnter"),
                    onMouseLeave: /* @__PURE__ */ __name((e) => {
                      e.target.style.background = "transparent";
                      e.target.style.color = "#b5bac1";
                    }, "onMouseLeave"),
                    children: cancelText
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    className: "confirm-btn",
                    onClick: /* @__PURE__ */ __name(() => cleanup(true), "onClick"),
                    autoFocus: true,
                    style: {
                      background: tc.btnColor,
                      border: "none",
                      color: "#fff",
                      padding: "10px 24px",
                      borderRadius: "8px",
                      cursor: "pointer",
                      fontSize: "14px",
                      fontWeight: 600,
                      transition: "all 0.15s",
                      boxShadow: `0 2px 8px ${tc.btnColor}40`
                    },
                    children: confirmText
                  }
                )
              ] })
            ] })
          ]
        }
      )
    );
  });
}
__name(confirmDialog, "confirmDialog");
if (typeof window !== "undefined") {
  window.confirmDialog = confirmDialog;
}
function useFetchWithAuth() {
  const { token, logout, refreshAccessToken } = useAuth();
  const isRefreshingRef = reactExports.useRef(false);
  const refreshPromiseRef = reactExports.useRef(null);
  const tokenRef = reactExports.useRef(token);
  tokenRef.current = token;
  const fetchWithAuth = reactExports.useCallback(async (url, options = {}, _isRetry = false) => {
    const currentToken = tokenRef.current || token;
    const headers = { ...options.headers || {} };
    if (currentToken) headers["Authorization"] = `Bearer ${currentToken}`;
    if (!(options.body instanceof FormData)) headers["Content-Type"] = "application/json";
    try {
      const isUpload = url.includes("upload") || options.body instanceof FormData;
      const timeout = isUpload ? 3e5 : 3e4;
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), timeout);
      const response = await fetch(url, { ...options, headers, signal: controller.signal });
      clearTimeout(timeoutId);
      if (response.status === 401 && !_isRetry) {
        if (url.includes("/auth/") || url.includes("/login")) {
          logout();
          throw new Error("Unauthorized");
        }
        if (!isRefreshingRef.current) {
          isRefreshingRef.current = true;
          refreshPromiseRef.current = refreshAccessToken().finally(() => {
            isRefreshingRef.current = false;
          });
        }
        const refreshed = await refreshPromiseRef.current;
        if (refreshed) return fetchWithAuth(url, options, true);
        else throw new Error("Unauthorized");
      }
      return response;
    } catch (err) {
      if (err.name === "AbortError") throw new Error("Ä°stek zaman aÅŸÄ±mÄ±na uÄŸradÄ±");
      if (err.message === "Unauthorized") throw err;
      console.error("Fetch error:", err);
      throw err;
    }
  }, [token, logout, refreshAccessToken]);
  return { fetchWithAuth, tokenRef };
}
__name(useFetchWithAuth, "useFetchWithAuth");
function useAppInit({
  isAuthenticated,
  username,
  token,
  fetchWithAuth,
  setCategories,
  setConversations,
  setAllUsers,
  setFriendsList,
  setCurrentUserProfile,
  setServerOrder,
  setMaintenanceMode,
  setAuthError,
  setServerMembers,
  API_BASE_URL: API_BASE_URL2,
  ROOM_LIST_URL: ROOM_LIST_URL2,
  CONVERSATION_LIST_URL: CONVERSATION_LIST_URL2,
  activeChat,
  categories,
  setActiveChat
}) {
  const [isInitialDataLoaded, setIsInitialDataLoaded] = reactExports.useState(false);
  const fetchingInitRef = reactExports.useRef(false);
  const serverMembersCacheRef = reactExports.useRef({});
  reactExports.useEffect(() => {
    if (!isAuthenticated || isInitialDataLoaded) return;
    if (fetchingInitRef.current) return;
    fetchingInitRef.current = true;
    const fetchInit = /* @__PURE__ */ __name(async () => {
      try {
        let initData = null;
        try {
          const initRes = await fetchWithAuth(`${API_BASE_URL2}/init/`);
          if (initRes.ok) initData = await initRes.json();
        } catch (e) {
          console.warn("âš ï¸ [Init] Combined endpoint failed, falling back");
        }
        let currentUserData, rooms, convs, friendsData;
        if (initData) {
          currentUserData = initData.user;
          rooms = initData.servers;
          convs = initData.conversations;
          friendsData = initData.friends;
          if (initData.server_order) setServerOrder(initData.server_order);
          if (initData.maintenance?.is_maintenance) {
            setMaintenanceMode({
              message: initData.maintenance.message || "System maintenance in progress",
              endTime: initData.maintenance.estimated_end,
              level: "info"
            });
          }
        } else {
          const [rooms_, convs_, friendsData_, currentUserData_] = await Promise.all([
            fetchWithAuth(ROOM_LIST_URL2).then((r) => r.json()),
            fetchWithAuth(`${CONVERSATION_LIST_URL2}?username=${encodeURIComponent(username)}`).then((r) => r.json()),
            fetchWithAuth(`${API_BASE_URL2}/friends/list/`).then((r) => r.json()),
            fetchWithAuth(`${API_BASE_URL2}/users/me/`).then((r) => r.json())
          ]);
          currentUserData = currentUserData_;
          rooms = rooms_;
          convs = convs_;
          friendsData = friendsData_;
        }
        const currentUser = {
          username: currentUserData?.username || username,
          email: currentUserData?.email || "",
          avatar: currentUserData?.avatar || null,
          status_message: currentUserData?.status_message || "",
          friend_code: currentUserData?.friend_code || "0000",
          social_links: currentUserData?.social_links || {},
          coins: currentUserData?.coins || 0,
          xp: currentUserData?.xp || 0,
          level: currentUserData?.level || 1,
          status: "online",
          role: currentUserData?.role || "member",
          is_whitelisted: currentUserData?.is_whitelisted || false
        };
        setCurrentUserProfile(currentUser);
        const friendProfiles = (friendsData.friends || []).map((f) => {
          const isSender = f.sender_username === username;
          const friendUsername = isSender ? f.receiver_username : f.sender_username;
          const friendAvatar = isSender ? f.receiver_avatar : f.sender_avatar;
          const friendStatus = isSender ? f.receiver_status : f.sender_status;
          const friendActivity = isSender ? f.receiver_activity : f.sender_activity;
          if (!friendUsername) return null;
          return {
            username: friendUsername,
            avatar: friendAvatar,
            status: friendStatus || "offline",
            display_name: friendUsername,
            current_activity: friendActivity || {},
            status_message: "",
            last_seen: f.created_at,
            role: "friend",
            friend_code: ""
          };
        }).filter(Boolean);
        const uniqueFriendProfiles = friendProfiles.filter((fp) => fp.username !== currentUser.username);
        setAllUsers(uniqueFriendProfiles);
        setCategories(rooms);
        setConversations(convs);
        setFriendsList(uniqueFriendProfiles);
        setIsInitialDataLoaded(true);
        __vitePreload(async () => {
          const { prefetchUserAvatars } = await import("./imageCaching-xf5IJBbb.js");
          return { prefetchUserAvatars };
        }, true ? __vite__mapDeps([252,1]) : void 0).then(({ prefetchUserAvatars }) => {
          prefetchUserAvatars(uniqueFriendProfiles);
        });
      } catch (e) {
        console.error("Init Data Error", e);
        setAuthError("Veriler yÃ¼klenemedi.");
        fetchingInitRef.current = false;
      }
    }, "fetchInit");
    fetchInit();
  }, [isAuthenticated, isInitialDataLoaded, fetchWithAuth]);
  reactExports.useEffect(() => {
    if (isInitialDataLoaded) return;
    const fetchServerOrder = /* @__PURE__ */ __name(async () => {
      try {
        const res = await fetchWithAuth(`${API_BASE_URL2}/user/server-order/`);
        if (res.ok) {
          const data = await res.json();
          setServerOrder(data.server_order || []);
        }
      } catch (error) {
        console.error("Server order fetch error:", error);
      }
    }, "fetchServerOrder");
    if (username) fetchServerOrder();
  }, [username, fetchWithAuth, isInitialDataLoaded]);
  const [stickyMessage, setStickyMessage] = reactExports.useState(null);
  reactExports.useEffect(() => {
    const fetchStickyMessages = /* @__PURE__ */ __name(async () => {
      if (!activeChat.id || activeChat.type !== "room") {
        setStickyMessage(null);
        return;
      }
      try {
        const res = await fetchWithAuth(`${API_BASE_URL2}/stickies/list/?room=${activeChat.id}`);
        if (res.ok) {
          const stickies = await res.json();
          if (stickies && stickies.length > 0) {
            setStickyMessage({ message: stickies[0].content, type: "info", author: stickies[0].creator });
          } else setStickyMessage(null);
        }
      } catch (error) {
        console.error("Sticky messages fetch error:", error);
      }
    }, "fetchStickyMessages");
    if (isAuthenticated && activeChat.id) fetchStickyMessages();
  }, [activeChat.id, activeChat.type, isAuthenticated, fetchWithAuth]);
  const fetchServerMembersById = reactExports.useCallback(async (serverId, forceRefresh = false) => {
    if (!serverId) {
      setServerMembers([]);
      return;
    }
    const cached = serverMembersCacheRef.current[serverId];
    if (!forceRefresh && cached && Date.now() - cached.timestamp < 12e4) {
      setServerMembers(cached.members);
      return;
    }
    try {
      const res = await fetchWithAuth(`${API_BASE_URL2}/servers/${serverId}/members/`);
      if (res.ok) {
        const members = await res.json();
        serverMembersCacheRef.current[serverId] = { members, timestamp: Date.now() };
        setServerMembers(members);
      } else setServerMembers([]);
    } catch (error) {
      console.error("âŒ Server members fetch error:", error);
      setServerMembers([]);
    }
  }, [fetchWithAuth]);
  const handleServerSelect = reactExports.useCallback((server2) => {
    fetchServerMembersById(server2.id);
    const defaultSlug = server2.metadata?.default_channel_slug;
    let selectedRoom = null;
    if (server2.categories && Array.isArray(server2.categories)) {
      for (const cat of server2.categories) {
        if (cat.rooms && Array.isArray(cat.rooms)) {
          for (const room of cat.rooms) {
            if (defaultSlug && room.slug === defaultSlug) {
              selectedRoom = room;
              break;
            }
            if (!selectedRoom && room.room_type !== "voice") selectedRoom = room;
          }
          if (selectedRoom && defaultSlug && selectedRoom.slug === defaultSlug) break;
        }
      }
    }
    if (selectedRoom) setActiveChat("room", selectedRoom.slug, null);
    else setActiveChat("server", server2.id, null);
  }, [fetchServerMembersById, setActiveChat]);
  reactExports.useEffect(() => {
    if (isAuthenticated && activeChat.id && activeChat.type === "room") {
      let serverId = null;
      for (const server2 of categories || []) {
        if (!server2.categories) continue;
        for (const category of server2.categories) {
          if (!category.rooms) continue;
          for (const room of category.rooms) {
            if (room.slug === activeChat.id) {
              serverId = server2.id;
              break;
            }
          }
          if (serverId) break;
        }
        if (serverId) break;
      }
      if (serverId) fetchServerMembersById(serverId);
      else setServerMembers([]);
    } else if (activeChat.type !== "server") setServerMembers([]);
  }, [activeChat.id, activeChat.type, isAuthenticated, fetchServerMembersById, categories]);
  reactExports.useEffect(() => {
    const hash2 = window.location.hash;
    const queryString = hash2.includes("?") ? hash2.split("?")[1] : "";
    const urlParams = new URLSearchParams(queryString);
    const joinServerId = urlParams.get("join_server");
    if (joinServerId && isAuthenticated && categories && categories.length > 0) {
      const targetServer = categories.find((s) => s.id === parseInt(joinServerId));
      if (targetServer) {
        if (targetServer.categories && targetServer.categories.length > 0) {
          const firstCategory = targetServer.categories[0];
          if (firstCategory.rooms && firstCategory.rooms.length > 0) {
            setActiveChat({ type: "room", id: firstCategory.rooms[0].slug });
          }
        }
        window.history.replaceState({}, document.title, "/#/");
      } else {
        const joinServer = /* @__PURE__ */ __name(async () => {
          try {
            const res = await fetchWithAuth(`${API_BASE_URL2}/servers/${joinServerId}/join/`, { method: "POST" });
            if (res.ok) {
              toast.success("Sunucuya katÄ±ldÄ±nÄ±z!");
              try {
                const roomsRes = await fetchWithAuth(ROOM_LIST_URL2);
                if (roomsRes.ok) {
                  const rooms = await roomsRes.json();
                  setCategories(rooms);
                  const joinedServer = rooms.find((s) => s.id === parseInt(joinServerId));
                  if (joinedServer) handleServerSelect(joinedServer);
                }
              } catch (e) {
                console.warn("Server list refresh failed:", e);
              }
            } else {
              const data = await res.json();
              toast.error(data.error || "Sunucuya katÄ±lÄ±namadÄ±");
            }
          } catch (error) {
            toast.error("Sunucuya katÄ±lÄ±rken hata oluÅŸtu");
          } finally {
            window.history.replaceState({}, document.title, "/#/");
          }
        }, "joinServer");
        joinServer();
      }
    }
  }, [isAuthenticated, categories, fetchWithAuth]);
  return {
    isInitialDataLoaded,
    setIsInitialDataLoaded,
    stickyMessage,
    setStickyMessage,
    serverMembersCacheRef,
    fetchServerMembersById,
    handleServerSelect
  };
}
__name(useAppInit, "useAppInit");
const GoogleAuth = registerPlugin("GoogleAuth", {
  web: /* @__PURE__ */ __name(() => __vitePreload(() => import("./web-m9W83Dzh.js"), true ? __vite__mapDeps([337,3,1,14,15,0,4,16]) : void 0).then((m) => new m.GoogleAuthWeb()), "web")
});
const registerServiceWorker = /* @__PURE__ */ __name(async () => {
  const isElectron2 = typeof window !== "undefined" && (window.process?.versions?.electron || window.navigator?.userAgent?.toLowerCase().includes("electron") || window.location?.protocol === "file:");
  if (isElectron2) {
    console.log("âš ï¸ [PWA] Service Worker disabled in Electron (file:// protocol)");
    return null;
  }
  if ("serviceWorker" in navigator) {
    try {
      const registrations = await navigator.serviceWorker.getRegistrations();
      for (const reg of registrations) {
        if (reg.active && reg.active.scriptURL.includes("service-worker.js")) {
          console.log("ðŸ—‘ï¸ Eski service-worker.js unregister ediliyor...");
          await reg.unregister();
          const cacheNames = await caches.keys();
          for (const name of cacheNames) {
            if (name.includes("pawscord-v")) {
              console.log("ðŸ—‘ï¸ Eski cache siliniyor:", name);
              await caches.delete(name);
            }
          }
        }
      }
      const registration = await navigator.serviceWorker.getRegistration("/");
      if (registration) {
        console.log("âœ… Service Worker active:", registration.scope);
        registration.addEventListener("updatefound", () => {
          const newWorker = registration.installing;
          console.log("ðŸ”„ New Service Worker installing...");
          newWorker.addEventListener("statechange", () => {
            if (newWorker.state === "installed" && navigator.serviceWorker.controller) {
              newWorker.postMessage({ type: "SKIP_WAITING" });
              console.log("ðŸ”„ Yeni SW aktive ediliyor, sayfa yenilenecek...");
              window.location.reload();
            }
          });
        });
        setInterval(() => {
          registration.update();
        }, 30 * 60 * 1e3);
      }
      return registration;
    } catch (error) {
      console.error("âŒ Service Worker error:", error);
      return null;
    }
  }
}, "registerServiceWorker");
const setupInstallPrompt = /* @__PURE__ */ __name(() => {
  window.addEventListener("beforeinstallprompt", (e) => {
    e.preventDefault();
    const installButton = document.getElementById("install-pwa-button");
    if (installButton) {
      installButton.style.display = "block";
    }
    console.log("ðŸ“± PWA install prompt ready");
  });
  window.addEventListener("appinstalled", () => {
    console.log("âœ… PWA installed successfully");
    if (window.gtag) {
      window.gtag("event", "pwa_installed", {
        event_category: "PWA",
        event_label: "App Installed"
      });
    }
  });
}, "setupInstallPrompt");
const setupNetworkMonitor = /* @__PURE__ */ __name((onOnline, onOffline) => {
  const handleOnline = /* @__PURE__ */ __name(() => {
    console.log("âœ… Network: Online");
    if (onOnline) onOnline();
    showNetworkBanner("ðŸŸ¢ Ã‡evrimiÃ§i", "success");
  }, "handleOnline");
  const handleOffline = /* @__PURE__ */ __name(() => {
    console.log("âŒ Network: Offline");
    if (onOffline) onOffline();
    showNetworkBanner("ðŸ”´ Ã‡evrimdÄ±ÅŸÄ± - BaÄŸlantÄ± koptu", "error");
  }, "handleOffline");
  window.addEventListener("online", handleOnline);
  window.addEventListener("offline", handleOffline);
  if (!navigator.onLine) {
    handleOffline();
  }
  return () => {
    window.removeEventListener("online", handleOnline);
    window.removeEventListener("offline", handleOffline);
  };
}, "setupNetworkMonitor");
const showNetworkBanner = /* @__PURE__ */ __name((message, type = "info") => {
  const existingBanner = document.getElementById("network-banner");
  if (existingBanner) {
    existingBanner.remove();
  }
  const banner = document.createElement("div");
  banner.id = "network-banner";
  banner.textContent = message;
  banner.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        padding: 12px;
        text-align: center;
        color: white;
        font-weight: 600;
        z-index: 9999;
        animation: slideDown 0.3s ease;
        background: ${type === "success" ? "#43b581" : "#ed4245"};
    `;
  document.body.appendChild(banner);
  if (type === "success") {
    setTimeout(() => {
      banner.style.animation = "slideUp 0.3s ease";
      setTimeout(() => banner.remove(), 300);
    }, 3e3);
  }
}, "showNetworkBanner");
const addAnimations = /* @__PURE__ */ __name(() => {
  const style = document.createElement("style");
  style.textContent = `
        @keyframes slideDown {
            from { transform: translateY(-100%); }
            to { transform: translateY(0); }
        }
        
        @keyframes slideUp {
            from { transform: translateY(0); }
            to { transform: translateY(-100%); }
        }
    `;
  document.head.appendChild(style);
}, "addAnimations");
addAnimations();
const CRITICAL_CSS = `
/* ðŸŽ¨ PAWSCORD Critical CSS - Above the Fold */

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: 'Whitney', 'Helvetica Neue', Helvetica, Arial, sans-serif;
    background-color: #1e1f22;
    color: #dcddde;
    overflow: hidden;
}

/* Loading Screen */
#loading-screen {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: #1e1f22;
    display: flex;
    align-items: center;
    justify-center: center;
    z-index: 9999;
}

.spinner {
    width: 50px;
    height: 50px;
    border: 4px solid #40444b;
    border-top-color: #5865f2;
    border-radius: 50%;
    animation: spin 1s linear infinite;
}

@keyframes spin {
    to { transform: rotate(360deg); }
}

/* Main Layout */
#root {
    width: 100vw;
    height: 100vh;
    overflow: hidden;
}

.app-container {
    display: flex;
    width: 100%;
    height: 100%;
}

/* Sidebar */
.sidebar {
    width: 240px;
    background: #2b2d31;
    flex-shrink: 0;
}

/* Chat Area */
.chat-container {
    flex: 1;
    display: flex;
    flex-direction: column;
    background: #313338;
}

/* Message Input - Critical */
.message-input-container {
    padding: 16px;
    background: #383a40;
}

.message-input {
    width: 100%;
    padding: 12px;
    background: #40444b;
    border: none;
    border-radius: 8px;
    color: #dcddde;
    font-size: 15px;
    outline: none;
}

/* Button Base */
button {
    cursor: pointer;
    border: none;
    background: transparent;
    color: inherit;
    font-family: inherit;
}

.btn-primary {
    background: #5865f2;
    color: white;
    padding: 10px 16px;
    border-radius: 4px;
    font-weight: 500;
    transition: background 0.17s ease;
}

.btn-primary:hover {
    background: #4752c4;
}

/* Scrollbar */
::-webkit-scrollbar {
    width: 8px;
    height: 8px;
}

::-webkit-scrollbar-track {
    background: #2b2d31;
}

::-webkit-scrollbar-thumb {
    background: #1a1b1e;
    border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
    background: #141517;
}

/* Typography */
h1, h2, h3, h4, h5, h6 {
    font-weight: 600;
    line-height: 1.2;
}

/* Utilities */
.flex {
    display: flex;
}

.flex-col {
    flex-direction: column;
}

.items-center {
    align-items: center;
}

.justify-center {
    justify-content: center;
}

.gap-2 {
    gap: 8px;
}

.gap-4 {
    gap: 16px;
}

.hidden {
    display: none !important;
}

/* Mobile Responsive */
@media (max-width: 768px) {
    .sidebar {
        width: 100%;
        position: absolute;
        z-index: 100;
        transform: translateX(-100%);
        transition: transform 0.3s ease;
    }
    
    .sidebar.open {
        transform: translateX(0);
    }
}
`;
const inlineCriticalCSS = /* @__PURE__ */ __name(() => {
  const style = document.createElement("style");
  style.id = "critical-css";
  style.textContent = CRITICAL_CSS;
  document.head.insertBefore(style, document.head.firstChild);
}, "inlineCriticalCSS");
const lazyLoadCSS = /* @__PURE__ */ __name((href) => {
  return new Promise((resolve, reject) => {
    const link = document.createElement("link");
    link.rel = "stylesheet";
    link.href = href;
    link.onload = () => {
      resolve();
    };
    link.onerror = reject;
    document.head.appendChild(link);
  });
}, "lazyLoadCSS");
const loadNonCriticalCSS = /* @__PURE__ */ __name(() => {
  const nonCriticalCSS = [];
  const loadCSS = /* @__PURE__ */ __name(() => {
    nonCriticalCSS.forEach((href) => {
      lazyLoadCSS(href);
    });
  }, "loadCSS");
  if ("requestIdleCallback" in window) {
    requestIdleCallback(loadCSS);
  } else {
    setTimeout(loadCSS, 1);
  }
}, "loadNonCriticalCSS");
const optimizeFontLoading = /* @__PURE__ */ __name(() => {
  const isElectron2 = typeof window !== "undefined" && (window.process?.versions?.electron || window.navigator?.userAgent?.includes("Electron") || window.location?.protocol === "file:");
  if (isElectron2) {
    return;
  }
}, "optimizeFontLoading");
const preloadKeyResources = /* @__PURE__ */ __name(() => {
  const isElectron2 = typeof window !== "undefined" && (window.process?.versions?.electron || window.navigator?.userAgent?.includes("Electron") || window.location?.protocol === "file:");
  if (isElectron2) {
    return;
  }
}, "preloadKeyResources");
const removeCriticalCSS = /* @__PURE__ */ __name(() => {
  const criticalStyle = document.getElementById("critical-css");
  if (criticalStyle) {
    setTimeout(() => {
      criticalStyle.remove();
    }, 1e3);
  }
}, "removeCriticalCSS");
const initializeCSSOptimization = /* @__PURE__ */ __name(() => {
  inlineCriticalCSS();
  preloadKeyResources();
  optimizeFontLoading();
  loadNonCriticalCSS();
  if (document.readyState === "complete") {
    removeCriticalCSS();
  } else {
    window.addEventListener("load", removeCriticalCSS);
  }
}, "initializeCSSOptimization");
const ComponentChunks = {
  // Modals (heavy)
  serverSettings: /* @__PURE__ */ __name(() => __vitePreload(() => import("./ServerSettingsModal-DMBbz04j.js"), true ? __vite__mapDeps([48,1,4,49,50,3,14,15,0,16]) : void 0), "serverSettings"),
  userProfile: /* @__PURE__ */ __name(() => __vitePreload(() => import("./UserProfileModal-nuerxjra.js"), true ? __vite__mapDeps([257,1,4,232,3,14,15,0,16,244]) : void 0), "userProfile"),
  imageModal: /* @__PURE__ */ __name(() => __vitePreload(() => import("./ImageModal-BlJrc8Ul.js"), true ? __vite__mapDeps([271,1]) : void 0), "imageModal"),
  // Media
  gifPicker: /* @__PURE__ */ __name(() => __vitePreload(() => import("./GifPicker-DRHla4ZE.js"), true ? __vite__mapDeps([6,1]) : void 0), "gifPicker"),
  stickerPicker: /* @__PURE__ */ __name(() => __vitePreload(() => import("./StickerPicker-D4KgwPIx.js"), true ? __vite__mapDeps([7,1]) : void 0), "stickerPicker"),
  // Tools
  poll: /* @__PURE__ */ __name(() => __vitePreload(() => import("./PollCreateModal-C0kTUS7Q.js"), true ? __vite__mapDeps([40,1,4]) : void 0), "poll"),
  codeSnippet: /* @__PURE__ */ __name(() => __vitePreload(() => import("./CodeSnippetModal-C61Oq3Pi.js"), true ? __vite__mapDeps([26,1,4]) : void 0), "codeSnippet")
};
const preloadCriticalChunks = /* @__PURE__ */ __name(() => {
  const criticalChunks = [
    ComponentChunks.userProfile,
    ComponentChunks.imageModal,
    ComponentChunks.serverSettings
  ];
  criticalChunks.forEach((chunk) => {
    try {
      chunk();
    } catch (e) {
    }
  });
}, "preloadCriticalChunks");
const prefetchNextChunks = /* @__PURE__ */ __name(() => {
  const secondaryChunks = [
    ComponentChunks.gifPicker,
    ComponentChunks.stickerPicker,
    ComponentChunks.poll,
    ComponentChunks.codeSnippet
  ];
  secondaryChunks.forEach((chunk) => {
    try {
      chunk();
    } catch (e) {
    }
  });
}, "prefetchNextChunks");
const getOrCreateSessionId = /* @__PURE__ */ __name(() => {
  let sessionId = sessionStorage.getItem("analytics_session_id");
  if (!sessionId) {
    sessionId = `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    sessionStorage.setItem("analytics_session_id", sessionId);
  }
  return sessionId;
}, "getOrCreateSessionId");
const usePageTracking = /* @__PURE__ */ __name(() => {
  const location = useLocation();
  reactExports.useEffect(() => {
    const trackPageView = /* @__PURE__ */ __name(async () => {
      try {
        const sessionId = getOrCreateSessionId();
        const token = localStorage.getItem("access_token");
        const headers = {
          "Content-Type": "application/json"
        };
        if (token) {
          headers["Authorization"] = `Bearer ${token}`;
        }
        await fetch(`${API_BASE_URL$1}/analytics/track/`, {
          method: "POST",
          headers,
          body: JSON.stringify({
            path: location.pathname,
            session_id: sessionId,
            referrer: document.referrer,
            timestamp: (/* @__PURE__ */ new Date()).toISOString()
          })
        });
      } catch (error) {
      }
    }, "trackPageView");
    trackPageView();
  }, [location.pathname]);
}, "usePageTracking");
const useKeyboardShortcuts = /* @__PURE__ */ __name((handlers = {}) => {
  const handleKeyDown = reactExports.useCallback((event) => {
    const { ctrlKey, shiftKey, altKey, metaKey, key } = event;
    const isMac = navigator.platform.toUpperCase().indexOf("MAC") >= 0;
    const cmdOrCtrl = isMac ? metaKey : ctrlKey;
    if (cmdOrCtrl && key === "k") {
      event.preventDefault();
      handlers.onQuickSwitcher?.();
    }
    if (cmdOrCtrl && key === "f") {
      event.preventDefault();
      handlers.onSearch?.();
    }
    if (cmdOrCtrl && key === "/") {
      event.preventDefault();
      handlers.onCommandList?.();
    }
    if (cmdOrCtrl && shiftKey && key === "M") {
      event.preventDefault();
      handlers.onToggleMute?.();
    }
    if (cmdOrCtrl && shiftKey && key.toLowerCase() === "p") {
      event.preventDefault();
      handlers.onCommandPalette?.();
    }
    if (cmdOrCtrl && key === ",") {
      event.preventDefault();
      handlers.onSettings?.();
    }
    if (cmdOrCtrl && shiftKey && key === "D") {
      event.preventDefault();
      handlers.onToggleDeafen?.();
    }
    if (altKey && (key === "ArrowUp" || key === "ArrowDown")) {
      event.preventDefault();
      handlers.onNavigateChannel?.(key === "ArrowUp" ? -1 : 1);
    }
    if (cmdOrCtrl && key === "Enter") {
      event.preventDefault();
      handlers.onSendMessage?.();
    }
    if (key === "Escape") {
      handlers.onEscape?.();
    }
    if (cmdOrCtrl && key === "b") {
      event.preventDefault();
      handlers.onToggleSidebar?.();
    }
    if (cmdOrCtrl && key === "i") {
      event.preventDefault();
      handlers.onToggleUserInfo?.();
    }
    if (cmdOrCtrl && key === "e") {
      event.preventDefault();
      handlers.onToggleEmoji?.();
    }
    if (cmdOrCtrl && shiftKey && key === "T") {
      event.preventDefault();
      handlers.onToggleTheme?.();
    }
    if (key === "ArrowUp" && !cmdOrCtrl && !shiftKey && !altKey) {
      handlers.onEditLastMessage?.();
    }
  }, [handlers]);
  reactExports.useEffect(() => {
    window.addEventListener("keydown", handleKeyDown);
    return () => window.removeEventListener("keydown", handleKeyDown);
  }, [handleKeyDown]);
  return null;
}, "useKeyboardShortcuts");
const getShortcutKey = /* @__PURE__ */ __name(() => {
  const isMac = navigator.platform.toUpperCase().indexOf("MAC") >= 0;
  return isMac ? "âŒ˜" : "Ctrl";
}, "getShortcutKey");
const THEMES = {
  default: {
    name: "Pawscord Dark",
    colors: {
      "--background-primary": "#313338",
      "--background-secondary": "#2b2d31",
      "--background-tertiary": "#1e1f22",
      "--background-accent": "#404249",
      "--text-primary": "#dbdee1",
      "--text-secondary": "#949ba4",
      "--text-muted": "#787f89",
      "--text-link": "#00a8fc",
      "--button-primary": "#5865f2",
      "--button-secondary": "#4e5058",
      "--border-primary": "#1f2023"
    }
  },
  midnight: {
    name: "Midnight AMOLED",
    colors: {
      "--background-primary": "#000000",
      "--background-secondary": "#0a0a0a",
      "--background-tertiary": "#111111",
      "--background-accent": "#222222",
      "--text-primary": "#ffffff",
      "--text-secondary": "#b0b0b0",
      "--text-muted": "#666666",
      "--text-link": "#3ea6ff",
      "--button-primary": "#3ea6ff",
      "--button-secondary": "#333333",
      "--border-primary": "#333333"
    }
  },
  dracula: {
    name: "Dracula",
    colors: {
      "--background-primary": "#282a36",
      "--background-secondary": "#44475a",
      "--background-tertiary": "#6272a4",
      "--background-accent": "#44475a",
      "--text-primary": "#f8f8f2",
      "--text-secondary": "#bfbfbf",
      "--text-muted": "#6272a4",
      "--text-link": "#8be9fd",
      "--button-primary": "#bd93f9",
      "--button-secondary": "#44475a",
      "--border-primary": "#44475a"
    }
  },
  ocean: {
    name: "Deep Ocean",
    colors: {
      "--background-primary": "#0f172a",
      "--background-secondary": "#1e293b",
      "--background-tertiary": "#334155",
      "--background-accent": "#334155",
      "--text-primary": "#e2e8f0",
      "--text-secondary": "#94a3b8",
      "--text-muted": "#64748b",
      "--text-link": "#38bdf8",
      "--button-primary": "#0ea5e9",
      "--button-secondary": "#334155",
      "--border-primary": "#1e293b"
    }
  },
  forest: {
    name: "Enchanted Forest",
    colors: {
      "--background-primary": "#1a2f1a",
      "--background-secondary": "#243b24",
      "--background-tertiary": "#2f4b2f",
      "--background-accent": "#3a5a3a",
      "--text-primary": "#e0ffe0",
      "--text-secondary": "#a0cca0",
      "--text-muted": "#608060",
      "--text-link": "#4caf50",
      "--button-primary": "#4caf50",
      "--button-secondary": "#2f4b2f",
      "--border-primary": "#2f4b2f"
    }
  },
  matrix: {
    name: "The Matrix",
    colors: {
      "--background-primary": "#0d0d0d",
      "--background-secondary": "#121212",
      "--background-tertiary": "#1a1a1a",
      "--background-accent": "#003b00",
      "--text-primary": "#00ff41",
      "--text-secondary": "#008f11",
      "--text-muted": "#003b00",
      "--text-link": "#00ff41",
      "--button-primary": "#008f11",
      "--button-secondary": "#003b00",
      "--border-primary": "#003b00"
    }
  },
  sunset: {
    name: "Sunset Vibes",
    colors: {
      "--background-primary": "#2d1b2e",
      "--background-secondary": "#442740",
      "--background-tertiary": "#5a3450",
      "--background-accent": "#734361",
      "--text-primary": "#ffccaa",
      "--text-secondary": "#ff9e7d",
      "--text-muted": "#b05963",
      "--text-link": "#ffbd69",
      "--button-primary": "#ff6b6b",
      "--button-secondary": "#5a3450",
      "--border-primary": "#5a3450"
    }
  }
};
const applyTheme = /* @__PURE__ */ __name((themeKey) => {
  const theme = THEMES[themeKey] || THEMES.default;
  const root2 = document.documentElement;
  Object.entries(theme.colors).forEach(([property, value]) => {
    root2.style.setProperty(property, value);
  });
  localStorage.setItem("pawscord_theme", themeKey);
}, "applyTheme");
const loadSavedTheme = /* @__PURE__ */ __name(() => {
  const savedTheme = localStorage.getItem("pawscord_theme");
  if (savedTheme && THEMES[savedTheme]) {
    applyTheme(savedTheme);
    return savedTheme;
  }
  return "default";
}, "loadSavedTheme");
function useAppEffects({
  // State setters
  setAnimationState,
  setShowVanityInvite,
  setShowInviteCode,
  setMaintenanceMode,
  setUpdateAvailable,
  setAllUsers,
  // State values
  animationState,
  isInitialDataLoaded,
  isAuthenticated,
  username,
  messages,
  activeChat,
  isInVoice,
  currentVoiceRoom,
  modals,
  // Refs
  statusWsRef,
  // Store functions
  openModal,
  closeModal,
  toggleModal,
  setActiveChat,
  // Auth
  isNative: isNative2,
  isElectron: isElectron2,
  // Helpers
  fetchWithAuth,
  isNearBottom,
  scrollToBottom,
  handleMessageScroll,
  // Config
  API_BASE_URL: API_BASE_URL2,
  MEDIA_BASE_URL: MEDIA_BASE_URL2,
  // Imported utils
  GOOGLE_WEB_CLIENT_ID: GOOGLE_WEB_CLIENT_ID2
}) {
  const [safeAreaTop, setSafeAreaTop] = reactExports.useState("0px");
  reactExports.useEffect(() => {
    if (animationState === "finished") return;
    setAnimationState("start");
    const minTimer = setTimeout(() => setAnimationState("pre-transition"), 800);
    const forceFinishTimer = setTimeout(() => setAnimationState("finished"), 2e3);
    return () => {
      clearTimeout(minTimer);
      clearTimeout(forceFinishTimer);
    };
  }, []);
  reactExports.useEffect(() => {
    if (isInitialDataLoaded && animationState === "pre-transition") {
      setAnimationState("finished");
    }
  }, [isInitialDataLoaded, animationState]);
  reactExports.useEffect(() => {
    const params = new URLSearchParams(window.location.search);
    const verification = params.get("verification");
    const verUsername = params.get("username");
    const reason = params.get("reason");
    const needsPassword = params.get("needs_password");
    if (verification === "success") {
      toast.success(`âœ… Email doÄŸrulandÄ±! HoÅŸgeldin ${verUsername || "kullanÄ±cÄ±"}!`);
      window.history.replaceState({}, document.title, window.location.pathname);
    } else if (verification === "failed") {
      const errorMsg = reason === "expired" ? "â° DoÄŸrulama linki sÃ¼resi dolmuÅŸ. Yeni bir link talep edin." : "âŒ GeÃ§ersiz doÄŸrulama linki.";
      toast.error(errorMsg);
      window.history.replaceState({}, document.title, window.location.pathname);
    }
    if (needsPassword === "true") {
      openModal("passwordSetupModal");
      window.history.replaceState({}, document.title, window.location.pathname);
    }
  }, []);
  reactExports.useEffect(() => {
    const params = new URLSearchParams(window.location.search);
    const success = params.get("success");
    const coins = params.get("coins");
    const sessionId = params.get("session_id");
    const canceled = params.get("canceled");
    if (success === "true" && coins) {
      const verifyPayment = /* @__PURE__ */ __name(async () => {
        try {
          const token = localStorage.getItem("access_token");
          const apiBase = API_BASE_URL2 || "https://api.pawscord.com/api";
          if (sessionId) {
            const response = await fetch(`${apiBase}/payments/verify/`, {
              method: "POST",
              headers: {
                "Authorization": `Bearer ${token}`,
                "Content-Type": "application/json"
              },
              body: JSON.stringify({
                session_id: sessionId,
                coin_amount: parseInt(coins)
              })
            });
            const data = await response.json();
            if (data.success) {
              if (data.already_processed) {
                toast.info(`ðŸ’° Ã–deme zaten iÅŸlendi! Bakiye: ${data.balance} coin`);
              } else {
                toast.success(`ðŸŽ‰ ${coins} coin hesabÄ±na eklendi! Yeni bakiye: ${data.balance} coin`);
              }
            } else {
              toast.error(data.error || "Ã–deme doÄŸrulama hatasÄ±");
            }
          } else {
            toast.success(`ðŸŽ‰ Ã–deme baÅŸarÄ±lÄ±! ${coins} coin hesabÄ±na eklendi.`);
          }
        } catch (error) {
          console.error("Payment verification error:", error);
          toast.success(`ðŸŽ‰ ${coins} coin satÄ±n alma tamamlandÄ±!`);
        }
      }, "verifyPayment");
      verifyPayment();
      window.history.replaceState({}, document.title, window.location.pathname);
    }
    if (canceled === "true") {
      toast.info("âŒ Ã–deme iptal edildi.");
      window.history.replaceState({}, document.title, window.location.pathname);
    }
  }, []);
  reactExports.useEffect(() => {
    const hash2 = window.location.hash;
    const inviteMatch = hash2.match(/^#\/invite\/([^/?]+)/);
    if (inviteMatch) {
      setShowInviteCode(inviteMatch[1]);
      return;
    }
    const vanityMatch = hash2.match(/^#\/join\/([^/?]+)/);
    if (vanityMatch) {
      setShowVanityInvite(vanityMatch[1]);
      return;
    }
    const pathMatch = window.location.pathname.match(/^\/join\/([^/?]+)/);
    if (pathMatch) {
      const vanityPath = pathMatch[1];
      window.history.replaceState({}, "", `/#/join/${vanityPath}`);
      setShowVanityInvite(vanityPath);
    }
  }, []);
  reactExports.useEffect(() => {
    window.showAutoModeration = () => openModal("autoModeration");
    window.showRaidProtection = () => openModal("raidProtection");
    window.showReportSystem = () => openModal("reportSystem");
    window.showAuditLog = () => openModal("auditLog");
    window.showUserWarnings = () => openModal("userWarnings");
    return () => {
      delete window.showAutoModeration;
      delete window.showRaidProtection;
      delete window.showReportSystem;
      delete window.showAuditLog;
      delete window.showUserWarnings;
    };
  }, []);
  reactExports.useEffect(() => {
    const handleClickOutside = /* @__PURE__ */ __name((e) => {
      if (modals.toolbarMenu && !e.target.closest(".toolbar-menu-container")) {
        closeModal("toolbarMenu");
      }
    }, "handleClickOutside");
    document.addEventListener("click", handleClickOutside);
    return () => document.removeEventListener("click", handleClickOutside);
  }, [modals.toolbarMenu]);
  reactExports.useEffect(() => {
    const handleOpenConnectionsPanel = /* @__PURE__ */ __name(() => {
      openModal("connectionsPanel");
    }, "handleOpenConnectionsPanel");
    window.addEventListener("openConnectionsPanel", handleOpenConnectionsPanel);
    return () => window.removeEventListener("openConnectionsPanel", handleOpenConnectionsPanel);
  }, []);
  reactExports.useEffect(() => {
    registerServiceWorker();
    setupInstallPrompt();
    setupNetworkMonitor();
    initializeCSSOptimization();
    setTimeout(() => {
      preloadCriticalChunks();
    }, 3e3);
    if ("requestIdleCallback" in window) {
      requestIdleCallback(() => {
        prefetchNextChunks();
      });
    }
    if (isNative2) {
      __vitePreload(async () => {
        const { initializeDeepLinkHandler } = await import("./urlHandlers-_pbByjvw.js");
        return { initializeDeepLinkHandler };
      }, true ? __vite__mapDeps([338,3,1,14,15,0,4,16]) : void 0).then(({ initializeDeepLinkHandler }) => {
      });
    }
  }, []);
  reactExports.useEffect(() => {
    if (isAuthenticated) {
      __vitePreload(async () => {
        const { pushNotificationManager } = await import("./pushNotifications-BulFuBDa.js");
        return { pushNotificationManager };
      }, true ? __vite__mapDeps([339,3,1]) : void 0).then(({ pushNotificationManager }) => {
        pushNotificationManager.init(API_BASE_URL2, fetchWithAuth);
      });
    }
  }, [isAuthenticated]);
  reactExports.useEffect(() => {
    if (Capacitor.isNativePlatform()) {
      GoogleAuth.initialize({
        clientId: GOOGLE_WEB_CLIENT_ID2,
        scopes: ["profile", "email"],
        grantOfflineAccess: true
      });
      setSafeAreaTop("max(35px, env(safe-area-inset-top))");
    }
  }, []);
  reactExports.useEffect(() => {
    const compareVersions = /* @__PURE__ */ __name((latest, current) => {
      try {
        const latestParts = latest.split(".").map(Number);
        const currentParts = current.split(".").map(Number);
        if (latestParts[0] > currentParts[0]) return true;
        if (latestParts[0] < currentParts[0]) return false;
        if (latestParts[1] > currentParts[1]) return true;
        if (latestParts[1] < currentParts[1]) return false;
        if (latestParts[2] > currentParts[2]) return true;
        return false;
      } catch (error) {
        console.error("âŒ Version karÅŸÄ±laÅŸtÄ±rma hatasÄ±:", error);
        return false;
      }
    }, "compareVersions");
    const checkForUpdates = /* @__PURE__ */ __name(async () => {
      const isDebugMode = window.location.hostname === "localhost" && window.location.port === "3000";
      if (!isElectron2 && !isNative2 && !isDebugMode) {
        return;
      }
      try {
        let currentVersion = "1.1.210";
        if (window.electron?.getAppVersion) {
          try {
            currentVersion = await window.electron.getAppVersion();
          } catch (e) {
            console.warn("âš ï¸ Electron version alÄ±namadÄ±:", e);
          }
        }
        const res = await fetch("https://media.pawscord.com/builds/version.json");
        if (!res.ok) {
          console.warn("âš ï¸ version.json alÄ±namadÄ±:", res.status);
          return;
        }
        const data = await res.json();
        const latestVersion = data.latest_version;
        const isNewer = compareVersions(latestVersion, currentVersion);
        if (latestVersion && isNewer) {
          setUpdateAvailable(true);
          if (window.require) {
            const { ipcRenderer } = window.require("electron");
            ipcRenderer.send("update-available", {
              currentVersion,
              latestVersion,
              downloadUrl: data.download_url_windows
            });
          }
        } else {
          setUpdateAvailable(false);
        }
      } catch (error) {
        console.error("âŒ Version check hatasÄ±:", error);
      }
    }, "checkForUpdates");
    checkForUpdates();
    const interval = setInterval(checkForUpdates, 30 * 60 * 1e3);
    return () => clearInterval(interval);
  }, []);
  reactExports.useEffect(() => {
    if (!isAuthenticated || !username) return;
    const prevActivityRef = { current: null };
    const checkActivity = /* @__PURE__ */ __name(async () => {
      try {
        const res = await fetchWithAuth(`${API_BASE_URL2}/users/rich_presence/${username}/`);
        if (res.ok) {
          const data = await res.json();
          let newActivity = {};
          const isTimestampFresh = /* @__PURE__ */ __name((timestamp) => {
            if (!timestamp) return true;
            const activityTime = new Date(timestamp);
            const now = /* @__PURE__ */ new Date();
            const diffMinutes = (now - activityTime) / 1e3 / 60;
            return diffMinutes < 2;
          }, "isTimestampFresh");
          if (data.spotify && isTimestampFresh(data.spotify.timestamp)) {
            newActivity.spotify = {
              type: "listening",
              name: data.spotify.track,
              details: data.spotify.artist,
              album_art: data.spotify.album_art
            };
          }
          if (data.steam && isTimestampFresh(data.steam.timestamp)) {
            newActivity.steam = {
              type: "playing",
              name: data.steam.game,
              state: data.steam.state
            };
          }
          if (Object.keys(newActivity).length === 0) newActivity = null;
          const prevStr = JSON.stringify(prevActivityRef.current);
          const newStr = JSON.stringify(newActivity);
          if (prevStr !== newStr) {
            prevActivityRef.current = newActivity;
            if (statusWsRef.current && statusWsRef.current.readyState === WebSocket.OPEN) {
              statusWsRef.current.send(JSON.stringify({
                type: "update_activity",
                activity: newActivity
              }));
            }
          }
        }
      } catch (e) {
      }
    }, "checkActivity");
    const interval = setInterval(checkActivity, 3e4);
    checkActivity();
    return () => clearInterval(interval);
  }, [isAuthenticated, username, fetchWithAuth]);
  reactExports.useEffect(() => {
    const checkMaintenanceMode = /* @__PURE__ */ __name(async () => {
      try {
        const res = await fetch(`${API_BASE_URL2}/maintenance/status/`);
        if (res.ok) {
          const data = await res.json();
          if (data.active) {
            setMaintenanceMode({
              message: data.message || "System maintenance in progress",
              endTime: data.end_time,
              level: data.level || "info"
            });
          } else {
            setMaintenanceMode(null);
          }
        }
      } catch (error) {
        console.error("Maintenance check error:", error);
      }
    }, "checkMaintenanceMode");
    const interval = setInterval(checkMaintenanceMode, 5 * 60 * 1e3);
    return () => clearInterval(interval);
  }, []);
  reactExports.useEffect(() => {
    if (isNearBottom()) {
      scrollToBottom("smooth");
    }
  }, [messages, isNearBottom, scrollToBottom]);
  reactExports.useEffect(() => {
    handleMessageScroll();
  }, [activeChat, handleMessageScroll]);
  useKeyboardShortcuts({
    onQuickSwitcher: /* @__PURE__ */ __name(() => toggleModal("quickSwitcher"), "onQuickSwitcher"),
    onCommandList: /* @__PURE__ */ __name(() => toggleModal("keyboardShortcuts"), "onCommandList"),
    onCommandPalette: /* @__PURE__ */ __name(() => toggleModal("commandPalette"), "onCommandPalette"),
    onSettings: /* @__PURE__ */ __name(() => toggleModal("userSettings"), "onSettings"),
    onEscape: /* @__PURE__ */ __name(() => {
      if (modals.featureHub) closeModal("featureHub");
    }, "onEscape")
  });
  reactExports.useEffect(() => {
    if (isInVoice && currentVoiceRoom) {
      setActiveChat("voice", currentVoiceRoom);
    }
  }, [isInVoice, currentVoiceRoom]);
  usePageTracking();
  return { safeAreaTop };
}
__name(useAppEffects, "useAppEffects");
const SOUND_URLS = {
  message: `${CDN_BASE_URL}/sounds/message.mp3`,
  mention: `${CDN_BASE_URL}/sounds/mention.mp3`,
  dm: `${CDN_BASE_URL}/sounds/dm.mp3`,
  join: `${CDN_BASE_URL}/sounds/join.mp3`,
  leave: `${CDN_BASE_URL}/sounds/leave.mp3`,
  call: `${CDN_BASE_URL}/sounds/call.mp3`,
  deafen: `${CDN_BASE_URL}/sounds/deafen.mp3`,
  mute: `${CDN_BASE_URL}/sounds/mute.mp3`
};
const FALLBACK_TONES = {
  message: { freq: 880, duration: 0.08, type: "sine", volume: 0.15 },
  mention: { freq: 1200, duration: 0.12, type: "sine", volume: 0.25, repeat: 2 },
  dm: { freq: 660, duration: 0.1, type: "triangle", volume: 0.2, repeat: 2 },
  join: { freq: 520, duration: 0.15, type: "sine", volume: 0.12, ramp: "up" },
  leave: { freq: 420, duration: 0.15, type: "sine", volume: 0.12, ramp: "down" },
  call: { freq: 440, duration: 0.3, type: "sine", volume: 0.3, repeat: 3 },
  deafen: { freq: 300, duration: 0.1, type: "square", volume: 0.1 },
  mute: { freq: 350, duration: 0.08, type: "square", volume: 0.1 }
};
const _NotificationSoundManager = class _NotificationSoundManager {
  constructor() {
    this.audioCache = {};
    this.audioContext = null;
    this.enabled = true;
    this.volume = 0.5;
    this.quietHours = null;
    this._cooldowns = {};
    this._loadSettings();
  }
  _loadSettings() {
    try {
      const saved = localStorage.getItem("pawscord_sound_settings");
      if (saved) {
        const parsed = JSON.parse(saved);
        this.enabled = parsed.enabled !== false;
        this.volume = parsed.volume ?? 0.5;
        this.quietHours = parsed.quietHours || null;
        this.perEvent = parsed.perEvent || {};
      }
    } catch (e) {
    }
  }
  saveSettings() {
    try {
      localStorage.setItem("pawscord_sound_settings", JSON.stringify({
        enabled: this.enabled,
        volume: this.volume,
        quietHours: this.quietHours,
        perEvent: this.perEvent || {}
      }));
    } catch (e) {
    }
  }
  setEnabled(val) {
    this.enabled = val;
    this.saveSettings();
  }
  setVolume(val) {
    this.volume = Math.max(0, Math.min(1, val));
    this.saveSettings();
  }
  setQuietHours(start, end) {
    this.quietHours = start && end ? { start, end } : null;
    this.saveSettings();
  }
  setEventEnabled(event, val) {
    if (!this.perEvent) this.perEvent = {};
    this.perEvent[event] = val;
    this.saveSettings();
  }
  isInQuietHours() {
    if (!this.quietHours) return false;
    const now = /* @__PURE__ */ new Date();
    const h = now.getHours();
    const m = now.getMinutes();
    const current = h * 60 + m;
    const [sh, sm] = this.quietHours.start.split(":").map(Number);
    const [eh, em] = this.quietHours.end.split(":").map(Number);
    const start = sh * 60 + sm;
    const end = eh * 60 + em;
    if (start <= end) return current >= start && current < end;
    return current >= start || current < end;
  }
  _getAudioContext() {
    if (!this.audioContext) {
      this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
    }
    return this.audioContext;
  }
  _playTone(config) {
    try {
      const ctx = this._getAudioContext();
      const play = /* @__PURE__ */ __name((delay = 0) => {
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = config.type || "sine";
        osc.frequency.value = config.freq;
        gain.gain.value = (config.volume || 0.15) * this.volume;
        if (config.ramp === "up") {
          osc.frequency.setValueAtTime(config.freq * 0.7, ctx.currentTime + delay);
          osc.frequency.linearRampToValueAtTime(config.freq, ctx.currentTime + delay + config.duration);
        } else if (config.ramp === "down") {
          osc.frequency.setValueAtTime(config.freq, ctx.currentTime + delay);
          osc.frequency.linearRampToValueAtTime(config.freq * 0.7, ctx.currentTime + delay + config.duration);
        }
        gain.gain.setValueAtTime((config.volume || 0.15) * this.volume, ctx.currentTime + delay);
        gain.gain.exponentialRampToValueAtTime(1e-3, ctx.currentTime + delay + config.duration);
        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.start(ctx.currentTime + delay);
        osc.stop(ctx.currentTime + delay + config.duration + 0.05);
      }, "play");
      const repeats = config.repeat || 1;
      for (let i = 0; i < repeats; i++) {
        play(i * (config.duration + 0.06));
      }
    } catch (e) {
      console.warn("Sound playback failed:", e);
    }
  }
  async play(eventType) {
    if (!this.enabled) return;
    if (this.isInQuietHours()) return;
    if (this.perEvent && this.perEvent[eventType] === false) return;
    const now = Date.now();
    if (this._cooldowns[eventType] && now - this._cooldowns[eventType] < 150) return;
    this._cooldowns[eventType] = now;
    const url = SOUND_URLS[eventType];
    if (url) {
      try {
        if (!this.audioCache[eventType]) {
          this.audioCache[eventType] = new Audio(url);
        }
        const audio = this.audioCache[eventType].cloneNode();
        audio.volume = this.volume;
        await audio.play();
        return;
      } catch (e) {
      }
    }
    const tone = FALLBACK_TONES[eventType];
    if (tone) this._playTone(tone);
  }
  // Resume audio context (must be called after user gesture)
  resume() {
    if (this.audioContext?.state === "suspended") {
      this.audioContext.resume();
    }
  }
};
__name(_NotificationSoundManager, "NotificationSoundManager");
let NotificationSoundManager = _NotificationSoundManager;
const soundManager = new NotificationSoundManager();
function useChatConnection({
  activeChat,
  username,
  token,
  isAuthenticated,
  isInitialDataLoaded,
  fetchWithAuth,
  scrollToBottom,
  isNearBottom,
  setMessages,
  setIsConnected,
  historyCacheRef,
  setHasMoreMessages,
  setMessageHistoryOffset,
  fetchMessageHistory,
  setShowScrollToBottom,
  API_BASE_URL: API_BASE_URL2,
  API_HOST: API_HOST2,
  WS_PROTOCOL: WS_PROTOCOL2,
  forwardToGlobalContext,
  setGlobalWsConnected,
  setOnlineUsers,
  setVoiceUsersState,
  setAllUsers,
  setCurrentUserProfile,
  activeChatRef,
  tokenRef,
  usernameRef,
  setCategories,
  ROOM_LIST_URL: ROOM_LIST_URL2,
  statusWsRef,
  statusWsReconnectRef,
  logout,
  refreshAccessToken,
  setCurrentTheme
}) {
  const ws = reactExports.useRef(null);
  const { setTypingUser, incrementUnread } = useChatStore();
  const connectWebSocket = reactExports.useCallback(() => {
    if (!activeChat.id || activeChat.type === "welcome" || activeChat.type === "friends" || !username) return;
    if (ws.current && ws.current.readyState === WebSocket.OPEN) {
      const currentWsUrl = ws.current.url;
      const expectedPath = activeChat.type === "room" ? `/ws/chat/${activeChat.id}/` : `/ws/dm/${activeChat.id}/`;
      if (currentWsUrl.includes(expectedPath)) return;
    }
    if (ws.current) ws.current.close(1e3, "change_room");
    let wsUrl = "";
    const params = `?username=${encodeURIComponent(username)}&token=${token}`;
    if (activeChat.type === "room") wsUrl = `${WS_PROTOCOL2}://${API_HOST2}/ws/chat/${activeChat.id}/${params}`;
    else if (activeChat.type === "dm") wsUrl = `${WS_PROTOCOL2}://${API_HOST2}/ws/dm/${activeChat.id}/${params}`;
    if (!wsUrl) return;
    const newWs = new WebSocket(wsUrl);
    ws.current = newWs;
    newWs.onopen = () => setIsConnected(true);
    newWs.onmessage = (event) => {
      const data = JSON.parse(event.data);
      if (data.type === "chat" || data.type === "dm" || data.type === "chat_message_handler") {
        const getCacheKeyFromMessage = /* @__PURE__ */ __name((msgData) => {
          if (msgData.room) return `room-${msgData.room}`;
          if (msgData.conversation) return `dm-${msgData.conversation}`;
          return activeChat.type === "room" ? `room-${activeChat.id}` : `dm-${activeChat.id}`;
        }, "getCacheKeyFromMessage");
        setMessages((prev) => {
          if (data.temp_id) {
            const tempIndex = prev.findIndex((msg) => msg.temp_id === data.temp_id);
            if (tempIndex !== -1) {
              const newMessages = [...prev];
              newMessages[tempIndex] = data;
              const cacheKey2 = getCacheKeyFromMessage(data);
              if (historyCacheRef.current[cacheKey2]) historyCacheRef.current[cacheKey2].messages = newMessages;
              return newMessages;
            }
          }
          if (data.id && prev.some((msg) => msg.id === data.id)) return prev;
          const updatedMessages = [...prev, data];
          const cacheKey = getCacheKeyFromMessage(data);
          if (historyCacheRef.current[cacheKey]) historyCacheRef.current[cacheKey].messages = updatedMessages;
          return updatedMessages;
        });
        setTypingUser(data.username, false);
        if (data.username !== username) {
          try {
            const isMention = data.content?.includes(`@${username}`) || data.mentions?.includes(username);
            const isDM = data.type === "dm";
            if (isMention) soundManager.play("mention");
            else if (isDM) soundManager.play("dm");
            else soundManager.play("message");
          } catch (e) {
          }
        }
        if (isNearBottom()) scrollToBottom("smooth");
        else setShowScrollToBottom(true);
      } else if (data.type === "typing_status_update") {
        if (data.username !== username) setTypingUser(data.username, data.is_typing);
      } else if (data.type === "chat_cleared") {
        setMessages([]);
      }
      if (data.message && data.message.startsWith("[ANNOUNCE] ")) {
        const announcement = data.message.replace("[ANNOUNCE] ", "");
        window.dispatchEvent(new CustomEvent("stickyMessage", {
          detail: { message: announcement, type: "info", author: data.username }
        }));
      }
    };
    newWs.onerror = (error) => console.error("âŒ [WebSocket] Connection error:", error);
    newWs.onclose = () => setIsConnected(false);
  }, [activeChat.id, activeChat.type, username, token]);
  reactExports.useEffect(() => {
    if (!isAuthenticated || !isInitialDataLoaded) return;
    const saved = loadSavedTheme();
    setCurrentTheme(saved);
    const currentToken = tokenRef.current;
    if (!currentToken) return;
    let intentionalClose = false;
    let reconnectAttempts = 0;
    const MAX_RECONNECT_ATTEMPTS = 10;
    const createSocket = /* @__PURE__ */ __name(() => {
      const tok = tokenRef.current || currentToken;
      const currentUser = usernameRef.current || username;
      const url = `${WS_PROTOCOL2}://${API_HOST2}/ws/status/?username=${encodeURIComponent(currentUser)}&token=${tok}`;
      let socket2;
      try {
        socket2 = new WebSocket(url);
      } catch (err) {
        return null;
      }
      socket2.onopen = () => {
        setGlobalWsConnected(true);
        reconnectAttempts = 0;
      };
      socket2.onerror = (error) => console.error("[StatusWS] WebSocket error:", error);
      socket2.onclose = (event) => {
        setGlobalWsConnected(false);
        if (!intentionalClose && event.code !== 1e3 && event.code !== 1001) {
          if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) return;
          reconnectAttempts++;
          const delay = Math.min(5e3 * Math.pow(2, reconnectAttempts - 1), 6e4);
          statusWsReconnectRef.current = setTimeout(() => {
            if (!intentionalClose) {
              const newSocket = createSocket();
              if (newSocket) statusWsRef.current = newSocket;
            }
          }, delay);
        }
      };
      socket2.onmessage = (e) => {
        try {
          const data = JSON.parse(e.data);
          forwardToGlobalContext(data);
          if (data.type === "online_user_list_update") {
            const onlineUsernames = Array.isArray(data.users) ? data.users.map((u) => typeof u === "string" ? u : u.username || u) : [];
            setOnlineUsers(onlineUsernames);
          }
          if (data.type === "voice_users_update") setVoiceUsersState(data.voice_users);
          if (data.type === "user_activity_update") {
            setAllUsers((prevUsers) => prevUsers.map(
              (u) => u.username === data.username ? { ...u, current_activity: data.activity } : u
            ));
          }
          if (data.type === "user_profile_update" && data.user_data) {
            const updatedUser = data.user_data;
            if (updatedUser.username === username) {
              setCurrentUserProfile((prevProfile) => ({
                ...prevProfile,
                avatar: updatedUser.avatar,
                status_message: updatedUser.status_message,
                social_links: updatedUser.social_links,
                coins: updatedUser.coins,
                xp: updatedUser.xp,
                level: updatedUser.level,
                status: updatedUser.status,
                role: updatedUser.role
              }));
            }
            setAllUsers((prevUsers) => prevUsers.map(
              (u) => u.username === updatedUser.username ? { ...u, ...updatedUser } : u
            ));
          }
          if (data.type === "global_message_notification" && data.username !== username) {
            const key = data.room_slug ? `room-${data.room_slug}` : `dm-${data.conversation_id}`;
            const chat2 = activeChatRef.current;
            const currentKey = chat2.type === "room" ? `room-${chat2.id}` : `dm-${chat2.id}`;
            if (key !== currentKey) incrementUnread(key);
          }
          if (data.type === "server_structure_update") {
            if (data.categories && Array.isArray(data.categories)) {
              setCategories(data.categories);
            } else {
              fetchWithAuth(ROOM_LIST_URL2).then((r) => r.json()).then((rooms) => setCategories(rooms)).catch(console.error);
            }
          }
        } catch (parseError) {
          console.error("[StatusWS] Failed to parse message:", parseError);
        }
      };
      return socket2;
    }, "createSocket");
    const socket = createSocket();
    if (socket) statusWsRef.current = socket;
    return () => {
      intentionalClose = true;
      clearTimeout(statusWsReconnectRef.current);
      try {
        if (statusWsRef.current) statusWsRef.current.close(1e3, "Component unmount");
      } catch (e) {
      }
    };
  }, [isAuthenticated, isInitialDataLoaded]);
  reactExports.useEffect(() => {
    if (!isInitialDataLoaded || !activeChat.id || activeChat.type === "friends" || activeChat.type === "welcome" || activeChat.type === "server") return;
    let isCancelled = false;
    const key = activeChat.type === "room" ? `room-${activeChat.id}` : `dm-${activeChat.id}`;
    const cached = historyCacheRef.current[key];
    if (cached?.messages?.length > 0) {
      setMessages(cached.messages);
      setHasMoreMessages(!!cached.hasMore);
      setMessageHistoryOffset(cached.offset || 0);
      setTimeout(() => {
        if (!isCancelled) scrollToBottom("auto");
      }, 50);
      if (!isCancelled) connectWebSocket();
    } else {
      setMessageHistoryOffset(0);
      setHasMoreMessages(true);
      if (!isCancelled) connectWebSocket();
      setTimeout(() => {
        if (!isCancelled) fetchMessageHistory(true, 0);
      }, 50);
    }
    return () => {
      isCancelled = true;
    };
  }, [activeChat.id, activeChat.type, isInitialDataLoaded, connectWebSocket]);
  return { ws, connectWebSocket };
}
__name(useChatConnection, "useChatConnection");
const PREFIX = "ENC::";
const encryptMessage = /* @__PURE__ */ __name((text, secretKey) => {
  if (!text || !secretKey) return text;
  try {
    const encrypted = CryptoJS.AES.encrypt(text, secretKey).toString();
    return PREFIX + encrypted;
  } catch (e) {
    console.error("Åžifreleme hatasÄ±:", e);
    return text;
  }
}, "encryptMessage");
const decryptMessage = /* @__PURE__ */ __name((cipherText, secretKey) => {
  if (!cipherText || !cipherText.startsWith(PREFIX) || !secretKey) return cipherText;
  try {
    const rawCipher = cipherText.replace(PREFIX, "");
    const bytes = CryptoJS.AES.decrypt(rawCipher, secretKey);
    const originalText = bytes.toString(CryptoJS.enc.Utf8);
    if (!originalText) return "ðŸ”’ Åžifreli Mesaj (Anahtar YanlÄ±ÅŸ)";
    return originalText;
  } catch (e) {
    console.error("Åžifre Ã§Ã¶zme hatasÄ±:", e);
    return "ðŸ”’ Ã‡Ã¶zÃ¼lemedi";
  }
}, "decryptMessage");
const isEncrypted = /* @__PURE__ */ __name((text) => {
  return text && typeof text === "string" && text.startsWith(PREFIX);
}, "isEncrypted");
function useMessageHandlers({
  activeChat,
  username,
  token,
  ws,
  encryptionKeys,
  setMessages,
  scrollToBottom,
  isNearBottom,
  setEditingMessage,
  setHasDraftMessage,
  setDraftText,
  persistDraft,
  setStickyMessage,
  richTextRef,
  fetchWithAuth,
  currentUserProfile,
  getDeterministicAvatar,
  historyCacheRef,
  setHasMoreMessages,
  setMessageHistoryOffset,
  setIsSummaryLoading,
  setSummaryResult,
  setPinnedMessages,
  setConversations,
  setMessageHistoryLoading,
  openModal,
  closeModal,
  API_BASE_URL: API_BASE_URL2,
  MESSAGE_HISTORY_ROOM_URL: MESSAGE_HISTORY_ROOM_URL2,
  MESSAGE_HISTORY_DM_URL: MESSAGE_HISTORY_DM_URL2
}) {
  const readReceiptBufferRef = reactExports.useRef([]);
  const readReceiptTimerRef = reactExports.useRef(null);
  const sendMessage = reactExports.useCallback((content) => {
    if (!content) return;
    const trimmed = content.trim();
    if (!trimmed) return;
    if (trimmed === "/tema") {
      openModal("themeStore");
      setEditingMessage(null);
      setHasDraftMessage(false);
      setDraftText("");
      richTextRef.current?.clear?.();
      return;
    }
    if (trimmed === "/sablon") {
      openModal("templateModal");
      setEditingMessage(null);
      setHasDraftMessage(false);
      setDraftText("");
      richTextRef.current?.clear?.();
      return;
    }
    if (trimmed.startsWith("/duyuru ")) {
      const announcement = trimmed.slice(8).trim();
      if (announcement) {
        const payload2 = {
          type: activeChat.type === "room" ? "chat_message" : "dm_message",
          message: `[ANNOUNCE] ${announcement}`,
          username,
          temp_id: getTemporaryId(),
          ...activeChat.type === "room" ? { room: activeChat.id } : { conversation: activeChat.id }
        };
        ws.current?.send(JSON.stringify(payload2));
        setStickyMessage({ message: announcement, type: "info", author: username });
        setEditingMessage(null);
        setHasDraftMessage(false);
        setDraftText("");
        richTextRef.current?.clear?.();
        return;
      }
    }
    setEditingMessage(null);
    setHasDraftMessage(false);
    setDraftText("");
    persistDraft("");
    const currentChatId = activeChat.type === "room" ? `room-${activeChat.id}` : `dm-${activeChat.id}`;
    const secretKey = encryptionKeys[currentChatId];
    let finalContent = trimmed;
    if (activeChat.type === "dm" && secretKey) finalContent = encryptMessage(trimmed, secretKey);
    const payload = {
      type: activeChat.type === "room" ? "chat_message" : "dm_message",
      message: finalContent,
      username,
      temp_id: getTemporaryId(),
      ...activeChat.type === "room" ? { room: activeChat.id } : { conversation: activeChat.id }
    };
    const jsonPayload = JSON.stringify(payload);
    const sendViaWebSocket = /* @__PURE__ */ __name(async () => {
      const maxWait = 3e3;
      const checkInterval = 100;
      let waited = 0;
      while (ws.current && ws.current.readyState === WebSocket.CONNECTING && waited < maxWait) {
        await new Promise((resolve) => setTimeout(resolve, checkInterval));
        waited += checkInterval;
      }
      if (ws.current && ws.current.readyState === WebSocket.OPEN) {
        try {
          ws.current.send(jsonPayload);
          return true;
        } catch (error) {
          return false;
        }
      }
      return false;
    }, "sendViaWebSocket");
    const sendViaHTTP = /* @__PURE__ */ __name(async () => {
      try {
        const endpoint = activeChat.type === "dm" ? `${API_BASE_URL2}/messages/send_dm/` : `${API_BASE_URL2}/messages/send/`;
        const httpPayload = activeChat.type === "dm" ? { conversation_id: activeChat.id, content: finalContent } : { room: activeChat.id, content: finalContent };
        const response = await fetchWithAuth(endpoint, { method: "POST", body: JSON.stringify(httpPayload) });
        return response.ok;
      } catch (error) {
        return false;
      }
    }, "sendViaHTTP");
    (async () => {
      const wsSent = await sendViaWebSocket();
      if (!wsSent) await sendViaHTTP();
    })();
    setMessages((prev) => {
      const newMessage = {
        ...payload,
        content: finalContent,
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        id: payload.temp_id,
        avatar: currentUserProfile?.avatar || getDeterministicAvatar(username)
      };
      const updatedMessages = [...prev, newMessage];
      const cacheKey = activeChat.type === "room" ? `room-${activeChat.id}` : `dm-${activeChat.id}`;
      if (historyCacheRef.current[cacheKey]) historyCacheRef.current[cacheKey].messages = updatedMessages;
      return updatedMessages;
    });
    richTextRef.current?.clear?.();
    scrollToBottom("smooth");
  }, [activeChat, username, encryptionKeys, ws, fetchWithAuth, currentUserProfile, getDeterministicAvatar, persistDraft]);
  const handleSendSnippet = reactExports.useCallback((data) => {
    const payload = {
      type: activeChat.type === "room" ? "chat_message" : "dm_message",
      message: "",
      username,
      temp_id: getTemporaryId(),
      snippet_data: data,
      ...activeChat.type === "room" ? { room: activeChat.id } : { conversation: activeChat.id }
    };
    ws.current?.send(JSON.stringify(payload));
    setMessages((prev) => [...prev, {
      ...payload,
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      id: payload.temp_id,
      avatar: currentUserProfile?.avatar || getDeterministicAvatar(username)
    }]);
    closeModal("snippetModal");
  }, [activeChat, username, ws, currentUserProfile, getDeterministicAvatar]);
  const fetchMessageHistory = reactExports.useCallback(async (isInitial = true, offset = 0) => {
    if (!activeChat.id) return;
    if (activeChat.type === "voice") {
      setMessages([]);
      setHasMoreMessages(false);
      return;
    }
    setMessageHistoryLoading(true);
    const urlBase = activeChat.type === "room" ? MESSAGE_HISTORY_ROOM_URL2 : MESSAGE_HISTORY_DM_URL2;
    const key = activeChat.type === "room" ? `room-${activeChat.id}` : `dm-${activeChat.id}`;
    try {
      const res = await fetchWithAuth(`${urlBase}${activeChat.id}/?limit=50&offset=${offset}`);
      if (res.ok) {
        const data = await res.json();
        const rawMessages = data.results || [];
        const validMessages = rawMessages.filter((msg) => msg && typeof msg === "object" && (msg.id || msg.temp_id));
        const newMsgs = validMessages.reverse();
        let combinedMessages = newMsgs;
        if (isInitial) {
          setMessages(newMsgs);
          setTimeout(() => scrollToBottom("auto"), 100);
        } else {
          setMessages((prev) => {
            combinedMessages = [...newMsgs, ...prev];
            return combinedMessages;
          });
        }
        const nextOffset = isInitial ? newMsgs.length : offset + newMsgs.length;
        const hasMore = !!data.next;
        setHasMoreMessages(hasMore);
        if (!isInitial) setMessageHistoryOffset(nextOffset);
        const cachedExisting = historyCacheRef.current[key]?.messages || [];
        const cachedCombined = isInitial ? newMsgs : [...newMsgs, ...cachedExisting];
        historyCacheRef.current[key] = { messages: combinedMessages || cachedCombined, offset: nextOffset, hasMore };
      }
    } catch (e) {
      console.error("âŒ [fetchMessageHistory] Error:", e);
    }
    setMessageHistoryLoading(false);
  }, [activeChat, fetchWithAuth, scrollToBottom]);
  const handleDeleteMessage = reactExports.useCallback(async (messageId) => {
    if (!await confirmDialog("Bu mesajÄ± silmek istediÄŸine emin misin?")) return;
    try {
      const res = await fetchWithAuth(`${API_BASE_URL2}/messages/${messageId}/delete/`, { method: "DELETE" });
      if (res.ok) setMessages((prev) => prev.filter((m) => m.id !== messageId));
    } catch (e) {
      console.error(e);
    }
  }, [fetchWithAuth, API_BASE_URL2]);
  const handleTogglePin = reactExports.useCallback(async (messageId) => {
    try {
      const res = await fetchWithAuth(`${API_BASE_URL2}/messages/${messageId}/pin/`, { method: "POST" });
      if (res.ok) {
        const data = await res.json();
        const isPinned = data.is_pinned ?? data.pinned ?? true;
        setMessages((prev) => prev.map((m) => m.id === messageId ? { ...m, is_pinned: isPinned } : m));
        if (isPinned) {
          setPinnedMessages((prev) => {
            const msg = prev.find((p) => p.id === messageId);
            if (!msg) return prev;
            return prev;
          });
          toast.success("ðŸ“Œ Mesaj sabitlendi");
        } else {
          setPinnedMessages((prev) => prev.filter((p) => p.id !== messageId));
          toast.success("ðŸ“Œ Sabitleme kaldÄ±rÄ±ldÄ±");
        }
      }
    } catch (e) {
      console.error("Pin toggle error:", e);
      toast.error("âŒ Sabitleme hatasÄ±");
    }
  }, [fetchWithAuth, API_BASE_URL2]);
  const handleSearchMessages = reactExports.useCallback(async (e, debouncedSearchQuery) => {
    e.preventDefault();
    if (!activeChat.id || !debouncedSearchQuery.trim()) {
      if (!debouncedSearchQuery.trim()) fetchMessageHistory(true, 0);
      return;
    }
    setMessageHistoryLoading(true);
    try {
      let url = `${API_BASE_URL2}/messages/search/?q=${encodeURIComponent(debouncedSearchQuery)}`;
      if (activeChat.type === "room") url += `&room=${activeChat.id}`;
      else url += `&dm=${activeChat.id}`;
      const res = await fetchWithAuth(url);
      if (res.ok) {
        const data = await res.json();
        setMessages(data.results || data);
      }
    } catch (e2) {
      console.error(e2);
    }
    setMessageHistoryLoading(false);
  }, [activeChat, fetchWithAuth, fetchMessageHistory]);
  const handleSummarize = reactExports.useCallback(async () => {
    openModal("summary");
    setIsSummaryLoading(true);
    setSummaryResult("");
    try {
      const res = await fetchWithAuth(`${API_BASE_URL2}/rooms/${activeChat.id}/summarize/`, { method: "POST" });
      const data = await res.json();
      setSummaryResult(res.ok ? data.summary : "Hata: " + data.error);
    } catch (e) {
      setSummaryResult("BaÄŸlantÄ± hatasÄ±.");
    }
    setIsSummaryLoading(false);
  }, [activeChat, fetchWithAuth]);
  const handleClearChat = reactExports.useCallback(async () => {
    if (!await confirmDialog("Bu odadaki tÃ¼m mesajlarÄ± silmek istediÄŸine emin misin?")) return;
    try {
      const res = await fetchWithAuth(`${API_BASE_URL2}/rooms/${activeChat.id}/clear/`, { method: "POST" });
      if (res.ok) setMessages([]);
    } catch (e) {
      console.error(e);
    }
  }, [activeChat, fetchWithAuth]);
  const handleHideConversation = reactExports.useCallback(async (conversationId) => {
    if (!await confirmDialog("Bu sohbeti listenizden gizlemek istiyor musunuz?")) return;
    try {
      const res = await fetchWithAuth(`${API_BASE_URL2}/conversations/${conversationId}/hide/`, { method: "POST" });
      if (res.ok) {
        setConversations((prev) => prev.filter((c) => c.id !== conversationId));
        if (activeChat.type === "dm" && activeChat.id === conversationId) window.dispatchEvent(new CustomEvent("setActiveChatWelcome"));
      }
    } catch (e) {
      console.error(e);
    }
  }, [activeChat, fetchWithAuth]);
  const handleAdminDeleteConversation = reactExports.useCallback(async (conversationId) => {
    if (!await confirmDialog("âš ï¸ ADMÄ°N: Bu konuÅŸmayÄ± HER Ä°KÄ° TARAFTAN KALICI OLARAK silmek istediÄŸinize emin misiniz?\n\nBu iÅŸlem GERÄ° ALINAMAZ!")) return;
    try {
      const res = await fetchWithAuth(`${API_BASE_URL2}/conversations/${conversationId}/admin-delete/`, { method: "DELETE" });
      if (res.ok) {
        const data = await res.json();
        toast.success(`âœ… ${data.deleted_messages} mesaj silindi. KatÄ±lÄ±mcÄ±lar: ${data.participants.join(", ")}`);
        setConversations((prev) => prev.filter((c) => c.id !== conversationId));
        if (activeChat.type === "dm" && activeChat.id === conversationId) window.dispatchEvent(new CustomEvent("setActiveChatWelcome"));
      } else {
        const errorData = await res.json();
        toast.error(`âŒ Hata: ${errorData.error || "Silme iÅŸlemi baÅŸarÄ±sÄ±z"}`);
      }
    } catch (e) {
      console.error(e);
      toast.error("âŒ Sunucuyla baÄŸlantÄ± hatasÄ±");
    }
  }, [activeChat, fetchWithAuth]);
  const handleMessageVisible = reactExports.useCallback((messageId) => {
    readReceiptBufferRef.current.push(messageId);
    if (readReceiptTimerRef.current) return;
    readReceiptTimerRef.current = setTimeout(async () => {
      const ids = [...new Set(readReceiptBufferRef.current)];
      readReceiptBufferRef.current = [];
      readReceiptTimerRef.current = null;
      if (ids.length === 0) return;
      try {
        const res = await fetchWithAuth(`${API_BASE_URL2}/messages/mark_read/`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ message_ids: ids })
        });
        if (res.ok) {
          setMessages((prev) => prev.map(
            (m) => ids.includes(m.id) ? { ...m, read_by: [...m.read_by || [], username] } : m
          ));
        }
      } catch (e) {
      }
    }, 1500);
  }, [fetchWithAuth, username]);
  const scrollToMessage = reactExports.useCallback((msgId) => {
    const el = document.getElementById(`message-${msgId}`);
    if (el) el.scrollIntoView({ behavior: "smooth", block: "center" });
  }, []);
  return {
    sendMessage,
    handleSendSnippet,
    fetchMessageHistory,
    handleDeleteMessage,
    handleTogglePin,
    handleSearchMessages,
    handleSummarize,
    handleClearChat,
    handleHideConversation,
    handleAdminDeleteConversation,
    handleMessageVisible,
    scrollToMessage
  };
}
__name(useMessageHandlers, "useMessageHandlers");
function useFileUpload({
  activeChat,
  username,
  fetchWithAuth,
  scrollToBottom,
  setMessages,
  API_BASE_URL: API_BASE_URL2,
  handleDMClick,
  conversations,
  categories
}) {
  const [isDragging, setIsDragging] = reactExports.useState(false);
  const [isUploading, setIsUploading] = reactExports.useState(false);
  const [uploadProgress, setUploadProgress] = reactExports.useState(0);
  const [pendingFilesFromDrop, setPendingFilesFromDrop] = reactExports.useState([]);
  const [isRecordingVoice, setIsRecordingVoice] = reactExports.useState(false);
  const mediaRecorderRef = reactExports.useRef(null);
  const audioChunksRef = reactExports.useRef([]);
  const dragCounterRef = reactExports.useRef(0);
  const uploadFile = reactExports.useCallback(async (file, isVoice = false, duration = 0, targetOverride = null) => {
    const showProgress = file.size >= 5 * 1024 * 1024;
    if (showProgress) {
      setIsUploading(true);
      setUploadProgress(0);
    }
    const target = targetOverride || activeChat;
    const tempId = getTemporaryId();
    try {
      const hash2 = await calculateFileHash(file);
      const contentType = file.type || "application/octet-stream";
      const CHUNK_SIZE = 10 * 1024 * 1024;
      const PARALLEL_UPLOADS = 5;
      const totalParts = Math.ceil(file.size / CHUNK_SIZE);
      const initRes = await fetchWithAuth(`${API_BASE_URL2}/upload/multipart/init/`, {
        method: "POST",
        body: JSON.stringify({
          file_name: file.name,
          file_size: file.size,
          content_type: contentType,
          file_hash: hash2,
          room_slug: target.type === "room" ? target.id : null,
          conversation_id: target.type === "dm" ? target.id : null,
          temp_id: tempId,
          is_voice_message: isVoice ? "true" : "false",
          duration: duration.toString()
        })
      });
      const initData = await initRes.json();
      if (initData.file_exists) {
        if (showProgress) {
          setIsUploading(false);
          setUploadProgress(100);
        }
        if (initData.id && target.id === activeChat.id) {
          setMessages((prev) => {
            if (initData.temp_id) {
              const idx = prev.findIndex((msg) => msg.temp_id === initData.temp_id);
              if (idx !== -1) {
                const n = [...prev];
                n[idx] = initData;
                return n;
              }
            }
            if (prev.some((msg) => msg.id === initData.id)) return prev;
            return [...prev, initData];
          });
          scrollToBottom("smooth");
        }
        return;
      }
      const { upload_id, key } = initData;
      const parts = [];
      let completedParts = 0;
      const uploadPart = /* @__PURE__ */ __name(async (partNumber) => {
        const start = (partNumber - 1) * CHUNK_SIZE;
        const end = Math.min(start + CHUNK_SIZE, file.size);
        const chunk = file.slice(start, end);
        const formData = new FormData();
        formData.append("upload_id", upload_id);
        formData.append("key", key);
        formData.append("part_number", partNumber.toString());
        formData.append("chunk", chunk, `part_${partNumber}`);
        const uploadRes = await fetchWithAuth(`${API_BASE_URL2}/upload/multipart/upload-part/`, {
          method: "POST",
          body: formData,
          headers: {}
        });
        if (!uploadRes.ok) throw new Error(`Part ${partNumber} upload failed`);
        const { etag, part_number } = await uploadRes.json();
        completedParts++;
        if (showProgress) setUploadProgress(Math.round(completedParts / totalParts * 95));
        return { ETag: etag, PartNumber: part_number };
      }, "uploadPart");
      for (let i = 0; i < totalParts; i += PARALLEL_UPLOADS) {
        const batch = [];
        for (let j = 0; j < PARALLEL_UPLOADS && i + j < totalParts; j++) batch.push(uploadPart(i + j + 1));
        const batchResults = await Promise.all(batch);
        parts.push(...batchResults);
      }
      parts.sort((a, b) => a.PartNumber - b.PartNumber);
      const completeRes = await fetchWithAuth(`${API_BASE_URL2}/upload/multipart/complete/`, {
        method: "POST",
        body: JSON.stringify({
          upload_id,
          key,
          parts,
          file_name: file.name,
          file_hash: hash2,
          room_slug: target.type === "room" ? target.id : null,
          conversation_id: target.type === "dm" ? target.id : null,
          temp_id: tempId,
          is_voice_message: isVoice ? "true" : "false",
          duration: duration.toString()
        })
      });
      if (!completeRes.ok) throw new Error(`Complete failed: ${await completeRes.text()}`);
      const data = await completeRes.json();
      if (showProgress) setUploadProgress(100);
      if (target.id === activeChat.id) {
        setMessages((prev) => {
          if (data.temp_id) {
            const idx = prev.findIndex((msg) => msg.temp_id === data.temp_id);
            if (idx !== -1) {
              const n = [...prev];
              n[idx] = data;
              return n;
            }
          }
          if (data.id && prev.some((msg) => msg.id === data.id)) return prev;
          return [...prev, data];
        });
        scrollToBottom("smooth");
      }
    } catch (e) {
      console.error("âŒ [R2 Multipart] Error:", e);
      toast.error(`YÃ¼kleme hatasÄ±: ${e.message}`);
    }
    if (showProgress) setIsUploading(false);
  }, [activeChat, fetchWithAuth]);
  const startVoiceRecording = reactExports.useCallback(async () => {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      const options = { mimeType: "audio/webm;codecs=opus" };
      if (!MediaRecorder.isTypeSupported(options.mimeType)) options.mimeType = "audio/webm";
      mediaRecorderRef.current = new MediaRecorder(stream, options);
      audioChunksRef.current = [];
      mediaRecorderRef.current.ondataavailable = (e) => {
        if (e.data.size > 0) audioChunksRef.current.push(e.data);
      };
      mediaRecorderRef.current.onstop = async () => {
        const audioBlob = new Blob(audioChunksRef.current, { type: "audio/webm;codecs=opus" });
        await sendVoiceMessage(audioBlob);
        stream.getTracks().forEach((track) => track.stop());
      };
      mediaRecorderRef.current.start();
      setIsRecordingVoice(true);
    } catch (error) {
      console.error("Error starting voice recording:", error);
      if (error.name === "NotAllowedError") toast.warning("Mikrofon eriÅŸimi reddedildi!");
      else if (error.name === "NotFoundError") toast.warning("Mikrofon bulunamadÄ±!");
      else toast.error("Mikrofon hatasÄ±: " + error.message);
    }
  }, []);
  const stopVoiceRecording = reactExports.useCallback(() => {
    if (mediaRecorderRef.current && isRecordingVoice) {
      mediaRecorderRef.current.stop();
      setIsRecordingVoice(false);
    }
  }, [isRecordingVoice]);
  const sendVoiceMessage = reactExports.useCallback(async (audioBlob) => {
    const fileName = `voice_${Date.now()}.webm`;
    const uploadId = `upload_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const formData = new FormData();
    formData.append("chunk", audioBlob);
    formData.append("upload_id", uploadId);
    formData.append("chunk_index", "0");
    formData.append("total_chunks", "1");
    formData.append("file_name", fileName);
    formData.append("is_voice_message", "true");
    if (activeChat.type === "room") formData.append("room_slug", activeChat.id);
    else if (activeChat.type === "dm") formData.append("conversation_id", activeChat.id);
    try {
      const response = await fetchWithAuth(`${API_BASE_URL2}/messages/upload_file/`, { method: "POST", body: formData });
      if (!response.ok) throw new Error("Upload failed");
    } catch (error) {
      console.error("Error uploading voice message:", error);
      toast.error("Ses mesajÄ± gÃ¶nderilemedi");
    }
  }, [activeChat, fetchWithAuth]);
  const handleChatDrop = reactExports.useCallback((e) => {
    e.preventDefault();
    e.stopPropagation();
    dragCounterRef.current = 0;
    setIsDragging(false);
    if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
      const files = Array.from(e.dataTransfer.files);
      const processedFiles = files.map((file) => ({
        id: `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
        file,
        name: file.name,
        size: file.size,
        type: file.type,
        previewUrl: file.type.startsWith("image/") || file.type.startsWith("video/") ? URL.createObjectURL(file) : null
      }));
      setPendingFilesFromDrop(processedFiles);
    }
  }, []);
  const handleChatDragEnter = reactExports.useCallback((e) => {
    e.preventDefault();
    dragCounterRef.current++;
    setIsDragging(true);
  }, []);
  const handleChatDragLeave = reactExports.useCallback((e) => {
    e.preventDefault();
    dragCounterRef.current--;
    if (dragCounterRef.current <= 0) {
      dragCounterRef.current = 0;
      setIsDragging(false);
    }
  }, []);
  return {
    isDragging,
    setIsDragging,
    isUploading,
    uploadProgress,
    pendingFilesFromDrop,
    setPendingFilesFromDrop,
    isRecordingVoice,
    uploadFile,
    startVoiceRecording,
    stopVoiceRecording,
    handleChatDrop,
    handleChatDragEnter,
    handleChatDragLeave,
    dragCounterRef
  };
}
__name(useFileUpload, "useFileUpload");
function useServerHandlers({
  username,
  fetchWithAuth,
  categories,
  allUsers,
  friendsList,
  serverMembers,
  isAdmin,
  currentVoiceRoom,
  setUpdateStatusText,
  setFriendsList,
  setInviteToServerUser,
  API_BASE_URL: API_BASE_URL2,
  handleDMClick,
  isInVoice,
  setServerOrder,
  serverOrder,
  setActiveChat,
  setCurrentUserProfile,
  setCategories,
  setConversations,
  setAllUsers,
  setIsInitialDataLoaded,
  setAuthError,
  login,
  logout,
  setViewingProfile,
  ABSOLUTE_HOST_URL: ABSOLUTE_HOST_URL2,
  ROOM_LIST_URL: ROOM_LIST_URL2
}) {
  const [serverToEdit, setServerToEdit] = reactExports.useState(null);
  const saveServerOrder = reactExports.useCallback(async (newOrder) => {
    try {
      await fetchWithAuth(`${API_BASE_URL2}/user/server-order/update/`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ server_order: newOrder })
      });
    } catch (error) {
      console.error("Server order save error:", error);
    }
  }, [fetchWithAuth]);
  const handleServerDragStart = reactExports.useCallback((e, serverId, index) => {
    e.dataTransfer.effectAllowed = "move";
    e.dataTransfer.setData("serverId", serverId.toString());
    e.dataTransfer.setData("sourceIndex", index.toString());
    const dragElement = e.currentTarget.cloneNode(true);
    dragElement.style.position = "absolute";
    dragElement.style.top = "-9999px";
    dragElement.style.opacity = "0.8";
    dragElement.style.transform = "rotate(5deg)";
    dragElement.style.pointerEvents = "none";
    document.body.appendChild(dragElement);
    e.dataTransfer.setDragImage(dragElement, 24, 24);
    setTimeout(() => {
      if (document.body.contains(dragElement)) document.body.removeChild(dragElement);
    }, 0);
    e.currentTarget.style.opacity = "0.4";
  }, []);
  const handleServerDragOver = reactExports.useCallback((e) => {
    e.preventDefault();
    e.dataTransfer.dropEffect = "move";
  }, []);
  const handleServerDragEnd = reactExports.useCallback((e) => {
    e.currentTarget.style.opacity = "1";
  }, []);
  const handleMoveServer = reactExports.useCallback((serverId, direction) => {
    let currentOrder = serverOrder.length > 0 ? [...serverOrder] : categories.map((c) => c.id);
    categories.forEach((c) => {
      if (!currentOrder.includes(c.id)) currentOrder.push(c.id);
    });
    const sourceIndex = currentOrder.indexOf(serverId);
    if (sourceIndex === -1) return;
    const targetIndex = direction === "up" ? sourceIndex - 1 : sourceIndex + 1;
    if (targetIndex < 0 || targetIndex >= currentOrder.length) return;
    const [draggedId] = currentOrder.splice(sourceIndex, 1);
    currentOrder.splice(targetIndex, 0, draggedId);
    setServerOrder(currentOrder);
    saveServerOrder(currentOrder);
  }, [serverOrder, categories, saveServerOrder]);
  const handleServerDrop = reactExports.useCallback((e, targetIndex) => {
    e.preventDefault();
    const serverId = parseInt(e.dataTransfer.getData("serverId"));
    if (isNaN(serverId)) return;
    let currentOrder = serverOrder.length > 0 ? [...serverOrder] : categories.map((c) => c.id);
    categories.forEach((c) => {
      if (!currentOrder.includes(c.id)) currentOrder.push(c.id);
    });
    const sourceIndex = currentOrder.indexOf(serverId);
    if (sourceIndex === -1) return;
    if (sourceIndex === targetIndex || sourceIndex + 1 === targetIndex) return;
    const [draggedId] = currentOrder.splice(sourceIndex, 1);
    const adjustedTargetIndex = sourceIndex < targetIndex ? targetIndex - 1 : targetIndex;
    currentOrder.splice(adjustedTargetIndex, 0, draggedId);
    setServerOrder(currentOrder);
    saveServerOrder(currentOrder);
  }, [serverOrder, categories, saveServerOrder]);
  const handleLogin = reactExports.useCallback(async (u, p) => {
    try {
      const LOGIN_URL = `${API_BASE_URL2}/auth/login/`;
      const res = await fetch(LOGIN_URL, {
        method: "POST",
        body: JSON.stringify({ username: u, password: p }),
        headers: { "Content-Type": "application/json" }
      });
      const data = await res.json();
      if (res.ok) {
        login(data.access, data.refresh);
      } else {
        if (res.status === 401 && data.requires_2fa && data.temp_token) {
          window.location.href = `/#/2fa-login?temp_token=${encodeURIComponent(data.temp_token)}`;
          return;
        }
        if (res.status === 401) setAuthError("KullanÄ±cÄ± adÄ± veya ÅŸifre hatalÄ±");
        else if (res.status === 400) setAuthError(data.detail || data.error || "GeÃ§ersiz giriÅŸ bilgileri");
        else if (res.status >= 500) setAuthError("Sunucu hatasÄ±. LÃ¼tfen daha sonra tekrar deneyin.");
        else setAuthError(data.detail || data.error || "GiriÅŸ baÅŸarÄ±sÄ±z");
      }
    } catch (e) {
      console.error("âŒ [Auth] Network error:", e);
      setAuthError("Sunucuya baÄŸlanÄ±lamadÄ±. Ä°nternet baÄŸlantÄ±nÄ±zÄ± kontrol edin.");
    }
  }, [login, setAuthError, API_BASE_URL2]);
  const handleRegister = reactExports.useCallback(async (u, e, p) => {
    try {
      const REGISTER_URL = `${API_BASE_URL2}/auth/register/`;
      const res = await fetch(REGISTER_URL, {
        method: "POST",
        body: JSON.stringify({ username: u, email: e, password: p }),
        headers: { "Content-Type": "application/json" }
      });
      if (res.status === 201) return true;
      const data = await res.json();
      let errorMessage = "";
      if (data.username) errorMessage = data.username.join(" ");
      else if (data.email) errorMessage = data.email.join(" ");
      else if (data.password) errorMessage = data.password.join(" ");
      else if (data.detail) errorMessage = data.detail;
      else errorMessage = Object.values(data).flat().join(" ");
      setAuthError(errorMessage || "KayÄ±t iÅŸlemi baÅŸarÄ±sÄ±z");
      return false;
    } catch (err) {
      console.error("âŒ [Auth] Network error:", err);
      setAuthError("Sunucuya baÄŸlanÄ±lamadÄ±. Ä°nternet baÄŸlantÄ±nÄ±zÄ± kontrol edin.");
      return false;
    }
  }, [setAuthError, API_BASE_URL2]);
  const handleUserContextAction = reactExports.useCallback(async (action, user, extraData) => {
    switch (action) {
      case "profile": {
        const userProfile = allUsers.find((u) => u.username === user.username);
        if (userProfile) setViewingProfile(userProfile);
        break;
      }
      case "message":
        handleDMClick(user.username);
        break;
      case "volume":
        break;
      case "move":
        if (isAdmin && extraData && currentVoiceRoom) {
          try {
            await fetchWithAuth(`${API_BASE_URL2}/voice/move_user/`, {
              method: "POST",
              body: JSON.stringify({ username: user.username, from_channel: currentVoiceRoom, to_channel: extraData })
            });
          } catch (e) {
            console.error("Move user error:", e);
          }
        }
        break;
      case "kick":
        if (isAdmin && await confirmDialog(`${user.username} kullanÄ±cÄ±sÄ±nÄ± kanaldan atmak istediÄŸine emin misin?`)) {
          try {
            await fetchWithAuth(`${API_BASE_URL2}/voice/kick_user/`, {
              method: "POST",
              body: JSON.stringify({ username: user.username, room: currentVoiceRoom })
            });
          } catch (e) {
            console.error("Kick user error:", e);
          }
        }
        break;
      case "server_mute":
        if (isAdmin) {
          try {
            await fetchWithAuth(`${API_BASE_URL2}/voice/server_mute/`, {
              method: "POST",
              body: JSON.stringify({ username: user.username, room: currentVoiceRoom })
            });
          } catch (e) {
            console.error("Server mute error:", e);
          }
        }
        break;
      case "add_friend":
        try {
          const res = await fetchWithAuth(`${API_BASE_URL2}/friends/send/`, {
            method: "POST",
            body: JSON.stringify({ username: user.username })
          });
          if (res.ok) {
            setUpdateStatusText(`âœ… ${user.username} kullanÄ±cÄ±sÄ±na arkadaÅŸlÄ±k isteÄŸi gÃ¶nderildi!`);
            setTimeout(() => setUpdateStatusText(""), 3e3);
          } else {
            const data = await res.json();
            setUpdateStatusText(`âŒ ${data.error || "Ä°stek gÃ¶nderilemedi"}`);
            setTimeout(() => setUpdateStatusText(""), 3e3);
          }
        } catch (e) {
          setUpdateStatusText("âŒ ArkadaÅŸ ekleme hatasÄ±");
          setTimeout(() => setUpdateStatusText(""), 3e3);
        }
        break;
      case "remove_friend":
        if (await confirmDialog(`${user.username} ile arkadaÅŸlÄ±ÄŸÄ± sonlandÄ±rmak istediÄŸinize emin misiniz?`)) {
          try {
            const friendship = friendsList.find((f) => f.sender_username === user.username || f.receiver_username === user.username);
            if (friendship) {
              const res = await fetchWithAuth(`${API_BASE_URL2}/friends/remove/${friendship.id}/`, { method: "DELETE" });
              if (res.ok) {
                setUpdateStatusText(`âœ… ${user.username} ile arkadaÅŸlÄ±k sonlandÄ±rÄ±ldÄ±`);
                setTimeout(() => setUpdateStatusText(""), 3e3);
                const friendsRes = await fetchWithAuth(`${API_BASE_URL2}/friends/list/`);
                if (friendsRes.ok) {
                  const data = await friendsRes.json();
                  setFriendsList(data.friends || []);
                }
              }
            }
          } catch (e) {
            setUpdateStatusText("âŒ ArkadaÅŸlÄ±k sonlandÄ±rma hatasÄ±");
            setTimeout(() => setUpdateStatusText(""), 3e3);
          }
        }
        break;
      case "invite_to_server":
        setInviteToServerUser({ username: user.username });
        break;
      case "mute_user":
        try {
          const res = await fetchWithAuth(`${API_BASE_URL2}/users/${user.username}/mute/`, { method: "POST" });
          if (res.ok) toast.success(`ðŸ”‡ ${user.username} sessize alÄ±ndÄ±`);
          else {
            const data = await res.json();
            toast.error(`âŒ ${data.error || "Sessize alma baÅŸarÄ±sÄ±z"}`);
          }
        } catch (e) {
          toast.error("âŒ Sessize alma hatasÄ±");
        }
        break;
      case "block_user":
        if (await confirmDialog(`${user.username} kullanÄ±cÄ±sÄ±nÄ± engellemek istediÄŸinize emin misiniz?`)) {
          try {
            const res = await fetchWithAuth(`${API_BASE_URL2}/users/${user.username}/block/`, { method: "POST" });
            if (res.ok) {
              toast.success(`ðŸš« ${user.username} engellendi`);
              const friendsRes = await fetchWithAuth(`${API_BASE_URL2}/friends/list/`);
              if (friendsRes.ok) {
                const data = await friendsRes.json();
                setFriendsList(data.friends || []);
              }
            } else {
              const data = await res.json();
              toast.error(`âŒ ${data.error || "Engelleme baÅŸarÄ±sÄ±z"}`);
            }
          } catch (e) {
            toast.error("âŒ Engelleme hatasÄ±");
          }
        }
        break;
    }
  }, [allUsers, isAdmin, currentVoiceRoom, fetchWithAuth, API_BASE_URL2, handleDMClick, friendsList]);
  return {
    serverToEdit,
    setServerToEdit,
    saveServerOrder,
    handleServerDragStart,
    handleServerDragOver,
    handleServerDragEnd,
    handleMoveServer,
    handleServerDrop,
    handleLogin,
    handleRegister,
    handleUserContextAction
  };
}
__name(useServerHandlers, "useServerHandlers");
const menuItemStyle = {
  display: "flex",
  alignItems: "center",
  gap: "8px",
  padding: "10px 16px",
  border: "none",
  width: "100%",
  textAlign: "left",
  cursor: "pointer",
  fontSize: "14px",
  backgroundColor: "transparent",
  color: "#dcddde",
  transition: "all 0.15s ease"
};
function ToolbarMenu({
  activeChat,
  hasKey,
  modals,
  soundSettings,
  isInVoice,
  username,
  openModal,
  closeModal,
  toggleModal,
  handleCopyLink,
  toggleNotifications,
  handleSummarize,
  handleClearChat,
  handleAdminDeleteConversation
}) {
  const hoverOn = /* @__PURE__ */ __name((e) => {
    e.currentTarget.style.backgroundColor = "#5865f2";
    e.currentTarget.style.color = "#ffffff";
  }, "hoverOn");
  const hoverOff = /* @__PURE__ */ __name((e, color = "#dcddde") => {
    e.currentTarget.style.backgroundColor = "transparent";
    e.currentTarget.style.color = color;
  }, "hoverOff");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
    position: "absolute",
    top: "50px",
    right: "0",
    backgroundColor: "#2f3136",
    borderRadius: "8px",
    boxShadow: "0 8px 16px rgba(0,0,0,0.4)",
    minWidth: "220px",
    zIndex: 1e3,
    overflow: "hidden",
    border: "1px solid #202225"
  }, children: [
    activeChat.type === "dm" && /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "button",
      {
        onClick: /* @__PURE__ */ __name(() => {
          openModal("encModal");
          closeModal("toolbarMenu");
        }, "onClick"),
        style: { ...menuItemStyle, color: hasKey ? "#43b581" : "#dcddde" },
        onMouseEnter: hoverOn,
        onMouseLeave: /* @__PURE__ */ __name((e) => hoverOff(e, hasKey ? "#43b581" : "#dcddde"), "onMouseLeave"),
        children: [
          hasKey ? /* @__PURE__ */ jsxRuntimeExports.jsx(FaLock, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(FaLock, { style: { opacity: 0.5 } }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: hasKey ? "Åžifreli" : "Åžifrele" })
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "button",
      {
        onClick: /* @__PURE__ */ __name(() => {
          toggleModal("pinned");
          closeModal("toolbarMenu");
        }, "onClick"),
        style: { ...menuItemStyle, color: modals.pinned ? "#f5a524" : "#dcddde" },
        onMouseEnter: hoverOn,
        onMouseLeave: /* @__PURE__ */ __name((e) => hoverOff(e, modals.pinned ? "#f5a524" : "#dcddde"), "onMouseLeave"),
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(FaThumbtack, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Sabitli Mesajlar" })
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "button",
      {
        onClick: /* @__PURE__ */ __name(() => {
          handleCopyLink();
          closeModal("toolbarMenu");
        }, "onClick"),
        style: menuItemStyle,
        onMouseEnter: hoverOn,
        onMouseLeave: /* @__PURE__ */ __name((e) => hoverOff(e), "onMouseLeave"),
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(FaLink, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "BaÄŸlantÄ±yÄ± Kopyala" })
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "button",
      {
        onClick: /* @__PURE__ */ __name(() => {
          toggleNotifications();
          closeModal("toolbarMenu");
        }, "onClick"),
        style: { ...menuItemStyle, color: soundSettings.notifications ? "#43b581" : "#f04747" },
        onMouseEnter: hoverOn,
        onMouseLeave: /* @__PURE__ */ __name((e) => hoverOff(e, soundSettings.notifications ? "#43b581" : "#f04747"), "onMouseLeave"),
        children: [
          soundSettings.notifications ? /* @__PURE__ */ jsxRuntimeExports.jsx(FaBell, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(FaBellSlash, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: soundSettings.notifications ? "Sessize Al" : "Sesi AÃ§" })
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { height: "1px", backgroundColor: "#40444b", margin: "4px 0" } }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "button",
      {
        onClick: /* @__PURE__ */ __name(() => {
          openModal("mentionsInbox");
          closeModal("toolbarMenu");
        }, "onClick"),
        style: menuItemStyle,
        onMouseEnter: hoverOn,
        onMouseLeave: /* @__PURE__ */ __name((e) => hoverOff(e), "onMouseLeave"),
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(FaInbox, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Bahsedilmeler" })
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "button",
      {
        onClick: /* @__PURE__ */ __name(() => {
          openModal("customStatus");
          closeModal("toolbarMenu");
        }, "onClick"),
        style: menuItemStyle,
        onMouseEnter: hoverOn,
        onMouseLeave: /* @__PURE__ */ __name((e) => hoverOff(e), "onMouseLeave"),
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(FaSmile, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Durumunu Ayarla" })
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { height: "1px", backgroundColor: "#40444b", margin: "4px 0" } }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "button",
      {
        onClick: /* @__PURE__ */ __name(() => {
          openModal("cinema");
          closeModal("toolbarMenu");
        }, "onClick"),
        style: menuItemStyle,
        onMouseEnter: hoverOn,
        onMouseLeave: /* @__PURE__ */ __name((e) => hoverOff(e), "onMouseLeave"),
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(FaFilm, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Sinema Modu" })
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "button",
      {
        onClick: /* @__PURE__ */ __name(() => {
          openModal("dJ");
          closeModal("toolbarMenu");
        }, "onClick"),
        style: menuItemStyle,
        onMouseEnter: hoverOn,
        onMouseLeave: /* @__PURE__ */ __name((e) => hoverOff(e), "onMouseLeave"),
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(FaCoffee, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "DJ Modu" })
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "button",
      {
        onClick: /* @__PURE__ */ __name(() => {
          openModal("whiteboard");
          closeModal("toolbarMenu");
        }, "onClick"),
        style: menuItemStyle,
        onMouseEnter: hoverOn,
        onMouseLeave: /* @__PURE__ */ __name((e) => hoverOff(e), "onMouseLeave"),
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(FaCode, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Beyaz Tahta" })
        ]
      }
    ),
    isInVoice && /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "button",
      {
        onClick: /* @__PURE__ */ __name(() => {
          openModal("soundboard");
          closeModal("toolbarMenu");
        }, "onClick"),
        style: menuItemStyle,
        onMouseEnter: hoverOn,
        onMouseLeave: /* @__PURE__ */ __name((e) => hoverOff(e), "onMouseLeave"),
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(FaMagic, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Ses Efektleri" })
        ]
      }
    ),
    activeChat.type === "room" && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { height: "1px", backgroundColor: "#40444b", margin: "4px 0" } }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "button",
        {
          onClick: /* @__PURE__ */ __name(() => {
            handleSummarize();
            closeModal("toolbarMenu");
          }, "onClick"),
          style: menuItemStyle,
          onMouseEnter: hoverOn,
          onMouseLeave: /* @__PURE__ */ __name((e) => hoverOff(e), "onMouseLeave"),
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(FaMagic, {}),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Sohbeti Ã–zetle" })
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "button",
        {
          onClick: /* @__PURE__ */ __name(() => {
            handleClearChat();
            closeModal("toolbarMenu");
          }, "onClick"),
          style: { ...menuItemStyle, color: "#f04747" },
          onMouseEnter: /* @__PURE__ */ __name((e) => {
            e.currentTarget.style.backgroundColor = "#f04747";
            e.currentTarget.style.color = "#ffffff";
          }, "onMouseEnter"),
          onMouseLeave: /* @__PURE__ */ __name((e) => hoverOff(e, "#f04747"), "onMouseLeave"),
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(FaBroom, {}),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Sohbeti Temizle" })
          ]
        }
      ),
      username === "admin" && activeChat.type === "dm" && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { height: "1px", backgroundColor: "#40444b", margin: "4px 0" } }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "button",
          {
            onClick: /* @__PURE__ */ __name(() => {
              handleAdminDeleteConversation(activeChat.id);
              closeModal("toolbarMenu");
            }, "onClick"),
            style: { ...menuItemStyle, color: "#ed4245", fontWeight: "bold" },
            onMouseEnter: /* @__PURE__ */ __name((e) => {
              e.currentTarget.style.backgroundColor = "#ed4245";
              e.currentTarget.style.color = "#ffffff";
            }, "onMouseEnter"),
            onMouseLeave: /* @__PURE__ */ __name((e) => hoverOff(e, "#ed4245"), "onMouseLeave"),
            title: "Admin: KonuÅŸmayÄ± kalÄ±cÄ± olarak sil",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(FaTrash, {}),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "âš ï¸ KALICI SÄ°L (ADMÄ°N)" })
            ]
          }
        )
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { height: "1px", backgroundColor: "#40444b", margin: "4px 0" } }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "button",
      {
        onClick: /* @__PURE__ */ __name(() => {
          openModal("featureHub");
          closeModal("toolbarMenu");
        }, "onClick"),
        style: { ...menuItemStyle, color: "#5865f2", fontWeight: "bold" },
        onMouseEnter: hoverOn,
        onMouseLeave: /* @__PURE__ */ __name((e) => hoverOff(e, "#5865f2"), "onMouseLeave"),
        children: [
          "ðŸš€",
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "TÃ¼m Ã–zellikler" })
        ]
      }
    )
  ] });
}
__name(ToolbarMenu, "ToolbarMenu");
function InviteServerModal({
  inviteToServerUser,
  setInviteToServerUser,
  categories,
  fetchWithAuth,
  API_BASE_URL: API_BASE_URL2
}) {
  if (!inviteToServerUser) return null;
  return ReactDOM.createPortal(
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        style: {
          position: "fixed",
          top: 0,
          left: 0,
          right: 0,
          bottom: 0,
          backgroundColor: "rgba(0,0,0,0.85)",
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          zIndex: 999999
        },
        onClick: /* @__PURE__ */ __name(() => setInviteToServerUser(null), "onClick"),
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            onClick: /* @__PURE__ */ __name((e) => e.stopPropagation(), "onClick"),
            style: {
              backgroundColor: "#2b2d31",
              borderRadius: "12px",
              width: "400px",
              maxHeight: "80vh",
              overflow: "hidden",
              boxShadow: "0 8px 32px rgba(0,0,0,0.5)"
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { padding: "20px", borderBottom: "1px solid #3f4147", textAlign: "center" }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { style: { color: "#f2f3f5", margin: 0, fontSize: "18px" }, children: "ðŸŽ« Sunucuya Davet Et" }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { style: { color: "#b9bbbe", margin: "8px 0 0", fontSize: "14px" }, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: inviteToServerUser.username }),
                  " kullanÄ±cÄ±sÄ±nÄ± hangi sunucuya davet etmek istiyorsunuz?"
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { maxHeight: "300px", overflowY: "auto", padding: "12px" }, children: categories.map((server2) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "div",
                {
                  onClick: /* @__PURE__ */ __name(async () => {
                    try {
                      const res = await fetchWithAuth(`${API_BASE_URL2}/servers/${server2.id}/invite/`, {
                        method: "POST",
                        body: JSON.stringify({ target_username: inviteToServerUser.username })
                      });
                      if (res.ok) {
                        toast.success(`ðŸŽ« ${inviteToServerUser.username} kullanÄ±cÄ±sÄ±na davetiye gÃ¶nderildi!`);
                      } else {
                        const data = await res.json();
                        if (data.error?.includes("zaten")) toast.info(`â„¹ï¸ ${inviteToServerUser.username} zaten bu sunucunun Ã¼yesi!`);
                        else toast.error(`âŒ ${data.error || "Davet gÃ¶nderilemedi"}`);
                      }
                    } catch (error) {
                      toast.error("âŒ BaÄŸlantÄ± hatasÄ±");
                    }
                    setInviteToServerUser(null);
                  }, "onClick"),
                  style: {
                    display: "flex",
                    alignItems: "center",
                    gap: "12px",
                    padding: "12px",
                    borderRadius: "8px",
                    cursor: "pointer",
                    transition: "all 0.2s",
                    backgroundColor: "rgba(255,255,255,0.02)",
                    marginBottom: "8px"
                  },
                  onMouseEnter: /* @__PURE__ */ __name((e) => {
                    e.currentTarget.style.backgroundColor = "rgba(88, 101, 242, 0.2)";
                  }, "onMouseEnter"),
                  onMouseLeave: /* @__PURE__ */ __name((e) => {
                    e.currentTarget.style.backgroundColor = "rgba(255,255,255,0.02)";
                  }, "onMouseLeave"),
                  children: [
                    server2.icon ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "img",
                      {
                        src: server2.icon,
                        alt: server2.name,
                        style: { width: 40, height: 40, borderRadius: "50%", objectFit: "cover" }
                      }
                    ) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
                      width: 40,
                      height: 40,
                      borderRadius: "50%",
                      backgroundColor: "#5865f2",
                      display: "flex",
                      alignItems: "center",
                      justifyContent: "center",
                      fontWeight: "bold",
                      color: "white",
                      fontSize: "16px"
                    }, children: server2.name?.substring(0, 2).toUpperCase() }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { flex: 1 }, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { color: "#f2f3f5", fontWeight: "600" }, children: server2.name }),
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { color: "#b9bbbe", fontSize: "12px" }, children: [
                        server2.member_count || 0,
                        " Ã¼ye"
                      ] })
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { color: "#5865f2", fontSize: "20px" }, children: "â†’" })
                  ]
                },
                server2.id
              )) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { padding: "16px 20px", borderTop: "1px solid #3f4147", textAlign: "center" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  onClick: /* @__PURE__ */ __name(() => setInviteToServerUser(null), "onClick"),
                  style: {
                    backgroundColor: "#4f545c",
                    color: "#f2f3f5",
                    border: "none",
                    padding: "10px 24px",
                    borderRadius: "4px",
                    cursor: "pointer",
                    fontWeight: "600"
                  },
                  children: "Ä°ptal"
                }
              ) })
            ]
          }
        )
      }
    ),
    document.body
  );
}
__name(InviteServerModal, "InviteServerModal");
const AppContent = /* @__PURE__ */ __name(() => {
  const { user, isAuthenticated, token, login, logout, isLoading: isAuthLoading, refreshAccessToken } = useAuth();
  const username = user?.username || localStorage.getItem("username") || "";
  const {
    isInVoice,
    isConnecting,
    currentRoom: currentVoiceRoom,
    joinChannel,
    leaveChannel,
    isMuted,
    isDeafened,
    toggleMute,
    toggleDeafened,
    toggleVideo,
    toggleScreenShare,
    remoteVolumes,
    setRemoteVolume,
    localCameraStream,
    remoteStreams,
    isTalking,
    sendSignal,
    isScreenSharing,
    isVideoEnabled,
    isPttActive,
    localScreenStream,
    sendReaction,
    lastReaction,
    applyVoiceEffect,
    activeEffect,
    cinemaState,
    setCinemaState,
    gameState,
    sendGameSignal,
    mutedUsers,
    useNewVoicePanel,
    showVoiceIsland,
    setShowVoiceIsland,
    isVoicePanelMinimized,
    setIsVoicePanelMinimized,
    focusedStream,
    setFocusedStream,
    islandState,
    setIslandState
  } = useVoice();
  const { setGlobalData: forwardToGlobalContext, setIsConnected: setGlobalWsConnected } = useGlobalWebSocket();
  const [defaultAvatars, setDefaultAvatars] = reactExports.useState([]);
  const [viewingProfile, setViewingProfile] = reactExports.useState(null);
  const [zoomedImage, setZoomedImage] = reactExports.useState(null);
  const [galleryData, setGalleryData] = reactExports.useState(null);
  const { activeChat, setActiveChat, messages, setMessages, encryptionKeys, setEncryptionKey, voiceUsers, setVoiceUsersState, unreadCounts, selectedMessages, setSelectedMessages } = useChatStore();
  const { modals, openModal, closeModal, toggleModal, animationState, setAnimationState, isConnected, setIsConnected, updateStatusText, setUpdateStatusText, downloadProgress, setDownloadProgress, isDownloading, setIsDownloading, searchQuery, setSearchQuery, dropTarget, setDropTarget } = useUIStore();
  const { isMobile } = useResponsive();
  const [isLeftSidebarVisible, setIsLeftSidebarVisible] = reactExports.useState(false);
  const [isRightSidebarVisible, setIsRightSidebarVisible] = reactExports.useState(false);
  const safeAreaBottom = isNative ? "max(20px, env(safe-area-inset-bottom))" : "0px";
  const debouncedSearchQuery = useDebounce(searchQuery, 300);
  const [currentTheme, setCurrentTheme] = reactExports.useState("default");
  const [messageHistoryLoading, setMessageHistoryLoading] = reactExports.useState(false);
  const [hasMoreMessages, setHasMoreMessages] = reactExports.useState(true);
  const [messageHistoryOffset, setMessageHistoryOffset] = reactExports.useState(0);
  const [friendsList, setFriendsList] = reactExports.useState([]);
  const [pendingFriendRequests, setPendingFriendRequests] = reactExports.useState(0);
  const [serverOrder, setServerOrder] = reactExports.useState([]);
  const [serverMembers, setServerMembers] = reactExports.useState([]);
  const [selectedServer, setSelectedServer] = reactExports.useState(null);
  const [currentUserProfile, setCurrentUserProfile] = reactExports.useState(null);
  const [updateAvailable, setUpdateAvailable] = reactExports.useState(false);
  const [soundSettings, setSoundSettings] = reactExports.useState(() => JSON.parse(localStorage.getItem("chat_sound_settings")) || { notifications: true, mentions: true, userJoinLeave: true });
  const [maintenanceMode, setMaintenanceMode] = reactExports.useState(null);
  const [showScrollToBottom, setShowScrollToBottom] = reactExports.useState(false);
  const [editingMessage, setEditingMessage] = reactExports.useState(null);
  const [replyingTo, setReplyingTo] = reactExports.useState(null);
  const [forwardingMessage, setForwardingMessage] = reactExports.useState(null);
  const [isSelectionMode, setIsSelectionMode] = reactExports.useState(false);
  const [userContextMenu, setUserContextMenu] = reactExports.useState(null);
  const [inviteToServerUser, setInviteToServerUser] = reactExports.useState(null);
  const [showVanityInvite, setShowVanityInvite] = reactExports.useState(null);
  const [showInviteCode, setShowInviteCode] = reactExports.useState(null);
  const [categories, setCategories] = reactExports.useState([]);
  const [conversations, setConversations] = reactExports.useState([]);
  const [allUsers, setAllUsers] = reactExports.useState([]);
  const [pinnedMessages, setPinnedMessages] = reactExports.useState([]);
  const [authError, setAuthError] = reactExports.useState(null);
  const [isSummaryLoading, setIsSummaryLoading] = reactExports.useState(false);
  const [summaryResult, setSummaryResult] = reactExports.useState("");
  const [chartSymbol, setChartSymbol] = reactExports.useState(null);
  const [hasDraftMessage, setHasDraftMessage] = reactExports.useState(false);
  const [draftText, setDraftText] = reactExports.useState("");
  const messagesEndRef = reactExports.useRef(null);
  const messageBoxRef = reactExports.useRef(null);
  const searchInputRef = reactExports.useRef(null);
  const richTextRef = reactExports.useRef(null);
  reactExports.useRef(null);
  const historyCacheRef = reactExports.useRef({});
  const statusWsRef = reactExports.useRef(null);
  const statusWsReconnectRef = reactExports.useRef(null);
  const activeChatRef = reactExports.useRef(activeChat);
  const tokenRef = reactExports.useRef(token);
  const usernameRef = reactExports.useRef(username);
  reactExports.useEffect(() => {
    activeChatRef.current = activeChat;
  }, [activeChat]);
  reactExports.useEffect(() => {
    tokenRef.current = token;
  }, [token]);
  reactExports.useEffect(() => {
    usernameRef.current = username;
  }, [username]);
  const { fetchWithAuth } = useFetchWithAuth();
  const typingUsers = useChatStore((state) => state.typingUsers);
  const activeTypingUsers = reactExports.useMemo(() => typingUsers.filter((u) => u !== username), [typingUsers, username]);
  const onlineUsers = useChatStore((state) => state.onlineUsers);
  const { setOnlineUsers } = useChatStore();
  const rawMessages = useChatStore((state) => state.messages);
  const optimizedMessages = useOptimizedMessages(rawMessages, debouncedSearchQuery);
  useOnlineUsers(allUsers);
  const isAdmin = username === "Eastkhan" || username === "PawPaw" || currentUserProfile?.role === "admin";
  const currentUserPermissions = reactExports.useMemo(() => {
    const currentServer = categories?.find((c) => c.id === activeChat?.serverId);
    const isServerOwner = currentServer?.owner === username || currentServer?.created_by === username;
    const isMod = serverMembers?.find((m) => m.username === username)?.role === "moderator";
    return {
      isAdmin,
      isServerOwner,
      isModerator: isMod,
      canKick: isAdmin || isServerOwner || isMod,
      canBan: isAdmin || isServerOwner,
      canMute: isAdmin || isServerOwner || isMod,
      canWarn: isAdmin || isServerOwner || isMod,
      canManageRoles: isAdmin || isServerOwner
    };
  }, [isAdmin, categories, activeChat?.serverId, username, serverMembers]);
  const sortedServers = reactExports.useMemo(() => {
    if (!categories || categories.length === 0) return [];
    if (!serverOrder || serverOrder.length === 0) return categories;
    const ordered = [], unordered = [];
    serverOrder.forEach((id) => {
      const s = categories.find((c) => c.id === id);
      if (s) ordered.push(s);
    });
    categories.forEach((s) => {
      if (!serverOrder.includes(s.id)) unordered.push(s);
    });
    return [...ordered, ...unordered];
  }, [categories, serverOrder]);
  const chatTitle = reactExports.useMemo(() => {
    if (activeChat.type === "room") {
      if (categories) {
        for (const server2 of categories) {
          if (server2.categories) {
            for (const cat of server2.categories) {
              const foundRoom = cat.rooms?.find((r) => r.slug === activeChat.id);
              if (foundRoom) return String(foundRoom.name);
            }
          }
        }
      }
      return String(activeChat.id);
    } else if (activeChat.type === "dm") return `@ ${String(activeChat.targetUser || "DM")}`;
    return "";
  }, [activeChat, categories]);
  const activeRoomType = reactExports.useMemo(() => {
    if (activeChat.type !== "room" || !categories) return "text";
    for (const srv of categories) {
      if (srv.categories) {
        for (const cat of srv.categories) {
          const room = cat.rooms?.find((r) => r.slug === activeChat.id);
          if (room) return room.channel_type;
        }
      }
    }
    return "text";
  }, [activeChat, categories]);
  const isImageOnlyMessage = /* @__PURE__ */ __name((msg) => {
    if (!msg) return false;
    const hasImage = !!(msg.image_url || msg.image);
    const hasFileImage = !!(msg.file_url || msg.file) && !msg.is_voice_message && /\.(jpg|jpeg|png|gif|webp|bmp|svg)$/i.test(msg.file_name || "");
    const hasContent = !!(msg.content && msg.content.trim());
    return (hasImage || hasFileImage) && !hasContent && !msg.poll && !msg.reply_to;
  }, "isImageOnlyMessage");
  const scrollToBottom = reactExports.useCallback((behavior = "auto") => {
    if (messagesEndRef.current) messagesEndRef.current.scrollIntoView({ behavior });
  }, []);
  const isNearBottom = reactExports.useCallback(() => {
    const el = messageBoxRef.current;
    if (!el) return true;
    return el.scrollHeight - el.scrollTop - el.clientHeight < 160;
  }, []);
  const handleMessageScroll = reactExports.useCallback(() => {
    const el = messageBoxRef.current;
    if (!el) return;
    setShowScrollToBottom(el.scrollHeight - el.scrollTop - el.clientHeight > 160);
  }, []);
  const throttledHandleMessageScroll = useThrottle(handleMessageScroll, 100);
  const getDeterministicAvatar = reactExports.useCallback((uname) => {
    if (uname === "âš¡ Signal Bot") return `${MEDIA_BASE_URL}/static/bot/signal.png`;
    if (uname === "PawPaw AI") return `${MEDIA_BASE_URL}/static/bot/ai.png`;
    if (!uname || !defaultAvatars || defaultAvatars.length === 0) return `${MEDIA_BASE_URL}/avatars/cat_1.png`;
    let hash2 = 0;
    for (let i = 0; i < uname.length; i++) hash2 = uname.charCodeAt(i) + ((hash2 << 5) - hash2);
    const index = Math.abs(hash2 % defaultAvatars.length);
    const avatarItem = defaultAvatars[index];
    let path2;
    if (typeof avatarItem === "object" && avatarItem !== null) path2 = avatarItem.original || avatarItem.thumbnail || avatarItem.url;
    else if (typeof avatarItem === "string") path2 = avatarItem;
    if (!path2 || typeof path2 !== "string") return `${MEDIA_BASE_URL}/avatars/cat_1.png`;
    if (path2.startsWith("http") || path2.startsWith("blob:")) return path2;
    if (!path2.startsWith("/")) path2 = "/" + path2;
    return `${MEDIA_BASE_URL}${path2}`;
  }, [defaultAvatars]);
  const getRealUserAvatar = reactExports.useCallback((targetUsername) => {
    const userObj = allUsers.find((u) => u.username === targetUsername);
    if (userObj && userObj.avatar && typeof userObj.avatar === "string") {
      if (userObj.avatar.startsWith("http") || userObj.avatar.startsWith("blob:")) return userObj.avatar;
      let avatarPath = userObj.avatar;
      if (!avatarPath.startsWith("/")) avatarPath = "/" + avatarPath;
      return `${MEDIA_BASE_URL}${avatarPath}`;
    }
    return getDeterministicAvatar(targetUsername);
  }, [allUsers, getDeterministicAvatar]);
  const chatDraftKey = reactExports.useMemo(() => !activeChat || !activeChat.id ? "" : `${activeChat.type}-${activeChat.id}`, [activeChat]);
  const loadDraftMap = reactExports.useCallback(() => {
    try {
      const raw = localStorage.getItem(DRAFT_STORAGE_KEY);
      if (!raw) return {};
      const parsed = JSON.parse(raw);
      return parsed && typeof parsed === "object" ? parsed : {};
    } catch (e) {
      return {};
    }
  }, []);
  const persistDraft = reactExports.useCallback((value) => {
    if (!chatDraftKey) return;
    const map = loadDraftMap();
    map[chatDraftKey] = value;
    localStorage.setItem(DRAFT_STORAGE_KEY, JSON.stringify(map));
  }, [chatDraftKey, loadDraftMap]);
  reactExports.useEffect(() => {
    if (!chatDraftKey) {
      setDraftText("");
      setHasDraftMessage(false);
      return;
    }
    const drafts = loadDraftMap();
    const restored = drafts[chatDraftKey] || "";
    setDraftText(restored);
    setHasDraftMessage(!!restored.trim());
  }, [chatDraftKey, loadDraftMap]);
  const handleRoomChange = /* @__PURE__ */ __name((slug) => {
    setActiveChat("room", slug);
    if (isMobile) setIsLeftSidebarVisible(false);
  }, "handleRoomChange");
  const handleDMClick = /* @__PURE__ */ __name((targetUser) => {
    fetchWithAuth(GET_OR_CREATE_CONVERSATION_URL, { method: "POST", body: JSON.stringify({ target_username: targetUser }) }).then((r) => r.json()).then((data) => {
      setActiveChat("dm", data.conversation_id, targetUser);
      if (isMobile) setIsLeftSidebarVisible(false);
    });
  }, "handleDMClick");
  const navigateToPath = reactExports.useCallback((hashPath) => {
    if (!hashPath) return;
    window.location.hash = hashPath.startsWith("#/") ? hashPath : `#${hashPath.startsWith("/") ? hashPath : `/${hashPath}`}`;
    if (isMobile) setIsRightSidebarVisible(false);
  }, [isMobile]);
  const handleWelcomeClick = reactExports.useCallback(() => {
    setActiveChat("welcome", "welcome", null);
    if (isMobile) setIsLeftSidebarVisible(false);
  }, [isMobile]);
  const toggleNotifications = reactExports.useCallback(() => {
    setSoundSettings((prev) => {
      const next = { ...prev, notifications: !prev.notifications };
      localStorage.setItem("chat_sound_settings", JSON.stringify(next));
      return next;
    });
  }, []);
  const handleCopyLink = reactExports.useCallback(async () => {
    if (!activeChat?.id) return;
    const link = `${window.location.origin}/#/${activeChat.type === "dm" ? `dm/${activeChat.id}` : `room/${activeChat.id}`}`;
    try {
      await navigator.clipboard.writeText(link);
      setUpdateStatusText("Link kopyalandÄ±");
      setTimeout(() => setUpdateStatusText(""), 1500);
    } catch (e) {
      console.error("Link kopyalanamadÄ±", e);
    }
  }, [activeChat]);
  const { isInitialDataLoaded, stickyMessage, setStickyMessage, handleServerSelect } = useAppInit({
    isAuthenticated,
    username,
    token,
    fetchWithAuth,
    setCategories,
    setConversations,
    setAllUsers,
    setFriendsList,
    setCurrentUserProfile,
    setServerOrder,
    setMaintenanceMode,
    setAuthError,
    setServerMembers,
    API_BASE_URL,
    ROOM_LIST_URL,
    CONVERSATION_LIST_URL,
    activeChat,
    categories,
    setActiveChat
  });
  const sharedWsRef = reactExports.useRef(null);
  const messageHandlers = useMessageHandlers({
    activeChat,
    username,
    token,
    ws: sharedWsRef,
    encryptionKeys,
    setMessages,
    scrollToBottom,
    isNearBottom,
    setEditingMessage,
    setHasDraftMessage,
    setDraftText,
    persistDraft,
    setStickyMessage,
    richTextRef,
    fetchWithAuth,
    currentUserProfile,
    getDeterministicAvatar,
    historyCacheRef,
    setHasMoreMessages,
    setMessageHistoryOffset,
    setIsSummaryLoading,
    setSummaryResult,
    setPinnedMessages,
    setConversations,
    setMessageHistoryLoading,
    openModal,
    closeModal,
    API_BASE_URL,
    MESSAGE_HISTORY_ROOM_URL,
    MESSAGE_HISTORY_DM_URL
  });
  const { ws } = useChatConnection({
    activeChat,
    username,
    token,
    isAuthenticated,
    isInitialDataLoaded,
    fetchWithAuth,
    scrollToBottom,
    isNearBottom,
    setMessages,
    setIsConnected,
    historyCacheRef,
    setHasMoreMessages,
    setMessageHistoryOffset,
    fetchMessageHistory: messageHandlers.fetchMessageHistory,
    setShowScrollToBottom,
    API_BASE_URL,
    API_HOST,
    WS_PROTOCOL,
    forwardToGlobalContext,
    setGlobalWsConnected,
    setOnlineUsers,
    setVoiceUsersState,
    setAllUsers,
    setCurrentUserProfile,
    activeChatRef,
    tokenRef,
    usernameRef,
    setCategories,
    ROOM_LIST_URL,
    statusWsRef,
    statusWsReconnectRef,
    logout,
    refreshAccessToken,
    setCurrentTheme
  });
  reactExports.useEffect(() => {
    if (ws) sharedWsRef.current = ws.current;
  }, [ws]);
  const fileUpload = useFileUpload({
    activeChat,
    username,
    fetchWithAuth,
    scrollToBottom,
    setMessages,
    API_BASE_URL,
    handleDMClick,
    conversations,
    categories
  });
  const serverHandlers = useServerHandlers({
    username,
    fetchWithAuth,
    categories,
    allUsers,
    friendsList,
    serverMembers,
    isAdmin,
    currentVoiceRoom,
    setUpdateStatusText,
    setFriendsList,
    setInviteToServerUser,
    API_BASE_URL,
    handleDMClick,
    isInVoice,
    setServerOrder,
    serverOrder,
    setActiveChat,
    setCurrentUserProfile,
    setCategories,
    setConversations,
    setAllUsers,
    setIsInitialDataLoaded: /* @__PURE__ */ __name(() => {
    }, "setIsInitialDataLoaded"),
    setAuthError,
    login,
    logout,
    setViewingProfile,
    ABSOLUTE_HOST_URL,
    ROOM_LIST_URL
  });
  const { safeAreaTop } = useAppEffects({
    setAnimationState,
    setShowVanityInvite,
    setShowInviteCode,
    setMaintenanceMode,
    setUpdateAvailable,
    setAllUsers,
    animationState,
    isInitialDataLoaded,
    isAuthenticated,
    username,
    messages,
    activeChat,
    isInVoice,
    currentVoiceRoom,
    modals,
    statusWsRef,
    openModal,
    closeModal,
    toggleModal,
    setActiveChat,
    isNative,
    isElectron,
    fetchWithAuth,
    isNearBottom,
    scrollToBottom,
    handleMessageScroll,
    API_BASE_URL,
    MEDIA_BASE_URL,
    GOOGLE_WEB_CLIENT_ID
  });
  const handleStartUpdate = /* @__PURE__ */ __name(() => {
    if (isElectron) {
      setIsDownloading(true);
      setUpdateStatusText("Ä°ndiriliyor...");
      const { ipcRenderer } = window.require("electron");
      ipcRenderer.send("start-download", `${ABSOLUTE_HOST_URL}/media/build/Pawscord-Setup.exe`);
    } else {
      window.open(`${ABSOLUTE_HOST_URL}/media/build/Pawscord-Setup.exe`, "_blank");
    }
  }, "handleStartUpdate");
  reactExports.useEffect(() => {
    if (isElectron) {
      const { ipcRenderer } = window.require("electron");
      const handleProgress = /* @__PURE__ */ __name((event, progress) => setDownloadProgress(Math.round(progress * 100)), "handleProgress");
      const handleComplete = /* @__PURE__ */ __name(() => {
        setUpdateStatusText("BaÅŸlatÄ±lÄ±yor...");
        setDownloadProgress(100);
        setTimeout(() => setUpdateStatusText("KapanÄ±yor..."), 1500);
      }, "handleComplete");
      const handleError = /* @__PURE__ */ __name((event, error) => {
        setIsDownloading(false);
      }, "handleError");
      ipcRenderer.on("download-progress", handleProgress);
      ipcRenderer.on("download-complete", handleComplete);
      ipcRenderer.on("download-error", handleError);
      return () => {
        ipcRenderer.removeAllListeners("download-progress");
        ipcRenderer.removeAllListeners("download-complete");
        ipcRenderer.removeAllListeners("download-error");
      };
    }
  }, []);
  const showSplash = animationState !== "finished";
  const mobileWebPadding = isMobile && !isNative ? "20px" : safeAreaTop;
  const currentKeyId = activeChat.type === "room" ? `room-${activeChat.id}` : `dm-${activeChat.id}`;
  const hasKey = !!encryptionKeys[currentKeyId];
  if (!isAuthenticated) return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    showSplash && /* @__PURE__ */ jsxRuntimeExports.jsx(SplashScreen$1, { animationState }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingSpinner, { size: "large", text: "YÃ¼kleniyor..." }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(LoginPage, { onLogin: serverHandlers.handleLogin, onRegister: serverHandlers.handleRegister, error: authError, setAuthError }) })
  ] });
  if (showVanityInvite) return /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingSpinner, { size: "large", text: "Davet yÃ¼kleniyor..." }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    VanityInviteScreen,
    {
      vanityPath: showVanityInvite,
      fetchWithAuth,
      apiBaseUrl: API_BASE_URL,
      onClose: /* @__PURE__ */ __name(() => {
        setShowVanityInvite(null);
        window.location.hash = "#/";
      }, "onClose")
    }
  ) });
  if (showInviteCode) return /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingSpinner, { size: "large", text: "Davet yÃ¼kleniyor..." }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    InviteCodeScreen,
    {
      inviteCode: showInviteCode,
      fetchWithAuth,
      apiBaseUrl: API_BASE_URL,
      onClose: /* @__PURE__ */ __name(() => {
        setShowInviteCode(null);
        window.location.hash = "#/";
      }, "onClose")
    }
  ) });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { ...styles$7.mainContainer }, className: "dark-theme", children: [
    showSplash && /* @__PURE__ */ jsxRuntimeExports.jsx(SplashScreen$1, { animationState }),
    maintenanceMode && /* @__PURE__ */ jsxRuntimeExports.jsx(MaintenanceBanner, { message: maintenanceMode.message, endTime: maintenanceMode.endTime, level: maintenanceMode.level, onDismiss: /* @__PURE__ */ __name(() => setMaintenanceMode(null), "onDismiss") }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      AppModals,
      {
        fetchWithAuth,
        activeChat,
        username,
        sendMessage: messageHandlers.sendMessage,
        sendSignal,
        ws,
        currentUserProfile,
        setCurrentUserProfile,
        currentTheme,
        setCurrentTheme,
        soundSettings,
        setSoundSettings,
        encryptionKeys,
        currentKeyId,
        setEncryptionKey,
        chartSymbol,
        setChartSymbol,
        serverToEdit: serverHandlers.serverToEdit,
        setServerToEdit: serverHandlers.setServerToEdit,
        serverMembers,
        friendsList,
        conversations,
        categories,
        allUsers,
        pinnedMessages,
        isSummaryLoading,
        summaryResult,
        zoomedImage,
        setZoomedImage,
        galleryData,
        setGalleryData,
        viewingProfile,
        setViewingProfile,
        isAdmin,
        richTextRef,
        logout,
        getDeterministicAvatar,
        handleSendSnippet: messageHandlers.handleSendSnippet,
        handleDMClick,
        setActiveChat,
        setConversations,
        isMuted,
        isDeafened,
        toggleMute,
        toggleDeafened
      }
    ),
    isMobile && isLeftSidebarVisible && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: styles$7.mobileOverlay, onClick: /* @__PURE__ */ __name(() => setIsLeftSidebarVisible(false), "onClick") }),
    isMobile && isRightSidebarVisible && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: styles$7.mobileOverlay, onClick: /* @__PURE__ */ __name(() => setIsRightSidebarVisible(false), "onClick") }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ConnectionStatusBar$1, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: styles$7.chatLayout, children: [
      (!isMobile || isLeftSidebarVisible) && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { ...styles$7.sidebarWrapper, ...isMobile && styles$7.mobileSidebar, paddingTop: mobileWebPadding, paddingBottom: safeAreaBottom, height: "100%", boxSizing: "border-box" }, children: [
        isMobile && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: styles$7.mobileSidebarHeader, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", gap: "10px" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: "https://media.pawscord.com/assets/logo.png", alt: "", style: { width: "24px", height: "24px" }, onError: /* @__PURE__ */ __name((e) => {
              e.target.style.display = "none";
            }, "onError") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: "18px", fontWeight: "bold", color: "white" }, children: "Pawscord" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: /* @__PURE__ */ __name(() => setIsLeftSidebarVisible(false), "onClick"), style: styles$7.closeSidebarButton, children: /* @__PURE__ */ jsxRuntimeExports.jsx(FaTimes, {}) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingSpinner, { size: "medium", text: "Kanallar yÃ¼kleniyor..." }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          RoomList,
          {
            onFriendsClick: /* @__PURE__ */ __name(() => setActiveChat("friends", "friends"), "onFriendsClick"),
            onRoomSelect: handleRoomChange,
            onDMSelect: /* @__PURE__ */ __name((id, targetUsername) => setActiveChat("dm", id, targetUsername), "onDMSelect"),
            onWelcomeClick: handleWelcomeClick,
            setIsLeftSidebarVisible,
            onProfileClick: /* @__PURE__ */ __name(() => openModal("profilePanel"), "onProfileClick"),
            onViewUserProfile: /* @__PURE__ */ __name((u) => {
              const usr = allUsers.find((a) => a.username === u);
              if (usr) setViewingProfile(usr);
            }, "onViewUserProfile"),
            onOpenStore: /* @__PURE__ */ __name(() => openModal("store"), "onOpenStore"),
            onOpenServerSettings: /* @__PURE__ */ __name((server2) => serverHandlers.setServerToEdit(server2), "onOpenServerSettings"),
            categories: sortedServers,
            onServerDragStart: serverHandlers.handleServerDragStart,
            onServerDragOver: serverHandlers.handleServerDragOver,
            onServerDragEnd: serverHandlers.handleServerDragEnd,
            onServerDrop: serverHandlers.handleServerDrop,
            onMoveServer: serverHandlers.handleMoveServer,
            conversations,
            allUsers,
            onlineUsers,
            serverMembers,
            isAdmin,
            friendsList,
            pendingFriendRequests,
            currentUsername: username,
            currentUserProfile,
            getRealUserAvatar,
            getDeterministicAvatar,
            unreadCounts,
            joinVoiceChat: joinChannel,
            leaveVoiceChat: leaveChannel,
            voiceUsers,
            isConnecting,
            currentVoiceRoom,
            currentRoom: currentVoiceRoom,
            currentConversationId: activeChat.type === "dm" ? activeChat.id : null,
            remoteVolumes,
            setRemoteVolume,
            isPttActive,
            apiBaseUrl: ABSOLUTE_HOST_URL,
            fetchWithAuth,
            onHideConversation: messageHandlers.handleHideConversation,
            handleDrop: /* @__PURE__ */ __name(() => {
            }, "handleDrop"),
            dropTarget,
            setDropTarget,
            isDragging: fileUpload.isDragging,
            onOpenCreateGroup: /* @__PURE__ */ __name(() => openModal("groupModal"), "onOpenCreateGroup"),
            toggleMute,
            toggleDeafened,
            isMuted,
            isDeafened,
            isInVoice,
            toggleVideo,
            toggleScreenShare,
            isVideoEnabled,
            isScreenSharing,
            updateAvailable,
            onUpdateClick: /* @__PURE__ */ __name(() => openModal("downloadModal"), "onUpdateClick"),
            onOpenAnalytics: /* @__PURE__ */ __name(() => openModal("analytics"), "onOpenAnalytics"),
            onOpenAdminPanel: /* @__PURE__ */ __name(() => openModal("adminPanel"), "onOpenAdminPanel"),
            onOpenPaymentPanel: /* @__PURE__ */ __name(() => openModal("paymentPanel"), "onOpenPaymentPanel"),
            onOpenStoreModal: /* @__PURE__ */ __name(() => openModal("storeModal"), "onOpenStoreModal"),
            onOpenDailyRewards: /* @__PURE__ */ __name(() => openModal("dailyRewards"), "onOpenDailyRewards"),
            onOpenAPIUsage: /* @__PURE__ */ __name(() => openModal("aPIUsagePanel"), "onOpenAPIUsage"),
            onOpenExportJobs: /* @__PURE__ */ __name(() => openModal("exportJobsPanel"), "onOpenExportJobs"),
            onOpenScheduledAnnouncements: /* @__PURE__ */ __name(() => openModal("scheduledAnnouncements"), "onOpenScheduledAnnouncements"),
            onOpenMiniGames: /* @__PURE__ */ __name(() => openModal("miniGames"), "onOpenMiniGames"),
            onOpenProjectCollaboration: /* @__PURE__ */ __name(() => openModal("projectCollaboration"), "onOpenProjectCollaboration"),
            onOpenAvatarStudio: /* @__PURE__ */ __name(() => openModal("avatarStudio"), "onOpenAvatarStudio"),
            onServerSelect: handleServerSelect
          }
        ) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: styles$7.mainContent, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { position: "absolute", top: 60, left: 0, right: 0, zIndex: 90 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: null, children: /* @__PURE__ */ jsxRuntimeExports.jsx(StickyMessageBanner, { message: stickyMessage?.message, type: stickyMessage?.type, onDismiss: /* @__PURE__ */ __name(() => setStickyMessage(null), "onDismiss") }) }) }),
        activeChat.type === "friends" ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "100%", height: "100%", paddingTop: mobileWebPadding }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingSpinner, { size: "medium", text: "ArkadaÅŸlar yÃ¼kleniyor..." }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          FriendsTab,
          {
            fetchWithAuth,
            apiBaseUrl: API_BASE_URL,
            onStartDM: handleDMClick,
            getDeterministicAvatar,
            onClose: /* @__PURE__ */ __name(() => setActiveChat("welcome", "welcome"), "onClose"),
            onPendingCountChange: setPendingFriendRequests,
            onlineUsers
          }
        ) }) }) : activeChat.type === "welcome" ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "100%", height: "100%" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingSpinner, { size: "medium", text: "YÃ¼kleniyor..." }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          WelcomeScreen,
          {
            isMobile,
            onOpenMenu: /* @__PURE__ */ __name(() => setIsLeftSidebarVisible(true), "onOpenMenu"),
            onOpenRightMenu: /* @__PURE__ */ __name(() => setIsRightSidebarVisible(true), "onOpenRightMenu"),
            updateAvailable,
            isDownloading,
            downloadProgress,
            updateStatusText,
            onStartUpdate: handleStartUpdate,
            onSwitchToFriends: /* @__PURE__ */ __name(() => {
              setActiveChat("friends", "friends");
              if (isMobile) setIsLeftSidebarVisible(false);
            }, "onSwitchToFriends"),
            onSwitchToAI: /* @__PURE__ */ __name(() => handleRoomChange("ai"), "onSwitchToAI"),
            onSwitchToCinema: /* @__PURE__ */ __name(() => {
              openModal("cinema");
              if (isMobile) setIsLeftSidebarVisible(false);
            }, "onSwitchToCinema")
          }
        ) }) }) : activeRoomType === "kanban" ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { width: "100%", height: "100%", overflow: "hidden" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: styles$7.chatHeader, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("h2", { children: [
            "# ",
            chatTitle,
            " (Pano)"
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingSpinner, { size: "medium", text: "Pano yÃ¼kleniyor..." }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(KanbanBoard, { roomSlug: activeChat.id, apiBaseUrl: ABSOLUTE_HOST_URL, fetchWithAuth }) })
        ] }) : activeChat.type === "voice" && isInVoice ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { width: "100%", height: "100%", display: "flex", flexDirection: "column", backgroundColor: "#2f3136" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { ...styles$7.chatHeader, justifyContent: "space-between" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", gap: "10px" }, children: [
              isMobile && /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: /* @__PURE__ */ __name(() => setActiveChat("welcome", "welcome"), "onClick"), style: styles$7.mobileMenuButton, children: "â†" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("h2", { style: { margin: 0, fontSize: "1.2em" }, children: [
                "ðŸ”Š ",
                currentVoiceRoom
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                onClick: /* @__PURE__ */ __name(() => {
                  leaveChannel();
                  setActiveChat("welcome", "welcome");
                }, "onClick"),
                style: { background: "#ed4245", color: "white", border: "none", borderRadius: "8px", padding: "8px 16px", cursor: "pointer", fontWeight: "bold" },
                children: "BaÄŸlantÄ±yÄ± Kes"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            VoiceChatPanel,
            {
              roomName: currentVoiceRoom,
              onClose: /* @__PURE__ */ __name(() => {
                leaveChannel();
                setActiveChat("welcome", "welcome");
              }, "onClose"),
              isMinimized: false,
              onToggleMinimize: /* @__PURE__ */ __name(() => {
              }, "onToggleMinimize"),
              getRealUserAvatar,
              allUsers,
              currentUserProfile
            }
          )
        ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            style: { ...styles$7.chatArea, position: "relative", paddingTop: mobileWebPadding, boxSizing: "border-box" },
            onDrop: fileUpload.handleChatDrop,
            onDragOver: /* @__PURE__ */ __name((e) => e.preventDefault(), "onDragOver"),
            onDragEnter: fileUpload.handleChatDragEnter,
            onDragLeave: fileUpload.handleChatDragLeave,
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { ...styles$7.chatHeader, justifyContent: "space-between" }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", overflow: "hidden", gap: "8px" }, children: [
                  isMobile && !isLeftSidebarVisible && /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: /* @__PURE__ */ __name(() => setIsLeftSidebarVisible(true), "onClick"), style: { ...styles$7.mobileMenuButton, fontSize: "1.3em" }, children: "â˜°" }),
                  isMobile && (activeChat.type === "dm" || activeChat.type === "room") && /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: /* @__PURE__ */ __name(() => {
                    setActiveChat("welcome", "welcome");
                    setIsLeftSidebarVisible(false);
                    setIsRightSidebarVisible(false);
                  }, "onClick"), style: { ...styles$7.mobileMenuButton, fontSize: "1.2em" }, children: "â†" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { style: { display: "flex", alignItems: "center", gap: "10px", margin: 0, fontSize: isMobile ? "1em" : "1.1em", whiteSpace: "nowrap", overflow: "hidden", textOverflow: "ellipsis" }, children: activeChat.type === "dm" ? `@ ${String(activeChat.targetUser || "DM")}` : `# ${String(chatTitle)}` }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: isConnected ? styles$7.connectionPillOnline : styles$7.connectionPillOffline, children: isConnected ? "âœ“" : "âœ—" })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: isMobile ? "5px" : "10px", alignItems: "center", flexWrap: isMobile ? "nowrap" : "wrap", position: "relative" }, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: /* @__PURE__ */ __name((e) => messageHandlers.handleSearchMessages(e, debouncedSearchQuery), "onSubmit"), style: styles$7.searchForm, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("input", { type: "text", placeholder: "Ara...", value: searchQuery, onChange: /* @__PURE__ */ __name((e) => setSearchQuery(e.target.value), "onChange"), style: styles$7.searchInput, ref: searchInputRef }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(FaSearch, { style: styles$7.searchIcon })
                  ] }),
                  !isMobile && activeTypingUsers.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(TypingIndicatorEnhanced$1, { users: activeTypingUsers }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: /* @__PURE__ */ __name(() => toggleModal("notifications"), "onClick"), style: { ...styles$7.iconButton, color: modals.notifications ? "#5865f2" : "#b9bbbe", position: "relative" }, title: "Bildirimler", children: /* @__PURE__ */ jsxRuntimeExports.jsx(FaBell, {}) }),
                  modals.notifications && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { position: "absolute", top: "54px", right: "20px", zIndex: 1e3 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingSpinner, { size: "small", text: "" }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(NotificationDropdown, { currentUser: username, onClose: /* @__PURE__ */ __name(() => closeModal("notifications"), "onClose"), fetchWithAuth, apiBaseUrl: ABSOLUTE_HOST_URL }) }) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "toolbar-menu-container", style: { position: "relative" }, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: /* @__PURE__ */ __name(() => toggleModal("toolbarMenu"), "onClick"), style: { ...styles$7.iconButton, color: modals.toolbarMenu ? "#5865f2" : "#b9bbbe", fontSize: "1.2em", fontWeight: "bold" }, title: "Daha Fazla", children: "â‹®" }),
                    modals.toolbarMenu && /* @__PURE__ */ jsxRuntimeExports.jsx(
                      ToolbarMenu,
                      {
                        activeChat,
                        hasKey,
                        modals,
                        soundSettings,
                        isInVoice,
                        username,
                        openModal,
                        closeModal,
                        toggleModal,
                        handleCopyLink,
                        toggleNotifications,
                        handleSummarize: messageHandlers.handleSummarize,
                        handleClearChat: messageHandlers.handleClearChat,
                        handleAdminDeleteConversation: messageHandlers.handleAdminDeleteConversation
                      }
                    )
                  ] }),
                  isMobile && !isRightSidebarVisible && /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: /* @__PURE__ */ __name(() => setIsRightSidebarVisible(true), "onClick"), style: { ...styles$7.mobileMenuButton, fontSize: "1.3em" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(FaUsers, {}) })
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: styles$7.messageBox, ref: messageBoxRef, onScroll: throttledHandleMessageScroll, children: /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: styles$7.systemMessage, children: "Mesajlar yÃ¼kleniyor..." }), children: messageHistoryLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: styles$7.systemMessage, children: "YÃ¼kleniyor..." }) : optimizedMessages.length > 50 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                VirtualMessageList,
                {
                  messages: optimizedMessages,
                  scrollToBottom: true,
                  renderMessage: /* @__PURE__ */ __name((msg, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Message,
                    {
                      msg,
                      currentUser: username,
                      absoluteHostUrl: ABSOLUTE_HOST_URL,
                      isAdmin,
                      onImageClick: setZoomedImage,
                      fetchWithAuth,
                      allUsers,
                      getDeterministicAvatar,
                      onShowChart: setChartSymbol,
                      onDelete: messageHandlers.handleDeleteMessage,
                      onStartEdit: setEditingMessage,
                      onSetReply: setReplyingTo,
                      onToggleReaction: /* @__PURE__ */ __name(() => {
                      }, "onToggleReaction"),
                      onStartForward: setForwardingMessage,
                      isSelectionMode,
                      isSelected: selectedMessages.has(msg.id),
                      onToggleSelection: /* @__PURE__ */ __name((id) => {
                        const s = new Set(selectedMessages);
                        if (s.has(id)) s.delete(id);
                        else s.add(id);
                        setSelectedMessages(s);
                      }, "onToggleSelection"),
                      onScrollToMessage: messageHandlers.scrollToMessage,
                      onViewProfile: /* @__PURE__ */ __name((u) => setViewingProfile(allUsers.find((usr) => usr.username === u)), "onViewProfile"),
                      onTogglePin: messageHandlers.handleTogglePin,
                      onVisible: messageHandlers.handleMessageVisible
                    },
                    msg.id || msg.temp_id || index
                  ), "renderMessage")
                }
              ) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                (() => {
                  const elements = [];
                  let i = 0;
                  while (i < optimizedMessages.length) {
                    const msg = optimizedMessages[i];
                    const key = msg.id || msg.temp_id || i;
                    const prevMsg = i > 0 ? optimizedMessages[i - 1] : null;
                    const showDateDivider = !prevMsg || msg.timestamp && prevMsg.timestamp && new Date(msg.timestamp).toDateString() !== new Date(prevMsg.timestamp).toDateString();
                    if (isImageOnlyMessage(msg)) {
                      const galleryMsgs = [msg];
                      let j = i + 1;
                      while (j < optimizedMessages.length && isImageOnlyMessage(optimizedMessages[j]) && optimizedMessages[j].username === msg.username && msg.timestamp && optimizedMessages[j].timestamp && Math.abs(new Date(optimizedMessages[j].timestamp) - new Date(msg.timestamp)) < 3e5) {
                        galleryMsgs.push(optimizedMessages[j]);
                        j++;
                      }
                      if (galleryMsgs.length >= 2) {
                        elements.push(
                          /* @__PURE__ */ jsxRuntimeExports.jsxs(React.Fragment, { children: [
                            showDateDivider && msg.timestamp && /* @__PURE__ */ jsxRuntimeExports.jsx(MessageDateDivider$1, { date: msg.timestamp }),
                            /* @__PURE__ */ jsxRuntimeExports.jsx(
                              ImageGalleryGroup,
                              {
                                messages: galleryMsgs,
                                currentUser: username,
                                absoluteHostUrl: ABSOLUTE_HOST_URL,
                                isAdmin,
                                onOpenGallery: /* @__PURE__ */ __name((images, startIndex) => setGalleryData({ images, startIndex }), "onOpenGallery"),
                                onViewProfile: /* @__PURE__ */ __name((u) => setViewingProfile(allUsers.find((usr) => usr.username === u)), "onViewProfile"),
                                onDelete: messageHandlers.handleDeleteMessage,
                                allUsers,
                                getDeterministicAvatar,
                                fetchWithAuth,
                                onVisible: messageHandlers.handleMessageVisible
                              }
                            )
                          ] }, `gallery-${galleryMsgs.map((m) => m.id || m.temp_id).join("-")}`)
                        );
                        i = j;
                        continue;
                      }
                    }
                    elements.push(
                      /* @__PURE__ */ jsxRuntimeExports.jsxs(React.Fragment, { children: [
                        showDateDivider && msg.timestamp && /* @__PURE__ */ jsxRuntimeExports.jsx(MessageDateDivider$1, { date: msg.timestamp }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(
                          Message,
                          {
                            msg,
                            currentUser: username,
                            absoluteHostUrl: ABSOLUTE_HOST_URL,
                            isAdmin,
                            onImageClick: setZoomedImage,
                            fetchWithAuth,
                            allUsers,
                            getDeterministicAvatar,
                            onShowChart: setChartSymbol,
                            onDelete: messageHandlers.handleDeleteMessage,
                            onStartEdit: setEditingMessage,
                            onSetReply: setReplyingTo,
                            onToggleReaction: /* @__PURE__ */ __name(() => {
                            }, "onToggleReaction"),
                            onStartForward: setForwardingMessage,
                            isSelectionMode,
                            isSelected: selectedMessages.has(msg.id),
                            onToggleSelection: /* @__PURE__ */ __name((id) => {
                              const s = new Set(selectedMessages);
                              if (s.has(id)) s.delete(id);
                              else s.add(id);
                              setSelectedMessages(s);
                            }, "onToggleSelection"),
                            onScrollToMessage: messageHandlers.scrollToMessage,
                            onViewProfile: /* @__PURE__ */ __name((u) => setViewingProfile(allUsers.find((usr) => usr.username === u)), "onViewProfile"),
                            onTogglePin: messageHandlers.handleTogglePin,
                            onVisible: messageHandlers.handleMessageVisible
                          }
                        )
                      ] }, key)
                    );
                    i++;
                  }
                  return elements;
                })(),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref: messagesEndRef, style: { float: "left", clear: "both", height: 1 } })
              ] }) }) }),
              fileUpload.isDragging && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { position: "absolute", top: 0, left: 0, right: 0, bottom: 0, backgroundColor: "rgba(30, 31, 34, 0.9)", border: "3px dashed #5865f2", borderRadius: "8px", display: "flex", flexDirection: "column", alignItems: "center", justifyContent: "center", pointerEvents: "none", zIndex: 1e3 }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: "48px", marginBottom: "12px" }, children: "ðŸ“" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { color: "#5865f2", fontSize: "1.4em", fontWeight: "bold" }, children: "DosyalarÄ± buraya bÄ±rakÄ±n" })
              ] }),
              showScrollToBottom && /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollToBottomButton$1, { onClick: /* @__PURE__ */ __name(() => {
                scrollToBottom("smooth");
                setShowScrollToBottom(false);
              }, "onClick"), unreadCount: 0 }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { ...styles$7.inputContainer, paddingBottom: isNative ? `calc(16px + ${safeAreaBottom})` : isMobile ? "25px" : "16px" }, children: [
                fileUpload.isUploading && fileUpload.uploadProgress > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { position: "absolute", top: "-40px", left: "16px", right: "16px", backgroundColor: "#2b2d31", borderRadius: "8px", padding: "8px 12px", boxShadow: "0 2px 10px rgba(0,0,0,0.3)", zIndex: 1001 }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", gap: "10px" }, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { style: { color: "#b9bbbe", fontSize: "12px", whiteSpace: "nowrap" }, children: [
                    "ðŸ“¤ YÃ¼kleniyor: ",
                    fileUpload.uploadProgress,
                    "%"
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { flex: 1, height: "6px", backgroundColor: "#40444b", borderRadius: "3px", overflow: "hidden" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: `${fileUpload.uploadProgress}%`, height: "100%", backgroundColor: "#5865f2", borderRadius: "3px", transition: "width 0.3s ease" } }) })
                ] }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { padding: "12px", color: "#72767d" }, children: "YÃ¼kleniyor..." }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  MessageInput,
                  {
                    onSendMessage: messageHandlers.sendMessage,
                    onFileUpload: fileUpload.uploadFile,
                    onShowCodeSnippet: /* @__PURE__ */ __name(() => openModal("snippetModal"), "onShowCodeSnippet"),
                    placeholder: chatTitle ? `${activeChat.type === "dm" ? chatTitle : `# ${chatTitle}`} kanalÄ±na mesaj gÃ¶nder` : "Mesaj yaz...",
                    disabled: fileUpload.isUploading,
                    fetchWithAuth,
                    apiBaseUrl: ABSOLUTE_HOST_URL,
                    activeChat,
                    pendingFilesFromDrop: fileUpload.pendingFilesFromDrop,
                    onClearPendingFiles: /* @__PURE__ */ __name(() => fileUpload.setPendingFilesFromDrop([]), "onClearPendingFiles")
                  }
                ) })
              ] })
            ]
          }
        ),
        (!isMobile || isRightSidebarVisible) && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { ...styles$7.chatUserListPanel, ...isMobile ? styles$7.mobileRightSidebar : {}, paddingTop: mobileWebPadding }, children: [
          isMobile && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: styles$7.mobileSidebarHeader, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", gap: "8px" }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(FaUsers, { size: 18, color: "#b9bbbe" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: "16px", fontWeight: "bold", color: "white" }, children: activeChat.type === "room" ? "Sunucu Ãœyeleri" : "ArkadaÅŸlar" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: /* @__PURE__ */ __name(() => setIsRightSidebarVisible(false), "onClick"), style: styles$7.closeSidebarButton, children: /* @__PURE__ */ jsxRuntimeExports.jsx(FaTimes, {}) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingSpinner, { size: "small", text: "KullanÄ±cÄ±lar yÃ¼kleniyor..." }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            ChatUserList,
            {
              chatUsers: [],
              allUsers,
              onlineUsers,
              currentUser: username,
              currentUserProfile,
              getDeterministicAvatar,
              onUserClick: /* @__PURE__ */ __name((u) => {
                let user2 = allUsers.find((usr) => usr.username === u);
                if (!user2 && serverMembers.length > 0) {
                  const m = serverMembers.find((m2) => m2.username === u);
                  if (m) user2 = { username: m.username, display_name: m.username, avatar: getDeterministicAvatar(m.username), role: m.role || "member" };
                }
                if (user2) setViewingProfile(user2);
              }, "onUserClick"),
              onUserContextMenu: /* @__PURE__ */ __name((e, targetUsername) => {
                if (targetUsername === username) return;
                const targetUser = allUsers.find((u) => u.username === targetUsername);
                if (!targetUser) return;
                setUserContextMenu({ x: e.clientX, y: e.clientY, user: targetUser, permissions: currentUserPermissions });
              }, "onUserContextMenu"),
              activeChat,
              serverMembers,
              friendsList,
              onNavigate: navigateToPath
            }
          ) })
        ] })
      ] }),
      isInVoice && /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: null, children: /* @__PURE__ */ jsxRuntimeExports.jsx(VoiceAudioController, { remoteStreams, remoteVolumes, mutedUsers }) }),
      isInVoice && !showVoiceIsland && activeChat.type !== "voice" && /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          onClick: /* @__PURE__ */ __name(() => setShowVoiceIsland(true), "onClick"),
          style: { position: "fixed", bottom: "20px", right: "20px", zIndex: 9998, background: "#5865f2", color: "white", border: "none", borderRadius: "50%", width: "60px", height: "60px", display: "flex", alignItems: "center", justifyContent: "center", cursor: "pointer", fontSize: "24px", boxShadow: "0 4px 12px rgba(0,0,0,0.3)" },
          title: "Ses Panelini AÃ§",
          children: "ðŸŽ¤"
        }
      ),
      isInVoice && showVoiceIsland && activeChat.type !== "voice" && /* @__PURE__ */ jsxRuntimeExports.jsx(
        VoiceChatPanel,
        {
          roomName: currentVoiceRoom,
          onClose: /* @__PURE__ */ __name(() => setShowVoiceIsland(false), "onClose"),
          isMinimized: isVoicePanelMinimized,
          onToggleMinimize: /* @__PURE__ */ __name(() => setIsVoicePanelMinimized(!isVoicePanelMinimized), "onToggleMinimize"),
          getRealUserAvatar,
          allUsers,
          currentUserProfile
        }
      )
    ] }),
    userContextMenu && /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: null, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      UserContextMenu,
      {
        x: userContextMenu.x,
        y: userContextMenu.y,
        user: userContextMenu.user,
        currentUser: username,
        onClose: /* @__PURE__ */ __name(() => setUserContextMenu(null), "onClose"),
        onAction: serverHandlers.handleUserContextAction,
        voiceChannels: categories.flatMap((s) => (s.categories || []).flatMap((c) => (c.rooms || []).filter((r) => r.is_voice))),
        isAdmin,
        isInVoiceRoom: isInVoice,
        friendsList
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      InviteServerModal,
      {
        inviteToServerUser,
        setInviteToServerUser,
        categories,
        fetchWithAuth,
        API_BASE_URL
      }
    )
  ] });
}, "AppContent");
function App() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBoundary$1, { fallbackMessage: "Pawscord encountered an error. Please try refreshing the page.", children: /* @__PURE__ */ jsxRuntimeExports.jsx(VoiceProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(AppContent, {}) }) });
}
__name(App, "App");
const VERIFY_EMAIL_URL = `${API_BASE_URL$2}/auth/verify-email/`;
const VerifyEmailPage = /* @__PURE__ */ __name(() => {
  const { token } = useParams();
  const navigate = useNavigate();
  const [status, setStatus] = reactExports.useState("loading");
  const [message, setMessage] = reactExports.useState("HesabÄ±nÄ±z doÄŸrulanÄ±yor, lÃ¼tfen bekleyin...");
  reactExports.useEffect(() => {
    if (!token) {
      setStatus("error");
      setMessage("GeÃ§ersiz veya eksik doÄŸrulama kodu.");
      return;
    }
    const verify = /* @__PURE__ */ __name(async () => {
      try {
        const response = await fetch(`${VERIFY_EMAIL_URL}${token}/`);
        const data = await response.json();
        if (response.ok) {
          setStatus("success");
          setMessage("ÃœyeliÄŸiniz baÅŸarÄ±yla aktif edildi!");
        } else {
          setStatus("error");
          setMessage(data.message || "DoÄŸrulama baÅŸarÄ±sÄ±z oldu.");
        }
      } catch (error) {
        setStatus("error");
        setMessage("Sunucuya baÄŸlanÄ±lamadÄ±. LÃ¼tfen internet baÄŸlantÄ±nÄ±zÄ± kontrol edin.");
      }
    }, "verify");
    setTimeout(() => {
      verify();
    }, 1e3);
  }, [token]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: styles$6.container, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: styles$6.card, children: [
    status === "loading" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: styles$6.content, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(FaSpinner, { className: "spin-animation", size: 50, color: "#5865f2", style: { marginBottom: 20 } }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { style: styles$6.title, children: "DoÄŸrulanÄ±yor..." }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: styles$6.text, children: message })
    ] }),
    status === "success" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: styles$6.content, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(FaCheckCircle, { size: 60, color: "#43b581", style: { marginBottom: 20 } }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { style: { ...styles$6.title, color: "#43b581" }, children: "Tebrikler! ðŸŽ‰" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: styles$6.text, children: message }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: styles$6.subText, children: "ArtÄ±k Pawscord'a tam eriÅŸim saÄŸlayabilirsin." }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          onClick: /* @__PURE__ */ __name(() => navigate("/"), "onClick"),
          style: styles$6.primaryButton,
          children: "GÄ°RÄ°Åž YAP"
        }
      )
    ] }),
    status === "error" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: styles$6.content, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(FaTimesCircle, { size: 60, color: "#f04747", style: { marginBottom: 20 } }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { style: { ...styles$6.title, color: "#f04747" }, children: "Hata OluÅŸtu" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: styles$6.text, children: message }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          onClick: /* @__PURE__ */ __name(() => navigate("/"), "onClick"),
          style: styles$6.secondaryButton,
          children: "Ana Sayfaya DÃ¶n"
        }
      )
    ] })
  ] }) });
}, "VerifyEmailPage");
const styles$6 = {
  container: {
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    height: "100dvh",
    backgroundColor: "#1e1f22",
    // Pawscord koyu tema
    fontFamily: "'Poppins', sans-serif",
    padding: "20px"
  },
  card: {
    backgroundColor: "#2b2d31",
    padding: "40px",
    borderRadius: "12px",
    boxShadow: "0 8px 24px rgba(0,0,0,0.5)",
    maxWidth: "400px",
    width: "100%",
    textAlign: "center",
    border: "1px solid #1f2023"
  },
  content: {
    display: "flex",
    flexDirection: "column",
    alignItems: "center"
  },
  title: {
    margin: "0 0 10px 0",
    color: "#fff",
    fontSize: "1.8em"
  },
  text: {
    color: "#dbdee1",
    fontSize: "1.1em",
    margin: "0 0 20px 0",
    lineHeight: "1.5"
  },
  subText: {
    color: "#949ba4",
    fontSize: "0.9em",
    marginBottom: "30px"
  },
  primaryButton: {
    backgroundColor: "#5865f2",
    color: "white",
    border: "none",
    padding: "12px 30px",
    borderRadius: "5px",
    fontSize: "1em",
    fontWeight: "bold",
    cursor: "pointer",
    transition: "background-color 0.2s",
    width: "100%"
  },
  secondaryButton: {
    backgroundColor: "#4f545c",
    color: "white",
    border: "none",
    padding: "12px 30px",
    borderRadius: "5px",
    fontSize: "1em",
    fontWeight: "bold",
    cursor: "pointer",
    width: "100%"
  }
};
const styleSheet$3 = document.createElement("style");
styleSheet$3.innerText = `
  .spin-animation { animation: spin 1s linear infinite; }
  @keyframes spin { 100% { transform: rotate(360deg); } }
`;
document.head.appendChild(styleSheet$3);
const VerifyEmailPage$1 = React.memo(VerifyEmailPage);
const InvitePage = /* @__PURE__ */ __name(() => {
  const { code } = useParams();
  const navigate = useNavigate();
  const { isAuthenticated, token } = useAuth();
  const [inviteInfo, setInviteInfo] = reactExports.useState(null);
  const [loading, setLoading] = reactExports.useState(true);
  const [error, setError] = reactExports.useState("");
  const [joining, setJoining] = reactExports.useState(false);
  const [joined, setJoined] = reactExports.useState(false);
  reactExports.useEffect(() => {
    fetchInviteInfo();
  }, [code]);
  const fetchInviteInfo = /* @__PURE__ */ __name(async () => {
    setLoading(true);
    setError("");
    try {
      const res = await fetch(`${API_BASE_URL$2}/invites/${code}/`);
      const contentType = res.headers.get("content-type") || "";
      if (!contentType.includes("application/json")) {
        console.error("âŒ [Invite Page] Non-JSON response:", contentType);
        setError("Davet bulunamadÄ± veya geÃ§ersiz");
        setLoading(false);
        return;
      }
      const data = await res.json();
      if (res.ok) {
        setInviteInfo(data);
      } else {
        setError(data.error || "Davet bulunamadÄ±");
        console.error("âŒ [Invite Page] Error:", data.error);
      }
    } catch (err) {
      console.error("âŒ [Invite Page] Network error:", err);
      setError("BaÄŸlantÄ± hatasÄ±. LÃ¼tfen tekrar deneyin.");
    }
    setLoading(false);
  }, "fetchInviteInfo");
  const handleAccept = /* @__PURE__ */ __name(async () => {
    if (!isAuthenticated) {
      toast.error("âŒ LÃ¼tfen Ã¶nce giriÅŸ yapÄ±n!");
      sessionStorage.setItem("pending_invite", code);
      navigate("/");
      return;
    }
    if (!token) {
      console.error("âŒ [Invite Page] No token found!");
      toast.error("âŒ GiriÅŸ token'Ä± bulunamadÄ±. LÃ¼tfen tekrar giriÅŸ yapÄ±n.");
      navigate("/");
      return;
    }
    setJoining(true);
    setError("");
    try {
      const isVanity = inviteInfo?.type === "vanity";
      const url = isVanity ? `${API_BASE_URL$2}/servers/${inviteInfo.server.id}/join/` : `${API_BASE_URL$2}/invites/${code}/accept/`;
      const res = await fetch(url, {
        method: "POST",
        headers: {
          "Authorization": `Bearer ${token}`,
          "Content-Type": "application/json"
        }
      });
      const data = await res.json();
      if (res.ok) {
        toast.success(`âœ… BaÅŸarÄ±lÄ±! ${data.server_name || "Sunucu"}ya katÄ±ldÄ±nÄ±z!`);
        setJoined(true);
        const redirectUrl = data.redirect || "/";
        setTimeout(() => {
          if (redirectUrl.startsWith("http")) {
            window.location.href = redirectUrl;
          } else {
            navigate(redirectUrl);
          }
        }, 2e3);
      } else {
        const errorMsg = data.error || data.message || "Sunucuya katÄ±lma hatasÄ±";
        console.error("âŒ [Invite Page] Join failed:", errorMsg, data);
        setError(errorMsg);
        toast.error(`âŒ Hata: ${errorMsg}`);
      }
    } catch (err) {
      console.error("âŒ [Invite Page] Exception:", err);
      const errorMsg = err.message || "BaÄŸlantÄ± hatasÄ±";
      setError(errorMsg);
      toast.error(`âŒ Hata: ${errorMsg}`);
    }
    setJoining(false);
  }, "handleAccept");
  if (loading) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: styles$5.container, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: styles$5.backgroundGradient }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: styles$5.card, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: styles$5.spinner }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: styles$5.loadingText, children: "Davet yÃ¼kleniyor..." })
      ] })
    ] });
  }
  if (error) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: styles$5.container, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: styles$5.backgroundGradient }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: styles$5.card, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(FaTimesCircle, { size: 64, color: "var(--error)" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { style: styles$5.errorTitle, children: "Hata" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: styles$5.errorText, children: error }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: /* @__PURE__ */ __name(() => navigate("/"), "onClick"), style: styles$5.homeButton, children: "Ana Sayfaya DÃ¶n" })
      ] })
    ] });
  }
  if (joined) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: styles$5.container, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: styles$5.backgroundGradient }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: styles$5.card, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(FaCheckCircle, { size: 64, color: "var(--success)" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { style: styles$5.successTitle, children: "BaÅŸarÄ±lÄ±!" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { style: styles$5.successText, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: inviteInfo.server.name }),
          " sunucusuna katÄ±ldÄ±nÄ±z!"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: styles$5.redirectText, children: "Ana sayfaya yÃ¶nlendiriliyorsunuz..." })
      ] })
    ] });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: styles$5.container, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: styles$5.backgroundGradient }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: styles$5.card, children: [
      inviteInfo.server.icon && /* @__PURE__ */ jsxRuntimeExports.jsx(
        "img",
        {
          src: inviteInfo.server.icon,
          alt: inviteInfo.server.name,
          style: styles$5.serverIcon
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("h1", { style: styles$5.serverName, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(FaServer, { style: styles$5.icon }),
        inviteInfo.server.name
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: styles$5.infoRow, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(FaUsers, { style: styles$5.infoIcon }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
          inviteInfo.server.member_count,
          " Ãœye"
        ] })
      ] }),
      inviteInfo.expires_at && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: styles$5.infoRow, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(FaClock, { style: styles$5.infoIcon }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
          "SÃ¼re: ",
          new Date(inviteInfo.expires_at).toLocaleString("tr-TR")
        ] })
      ] }),
      inviteInfo.max_uses > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: styles$5.infoRow, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
        "KullanÄ±m: ",
        inviteInfo.uses,
        " / ",
        inviteInfo.max_uses
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: styles$5.inviterInfo, children: [
        "Davet Eden: ",
        /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: inviteInfo.inviter.username })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          onClick: handleAccept,
          disabled: joining,
          style: {
            ...styles$5.joinButton,
            ...joining ? styles$5.joinButtonDisabled : {}
          },
          children: joining ? "KatÄ±lÄ±nÄ±yor..." : !isAuthenticated ? "GiriÅŸ Yap ve KatÄ±l" : "Sunucuya KatÄ±l"
        }
      ),
      !isAuthenticated && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: styles$5.loginHint, children: "* Sunucuya katÄ±lmak iÃ§in giriÅŸ yapmanÄ±z gerekiyor" })
    ] })
  ] });
}, "InvitePage");
const styles$5 = {
  container: {
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    minHeight: "100vh",
    background: "var(--bg-app)",
    padding: "20px",
    position: "relative",
    overflow: "hidden"
  },
  backgroundGradient: {
    position: "absolute",
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    background: "radial-gradient(ellipse at top, rgba(139, 92, 246, 0.15), transparent 50%), radial-gradient(ellipse at bottom, rgba(118, 75, 162, 0.15), transparent 50%)",
    pointerEvents: "none",
    zIndex: 0
  },
  card: {
    background: "var(--glass-bg)",
    backdropFilter: "blur(20px)",
    WebkitBackdropFilter: "blur(20px)",
    padding: "48px",
    borderRadius: "var(--radius-2xl)",
    textAlign: "center",
    color: "var(--text-primary)",
    maxWidth: "560px",
    width: "100%",
    boxShadow: "var(--shadow-2xl)",
    border: "1px solid var(--glass-border)",
    position: "relative",
    zIndex: 1,
    animation: "scaleIn 0.4s ease-out"
  },
  spinner: {
    width: "50px",
    height: "50px",
    border: "3px solid var(--glass-border)",
    borderTop: "3px solid var(--brand-primary)",
    borderRadius: "50%",
    animation: "spin 0.8s linear infinite",
    margin: "0 auto"
  },
  loadingText: {
    marginTop: "24px",
    color: "var(--text-tertiary)",
    fontSize: "15px",
    fontWeight: 500
  },
  serverIcon: {
    width: "120px",
    height: "120px",
    borderRadius: "50%",
    marginBottom: "24px",
    objectFit: "cover",
    border: "4px solid var(--glass-border)",
    boxShadow: "0 8px 24px rgba(0, 0, 0, 0.2)",
    transition: "var(--transition-normal)"
  },
  serverName: {
    fontSize: "32px",
    fontWeight: 800,
    marginBottom: "24px",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    gap: "12px",
    background: "var(--gradient-primary)",
    WebkitBackgroundClip: "text",
    WebkitTextFillColor: "transparent",
    backgroundClip: "text"
  },
  icon: {
    fontSize: "28px",
    color: "var(--brand-primary)"
  },
  infoRow: {
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    gap: "10px",
    margin: "16px 0",
    color: "var(--text-secondary)",
    fontSize: "16px",
    fontWeight: 500,
    padding: "12px 20px",
    background: "var(--bg-elevated)",
    borderRadius: "var(--radius-md)",
    border: "1px solid var(--glass-border)"
  },
  infoIcon: {
    fontSize: "20px",
    color: "var(--brand-primary)"
  },
  inviterInfo: {
    marginTop: "24px",
    marginBottom: "32px",
    color: "var(--text-tertiary)",
    fontSize: "14px",
    padding: "16px",
    background: "var(--bg-elevated)",
    borderRadius: "var(--radius-md)",
    border: "1px solid var(--glass-border)"
  },
  joinButton: {
    background: "var(--gradient-primary)",
    color: "white",
    border: "none",
    padding: "16px 32px",
    borderRadius: "var(--radius-md)",
    cursor: "pointer",
    fontSize: "16px",
    fontWeight: 700,
    marginTop: "16px",
    width: "100%",
    transition: "var(--transition-normal)",
    boxShadow: "0 4px 20px rgba(139, 92, 246, 0.4)",
    position: "relative",
    overflow: "hidden"
  },
  joinButtonDisabled: {
    background: "var(--bg-tertiary)",
    cursor: "not-allowed",
    opacity: 0.6,
    boxShadow: "none"
  },
  loginHint: {
    marginTop: "20px",
    fontSize: "13px",
    color: "var(--warning)",
    fontStyle: "italic",
    fontWeight: 500
  },
  errorTitle: {
    color: "var(--error)",
    marginTop: "24px",
    fontSize: "28px",
    fontWeight: 700
  },
  errorText: {
    color: "var(--text-tertiary)",
    margin: "24px 0",
    fontSize: "15px",
    lineHeight: 1.6
  },
  successTitle: {
    color: "var(--success)",
    marginTop: "24px",
    fontSize: "28px",
    fontWeight: 700
  },
  successText: {
    color: "var(--text-primary)",
    margin: "24px 0",
    fontSize: "18px",
    fontWeight: 600
  },
  redirectText: {
    color: "var(--text-tertiary)",
    fontSize: "14px",
    marginTop: "12px",
    fontStyle: "italic"
  },
  homeButton: {
    background: "var(--bg-elevated)",
    color: "var(--text-primary)",
    border: "1px solid var(--glass-border)",
    padding: "14px 28px",
    borderRadius: "var(--radius-md)",
    cursor: "pointer",
    fontSize: "15px",
    fontWeight: 600,
    marginTop: "24px",
    transition: "var(--transition-normal)"
  }
};
const styleSheet$2 = document.createElement("style");
styleSheet$2.textContent = `
    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
`;
document.head.appendChild(styleSheet$2);
const RELOAD_KEY = "pawscord_chunk_reload";
const RELOAD_COUNT_KEY = "pawscord_chunk_reload_count";
const RELOAD_COOLDOWN = 1e4;
const MAX_RELOADS = 2;
function isChunkLoadError(error) {
  if (!error) return false;
  const msg = error.message || error.toString();
  return msg.includes("Failed to fetch dynamically imported module") || msg.includes("Loading chunk") || msg.includes("Loading CSS chunk") || msg.includes("ChunkLoadError") || msg.includes("Importing a module script failed") || msg.includes("error loading dynamically imported module");
}
__name(isChunkLoadError, "isChunkLoadError");
function lazyWithRetry(importFn, retries = 1) {
  return React.lazy(() => {
    return new Promise((resolve, reject) => {
      const attempt = /* @__PURE__ */ __name((retriesLeft) => {
        importFn().then(resolve).catch((error) => {
          if (retriesLeft > 0 && isChunkLoadError(error)) {
            console.warn(`âš ï¸ Chunk yÃ¼kleme hatasÄ±, retry... (${retriesLeft} kalan)`);
            setTimeout(() => attempt(retriesLeft - 1), 500);
          } else if (isChunkLoadError(error)) {
            handleChunkReload();
            reject(error);
          } else {
            reject(error);
          }
        });
      }, "attempt");
      attempt(retries);
    });
  });
}
__name(lazyWithRetry, "lazyWithRetry");
function handleChunkReload() {
  const lastReload = sessionStorage.getItem(RELOAD_KEY);
  const reloadCount = parseInt(sessionStorage.getItem(RELOAD_COUNT_KEY) || "0", 10);
  const now = Date.now();
  if (reloadCount >= MAX_RELOADS) {
    console.error("âŒ Chunk reload limiti aÅŸÄ±ldÄ±. Sonsuz dÃ¶ngÃ¼ engellendi.");
    console.error("ðŸ’¡ LÃ¼tfen Ctrl+Shift+R ile sayfayÄ± tamamen yenileyin.");
    return;
  }
  if (lastReload && now - parseInt(lastReload, 10) < RELOAD_COOLDOWN) {
    console.error("âŒ Chunk reload cooldown aktif â€” sonsuz dÃ¶ngÃ¼ engellendi");
    return;
  }
  console.warn(`ðŸ”„ Yeni versiyon algÄ±landÄ±, sayfa yenileniyor... (${reloadCount + 1}/${MAX_RELOADS})`);
  sessionStorage.setItem(RELOAD_KEY, now.toString());
  sessionStorage.setItem(RELOAD_COUNT_KEY, (reloadCount + 1).toString());
  window.location.reload();
}
__name(handleChunkReload, "handleChunkReload");
function handleChunkErrorInBoundary(error) {
  if (isChunkLoadError(error)) {
    handleChunkReload();
    return true;
  }
  return false;
}
__name(handleChunkErrorInBoundary, "handleChunkErrorInBoundary");
const EnglishVoicePractice = /* @__PURE__ */ __name(({ apiBaseUrl }) => {
  const [isRecording, setIsRecording] = reactExports.useState(false);
  const [messages, setMessages] = reactExports.useState([]);
  const [processing, setProcessing] = reactExports.useState(false);
  const mediaRecorderRef = reactExports.useRef(null);
  const audioChunksRef = reactExports.useRef([]);
  const messagesEndRef = reactExports.useRef(null);
  const { token } = useAuth();
  const scrollToBottom = /* @__PURE__ */ __name(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  }, "scrollToBottom");
  reactExports.useEffect(() => {
    scrollToBottom();
  }, [messages, processing]);
  const startRecording = /* @__PURE__ */ __name(async () => {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      mediaRecorderRef.current = new MediaRecorder(stream);
      audioChunksRef.current = [];
      mediaRecorderRef.current.ondataavailable = (event) => {
        if (event.data.size > 0) audioChunksRef.current.push(event.data);
      };
      mediaRecorderRef.current.onstop = handleStop;
      mediaRecorderRef.current.start();
      setIsRecording(true);
    } catch (err) {
      toast.error("âŒ Mikrofon izni gerekli!");
    }
  }, "startRecording");
  const stopRecording = /* @__PURE__ */ __name(() => {
    if (mediaRecorderRef.current && isRecording) {
      mediaRecorderRef.current.stop();
      setIsRecording(false);
    }
  }, "stopRecording");
  const handleStop = /* @__PURE__ */ __name(async () => {
    setProcessing(true);
    const audioBlob = new Blob(audioChunksRef.current, { type: "audio/webm" });
    const formData = new FormData();
    formData.append("audio", audioBlob, "voice.webm");
    try {
      const res = await fetch(`${apiBaseUrl}/eng-learn/voice-chat/`, {
        method: "POST",
        headers: {
          "Authorization": `Bearer ${token}`
          // Content-Type EKLENMEMELÄ°DÄ°R (FormData otomatik ekler)
        },
        body: formData
      });
      if (res.ok) {
        const data = await res.json();
        setMessages((prev) => [
          ...prev,
          { sender: "user", text: data.user_text },
          { sender: "ai", text: data.ai_text }
        ]);
        const audio = new Audio(`data:audio/mp3;base64,${data.audio_base64}`);
        audio.play();
      } else {
        console.error("Sunucu hatasÄ±:", res.status);
        toast.error("âŒ AnlaÅŸÄ±lamadÄ± veya hata oluÅŸtu.");
      }
    } catch (e) {
      console.error(e);
      toast.error("âŒ BaÄŸlantÄ± hatasÄ±.");
    } finally {
      setProcessing(false);
    }
  }, "handleStop");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: styles$4.container, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: styles$4.header, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Link, { to: "/eng-learn", style: styles$4.backBtn, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(FaArrowLeft, {}),
        " Geri"
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "AI ile KonuÅŸ (Speaking)" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: styles$4.chatArea, children: [
      messages.length === 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: styles$4.emptyState, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(FaRobot, { size: 60, color: "#5865f2", style: { marginBottom: 20 } }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Ä°ngilizce Pratik Yap" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Mikrofona basÄ±lÄ± tut ve konuÅŸmaya baÅŸla." }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("small", { style: { color: "#72767d" }, children: '"Hello, how are you?" diyebilirsin.' })
      ] }),
      messages.map((msg, i) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
        ...styles$4.messageBubble,
        alignSelf: msg.sender === "user" ? "flex-end" : "flex-start",
        backgroundColor: msg.sender === "user" ? "#5865f2" : "#2b2d31",
        color: "white",
        borderBottomRightRadius: msg.sender === "user" ? "0" : "12px",
        borderBottomLeftRadius: msg.sender === "ai" ? "0" : "12px"
      }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: styles$4.msgHeader, children: [
          msg.sender === "user" ? /* @__PURE__ */ jsxRuntimeExports.jsx(FaUser, { size: 12 }) : /* @__PURE__ */ jsxRuntimeExports.jsx(FaRobot, { size: 12 }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { marginLeft: 5, fontSize: "0.8em", fontWeight: "bold" }, children: msg.sender === "user" ? "Sen" : "AI Ã–ÄŸretmen" })
        ] }),
        msg.text
      ] }, i)),
      processing && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { alignSelf: "flex-start", color: "#949ba4", marginLeft: 10, fontStyle: "italic" }, children: "YazÄ±yor ve seslendiriyor..." }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref: messagesEndRef })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: styles$4.controls, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          onMouseDown: startRecording,
          onMouseUp: stopRecording,
          onTouchStart: startRecording,
          onTouchEnd: stopRecording,
          style: {
            ...styles$4.micButton,
            backgroundColor: isRecording ? "#f04747" : "#5865f2",
            transform: isRecording ? "scale(1.1)" : "scale(1)"
          },
          children: isRecording ? /* @__PURE__ */ jsxRuntimeExports.jsx(FaStop, { size: 24 }) : /* @__PURE__ */ jsxRuntimeExports.jsx(FaMicrophone, { size: 30 })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { marginTop: 15, color: "#949ba4", fontSize: "0.9em" }, children: isRecording ? "Dinliyor... (BÄ±rakÄ±nca GÃ¶nderir)" : "BasÄ±lÄ± Tut ve KonuÅŸ" })
    ] })
  ] });
}, "EnglishVoicePractice");
const styles$4 = {
  container: {
    display: "flex",
    flexDirection: "column",
    height: "100%",
    backgroundColor: "#313338",
    color: "white",
    padding: "20px",
    boxSizing: "border-box",
    fontFamily: "Poppins, sans-serif"
  },
  header: { display: "flex", alignItems: "center", gap: "15px", marginBottom: "20px", borderBottom: "1px solid #1f2023", paddingBottom: "15px" },
  backBtn: { color: "#b9bbbe", fontSize: "1em", textDecoration: "none", display: "flex", alignItems: "center", gap: "5px", fontWeight: "600" },
  chatArea: {
    flex: 1,
    overflowY: "auto",
    display: "flex",
    flexDirection: "column",
    gap: "15px",
    paddingBottom: "20px",
    paddingRight: "5px"
    // Scrollbar iÃ§in
  },
  emptyState: { display: "flex", flexDirection: "column", alignItems: "center", justifyContent: "center", height: "100%", color: "#949ba4", opacity: 0.8, textAlign: "center" },
  messageBubble: {
    maxWidth: "85%",
    padding: "15px",
    borderRadius: "12px",
    fontSize: "1em",
    lineHeight: "1.5",
    boxShadow: "0 2px 5px rgba(0,0,0,0.1)",
    position: "relative"
  },
  msgHeader: { display: "flex", alignItems: "center", marginBottom: "5px", opacity: 0.8 },
  controls: { display: "flex", flexDirection: "column", alignItems: "center", paddingTop: "20px", borderTop: "1px solid #1f2023" },
  micButton: {
    width: "80px",
    height: "80px",
    borderRadius: "50%",
    border: "none",
    color: "white",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    cursor: "pointer",
    transition: "all 0.1s ease",
    boxShadow: "0 5px 20px rgba(0,0,0,0.4)"
  }
};
const pronunciationList = [
  // --- ðŸŸ¢ KOLAY (IsÄ±nma TurlarÄ±) ---
  { text: "Hello", difficulty: "Kolay" },
  { text: "Water", difficulty: "Kolay" },
  { text: "Friend", difficulty: "Kolay" },
  { text: "Family", difficulty: "Kolay" },
  { text: "Music", difficulty: "Kolay" },
  { text: "School", difficulty: "Kolay" },
  { text: "Computer", difficulty: "Kolay" },
  { text: "Beautiful", difficulty: "Kolay" },
  { text: "Together", difficulty: "Kolay" },
  { text: "Morning", difficulty: "Kolay" },
  { text: "Happy", difficulty: "Kolay" },
  { text: "Garden", difficulty: "Kolay" },
  { text: "People", difficulty: "Kolay" },
  { text: "Coffee", difficulty: "Kolay" },
  { text: "Purple", difficulty: "Kolay" },
  // --- ðŸ”µ ORTA (Ä°ÅŸ ve GÃ¼nlÃ¼k Hayat) ---
  { text: "Technology", difficulty: "Orta" },
  { text: "Development", difficulty: "Orta" },
  { text: "Environment", difficulty: "Orta" },
  { text: "Successfully", difficulty: "Orta" },
  { text: "Opportunity", difficulty: "Orta" },
  { text: "Government", difficulty: "Orta" },
  { text: "Communication", difficulty: "Orta" },
  { text: "Experience", difficulty: "Orta" },
  { text: "Available", difficulty: "Orta" },
  { text: "Management", difficulty: "Orta" },
  { text: "International", difficulty: "Orta" },
  { text: "Recommendation", difficulty: "Orta" },
  { text: "Responsibility", difficulty: "Orta" },
  { text: "Understand", difficulty: "Orta" },
  { text: "Literature", difficulty: "Orta" },
  { text: "Necessary", difficulty: "Orta" },
  { text: "Vocabulary", difficulty: "Orta" },
  { text: "Interesting", difficulty: "Orta" },
  { text: "Comfortable", difficulty: "Orta" },
  { text: "Vegetable", difficulty: "Orta" },
  // --- ðŸ”´ ZOR (Dikkat Gerektirenler) ---
  { text: "Squirrel", difficulty: "Zor" },
  { text: "Schedule", difficulty: "Zor" },
  { text: "Queue", difficulty: "Zor" },
  { text: "Rural", difficulty: "Zor" },
  { text: "Brewery", difficulty: "Zor" },
  { text: "Phenomenon", difficulty: "Zor" },
  { text: "February", difficulty: "Zor" },
  { text: "Library", difficulty: "Zor" },
  { text: "Specific", difficulty: "Zor" },
  { text: "Regularly", difficulty: "Zor" },
  { text: "Probably", difficulty: "Zor" },
  { text: "Algorithm", difficulty: "Zor" },
  { text: "Hierarchical", difficulty: "Zor" },
  { text: "Maintenance", difficulty: "Zor" },
  { text: "Pronunciation", difficulty: "Zor" },
  { text: "Throughout", difficulty: "Zor" },
  { text: "Entrepreneur", difficulty: "Zor" },
  { text: "Simultaneously", difficulty: "Zor" },
  { text: "Mischievous", difficulty: "Zor" },
  { text: "Chaos", difficulty: "Zor" },
  { text: "Recipe", difficulty: "Zor" },
  // --- ðŸ”¥ EFSANE (Telaffuz KabuslarÄ±) ---
  { text: "Worcestershire", difficulty: "Efsane" },
  { text: "Colonel", difficulty: "Efsane" },
  { text: "Miscellaneous", difficulty: "Efsane" },
  { text: "Anesthetist", difficulty: "Efsane" },
  { text: "Otorhinolaryngologist", difficulty: "Efsane" },
  { text: "Isthmus", difficulty: "Efsane" },
  { text: "Anemone", difficulty: "Efsane" },
  { text: "Synecdoche", difficulty: "Efsane" },
  { text: "Onomatopoeia", difficulty: "Efsane" },
  { text: "Conscientious", difficulty: "Efsane" },
  { text: "Defibrillator", difficulty: "Efsane" },
  { text: "Antidisestablishmentarianism", difficulty: "Efsane" },
  // --- ðŸ’¬ CÃœMLELER (AkÄ±cÄ±lÄ±k Testi) ---
  { text: "How are you doing today?", difficulty: "CÃ¼mle" },
  { text: "I would like to order a coffee.", difficulty: "CÃ¼mle" },
  { text: "The quick brown fox jumps over the lazy dog.", difficulty: "CÃ¼mle" },
  { text: "Can you please repeat that?", difficulty: "CÃ¼mle" },
  { text: "I am learning to speak English fluently.", difficulty: "CÃ¼mle" },
  { text: "It is raining cats and dogs outside.", difficulty: "CÃ¼mle" },
  { text: "Actions speak louder than words.", difficulty: "CÃ¼mle" },
  { text: "I need to schedule a meeting for tomorrow.", difficulty: "CÃ¼mle" },
  { text: "What do you do for a living?", difficulty: "CÃ¼mle" },
  // --- ðŸŒ€ TEKERLEMELER (Tongue Twisters) ---
  { text: "She sells seashells by the seashore.", difficulty: "Tekerleme" },
  { text: "Red lorry, yellow lorry.", difficulty: "Tekerleme" },
  { text: "Peter Piper picked a peck of pickled peppers.", difficulty: "Tekerleme" },
  { text: "How much wood would a woodchuck chuck?", difficulty: "Tekerleme" },
  { text: "Unique New York.", difficulty: "Tekerleme" },
  { text: "Fuzzy Wuzzy was a bear.", difficulty: "Tekerleme" },
  { text: "Which wristwatches are Swiss wristwatches?", difficulty: "Tekerleme" }
];
const PronunciationPage = /* @__PURE__ */ __name(({ apiBaseUrl }) => {
  const { token } = useAuth();
  const [currentCard, setCurrentCard] = reactExports.useState(null);
  const [isRecording, setIsRecording] = reactExports.useState(false);
  const [processing, setProcessing] = reactExports.useState(false);
  const [status, setStatus] = reactExports.useState("idle");
  const [feedbackMsg, setFeedbackMsg] = reactExports.useState("");
  const [score, setScore] = reactExports.useState(0);
  const mediaRecorderRef = reactExports.useRef(null);
  const audioChunksRef = reactExports.useRef([]);
  reactExports.useEffect(() => {
    pickRandomCard();
  }, []);
  const pickRandomCard = /* @__PURE__ */ __name(() => {
    const randomIndex = Math.floor(Math.random() * pronunciationList.length);
    setCurrentCard(pronunciationList[randomIndex]);
    setStatus("idle");
    setFeedbackMsg("");
  }, "pickRandomCard");
  const playPronunciation = /* @__PURE__ */ __name(async () => {
    if (!currentCard) return;
    try {
      const res = await fetch(`${apiBaseUrl}/eng-learn/speak-text/`, {
        method: "POST",
        headers: {
          "Authorization": `Bearer ${token}`,
          "Content-Type": "application/json"
        },
        body: JSON.stringify({ text: currentCard.text })
      });
      if (res.ok) {
        const data = await res.json();
        const audio = new Audio(`data:audio/mp3;base64,${data.audio_base64}`);
        audio.play();
      }
    } catch (e) {
      console.error(e);
    }
  }, "playPronunciation");
  const startRecording = /* @__PURE__ */ __name(async () => {
    setFeedbackMsg("");
    setStatus("recording");
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      mediaRecorderRef.current = new MediaRecorder(stream);
      audioChunksRef.current = [];
      mediaRecorderRef.current.ondataavailable = (e) => {
        if (e.data.size > 0) audioChunksRef.current.push(e.data);
      };
      mediaRecorderRef.current.onstop = handleStop;
      mediaRecorderRef.current.start();
      setIsRecording(true);
    } catch (err) {
      toast.error("âŒ Mikrofon izni gerekli!");
      setStatus("idle");
    }
  }, "startRecording");
  const stopRecording = /* @__PURE__ */ __name(() => {
    if (mediaRecorderRef.current && isRecording) {
      mediaRecorderRef.current.stop();
      setIsRecording(false);
    }
  }, "stopRecording");
  const handleStop = /* @__PURE__ */ __name(async () => {
    setProcessing(true);
    const audioBlob = new Blob(audioChunksRef.current, { type: "audio/webm" });
    const formData = new FormData();
    formData.append("audio", audioBlob, "voice.webm");
    formData.append("target_text", currentCard.text);
    try {
      const res = await fetch(`${apiBaseUrl}/eng-learn/check-pronunciation/`, {
        method: "POST",
        headers: { "Authorization": `Bearer ${token}` },
        body: formData
      });
      const data = await res.json();
      if (data.is_correct) {
        setStatus("success");
        setFeedbackMsg(`Harika! ðŸŽ‰ (${data.spoken_text})`);
        setScore((s) => s + 1);
      } else {
        setStatus("error");
        setFeedbackMsg(`AlgÄ±lanan: "${data.spoken_text || "???"}" - Tekrar dene!`);
      }
    } catch (e) {
      console.error(e);
      setFeedbackMsg("Sunucu hatasÄ±.");
      setStatus("error");
    } finally {
      setProcessing(false);
    }
  }, "handleStop");
  if (!currentCard) return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: styles$3.container, children: "YÃ¼kleniyor..." });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: styles$3.container, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: styles$3.header, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Link, { to: "/eng-learn", style: styles$3.backBtn, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(FaArrowLeft, {}),
        " Ã‡Ä±kÄ±ÅŸ"
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: styles$3.scoreBadge, children: [
        "Skor: ",
        score
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: styles$3.mainContent, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
        ...styles$3.card,
        borderColor: status === "success" ? "#43b581" : status === "error" ? "#f04747" : "transparent",
        boxShadow: status === "success" ? "0 0 30px rgba(67, 181, 129, 0.3)" : status === "error" ? "0 0 30px rgba(240, 71, 71, 0.3)" : "0 10px 30px rgba(0,0,0,0.3)"
      }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: {
          ...styles$3.difficulty,
          backgroundColor: currentCard.difficulty === "Efsane" ? "#eb459e" : currentCard.difficulty === "Zor" ? "#f04747" : "#202225",
          color: currentCard.difficulty === "Efsane" || currentCard.difficulty === "Zor" ? "white" : "#949ba4"
        }, children: currentCard.difficulty }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { style: styles$3.wordText, children: currentCard.text }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { height: "30px", marginTop: "10px", color: status === "success" ? "#43b581" : "#f04747", fontWeight: "bold" }, children: processing ? "Analiz ediliyor..." : feedbackMsg }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: styles$3.controls, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: playPronunciation, style: styles$3.iconButton, title: "DoÄŸrusunu Dinle", children: /* @__PURE__ */ jsxRuntimeExports.jsx(FaVolumeUp, { size: 24 }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              onMouseDown: startRecording,
              onMouseUp: stopRecording,
              onTouchStart: startRecording,
              onTouchEnd: stopRecording,
              style: {
                ...styles$3.micButton,
                backgroundColor: isRecording ? "#f04747" : status === "success" ? "#43b581" : "#5865f2",
                transform: isRecording ? "scale(1.1)" : "scale(1)"
              },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(FaMicrophone, { size: 32 })
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: styles$3.hint, children: isRecording ? "Dinliyor..." : "Mikrofona basÄ±lÄ± tut ve oku" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: styles$3.bottomNav, children: /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: pickRandomCard, style: styles$3.skipButton, children: status === "success" ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        "Sonraki Kelime ",
        /* @__PURE__ */ jsxRuntimeExports.jsx(FaForward, {})
      ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        "Bunu GeÃ§ ",
        /* @__PURE__ */ jsxRuntimeExports.jsx(FaRedo, {})
      ] }) }) })
    ] })
  ] });
}, "PronunciationPage");
const styles$3 = {
  container: {
    display: "flex",
    flexDirection: "column",
    height: "100%",
    backgroundColor: "#1e1f22",
    color: "white",
    padding: "20px",
    boxSizing: "border-box",
    fontFamily: "Poppins, sans-serif",
    alignItems: "center"
  },
  header: {
    width: "100%",
    maxWidth: "600px",
    display: "flex",
    justifyContent: "space-between",
    alignItems: "center",
    marginBottom: "40px"
  },
  backBtn: { color: "#b9bbbe", textDecoration: "none", display: "flex", alignItems: "center", gap: "8px", fontWeight: "600" },
  scoreBadge: { backgroundColor: "#f0b232", color: "#000", padding: "5px 15px", borderRadius: "20px", fontWeight: "bold" },
  mainContent: {
    flex: 1,
    display: "flex",
    flexDirection: "column",
    alignItems: "center",
    justifyContent: "center",
    width: "100%"
  },
  card: {
    backgroundColor: "#2b2d31",
    padding: "40px",
    borderRadius: "24px",
    width: "100%",
    maxWidth: "500px",
    // KartÄ± biraz geniÅŸlettik
    display: "flex",
    flexDirection: "column",
    alignItems: "center",
    textAlign: "center",
    border: "3px solid transparent",
    transition: "all 0.3s ease"
  },
  difficulty: {
    padding: "4px 12px",
    borderRadius: "12px",
    fontSize: "0.85em",
    marginBottom: "20px",
    fontWeight: "bold"
  },
  wordText: {
    fontSize: "2.2em",
    fontWeight: "800",
    margin: "0 0 10px 0",
    color: "#fff",
    letterSpacing: "1px",
    lineHeight: "1.3"
  },
  controls: {
    display: "flex",
    alignItems: "center",
    gap: "30px",
    marginTop: "30px"
  },
  iconButton: {
    width: "50px",
    height: "50px",
    borderRadius: "50%",
    border: "2px solid #40444b",
    backgroundColor: "transparent",
    color: "#b9bbbe",
    cursor: "pointer",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    transition: "all 0.2s"
  },
  micButton: {
    width: "80px",
    height: "80px",
    borderRadius: "50%",
    border: "none",
    color: "white",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    cursor: "pointer",
    boxShadow: "0 5px 20px rgba(0,0,0,0.4)",
    transition: "all 0.1s ease"
  },
  hint: { marginTop: "20px", color: "#72767d", fontSize: "0.9em" },
  bottomNav: { marginTop: "50px" },
  skipButton: {
    background: "transparent",
    border: "none",
    color: "#b9bbbe",
    fontSize: "1.1em",
    fontWeight: "600",
    cursor: "pointer",
    display: "flex",
    alignItems: "center",
    gap: "10px",
    padding: "10px 20px",
    borderRadius: "8px",
    transition: "background 0.2s",
    ":hover": { backgroundColor: "rgba(255,255,255,0.05)" }
  }
};
const PronunciationPage$1 = React.memo(PronunciationPage);
const SpotifyCallback = /* @__PURE__ */ __name(({ apiBaseUrl }) => {
  const [status, setStatus] = reactExports.useState("loading");
  const navigate = useNavigate();
  const location = useLocation();
  reactExports.useEffect(() => {
    const queryParams = new URLSearchParams(location.search);
    const code = queryParams.get("code");
    const error = queryParams.get("error");
    if (error) {
      setStatus("error");
      return;
    }
    if (code) {
      const token = localStorage.getItem("access_token");
      fetch(`${apiBaseUrl}/spotify/callback/`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${token}`
        },
        body: JSON.stringify({ code })
      }).then((res) => {
        if (res.ok) {
          setStatus("success");
          setTimeout(() => {
            navigate("/", { replace: true });
          }, 1500);
        } else {
          setStatus("error");
        }
      }).catch((err) => {
        console.error(err);
        setStatus("error");
      });
    }
  }, [location, apiBaseUrl, navigate]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: styles$2.container, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: styles$2.card, children: [
    status === "loading" && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(FaSpinner, { className: "spin", size: 50, color: "#1db954", style: { marginBottom: 20 } }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Spotify BaÄŸlanÄ±yor..." }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Token alÄ±nÄ±yor, lÃ¼tfen bekleyin." })
    ] }),
    status === "success" && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(FaCheckCircle, { size: 60, color: "#1db954", style: { marginBottom: 20 } }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { style: { color: "#1db954" }, children: "BaÅŸarÄ±lÄ±!" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "HesabÄ±n baÄŸlandÄ±. Sohbet ekranÄ±na dÃ¶nÃ¼lÃ¼yor..." })
    ] }),
    status === "error" && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(FaTimesCircle, { size: 60, color: "#f04747", style: { marginBottom: 20 } }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { style: { color: "#f04747" }, children: "Hata OluÅŸtu" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "BaÄŸlantÄ± kurulamadÄ±." }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: /* @__PURE__ */ __name(() => navigate("/"), "onClick"), style: styles$2.button, children: "Geri DÃ¶n" })
    ] })
  ] }) });
}, "SpotifyCallback");
const styles$2 = {
  container: {
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    height: "100dvh",
    backgroundColor: "#191414",
    color: "white",
    fontFamily: "Poppins, sans-serif"
  },
  card: {
    backgroundColor: "#282828",
    padding: "40px",
    borderRadius: "16px",
    textAlign: "center",
    boxShadow: "0 10px 30px rgba(0,0,0,0.5)",
    maxWidth: "400px",
    width: "90%"
  },
  button: {
    marginTop: "20px",
    padding: "10px 20px",
    borderRadius: "20px",
    border: "none",
    backgroundColor: "#1db954",
    color: "white",
    fontWeight: "bold",
    cursor: "pointer"
  }
};
const styleSheet$1 = document.createElement("style");
styleSheet$1.innerText = `
  .spin { animation: spin 1s linear infinite; }
  @keyframes spin { 100% { transform: rotate(360deg); } }
`;
document.head.appendChild(styleSheet$1);
const SpotifyCallback$1 = React.memo(SpotifyCallback);
const SignalNotification = /* @__PURE__ */ __name(() => {
  const { globalData } = useGlobalWebSocket();
  const [notification, setNotification] = reactExports.useState(null);
  const [visible, setVisible] = reactExports.useState(false);
  const navigate = useNavigate();
  reactExports.useEffect(() => {
    if (!globalData) return;
    if (globalData.type === "chat_message_handler" && globalData.username === "âš¡ Signal Bot") {
      const lines = globalData.content.split("\n");
      const coinLine = lines.find((l) => l.includes("ðŸª™")) || "Bilinmiyor";
      const dirLine = lines.find((l) => l.includes("ðŸ“ˆ")) || "";
      const newNotif = {
        title: "YENÄ° KRÄ°PTO SÄ°NYALÄ°! ðŸš¨",
        coin: coinLine.replace("ðŸª™", "").replace(/\*/g, "").trim(),
        direction: dirLine.includes("LONG") ? "YÃœKSELÄ°Åž (LONG)" : "DÃœÅžÃœÅž (SHORT)",
        isLong: dirLine.includes("LONG"),
        raw: globalData
      };
      setNotification(newNotif);
      setVisible(true);
      const timer = setTimeout(() => {
        setVisible(false);
      }, 8e3);
      return () => clearTimeout(timer);
    }
  }, [globalData]);
  if (!visible || !notification) return null;
  const handleClick = /* @__PURE__ */ __name(() => {
    setVisible(false);
    navigate("/");
  }, "handleClick");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: styles$1.container, className: "slide-in-notification", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: styles$1.iconBox, children: /* @__PURE__ */ jsxRuntimeExports.jsx(FaBitcoin, { size: 24, color: "#f0b232" }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: styles$1.content, onClick: handleClick, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { style: styles$1.title, children: notification.title }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: styles$1.details, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: styles$1.coinName, children: notification.coin }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: {
          ...styles$1.directionBadge,
          backgroundColor: notification.isLong ? "rgba(35, 165, 89, 0.2)" : "rgba(240, 71, 71, 0.2)",
          color: notification.isLong ? "#23a559" : "#da373c"
        }, children: notification.direction })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { style: styles$1.hint, children: [
        "Detaylar iÃ§in tÄ±kla ",
        /* @__PURE__ */ jsxRuntimeExports.jsx(FaArrowRight, { size: 10 })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: /* @__PURE__ */ __name((e) => {
      e.stopPropagation();
      setVisible(false);
    }, "onClick"), style: styles$1.closeButton, children: /* @__PURE__ */ jsxRuntimeExports.jsx(FaTimes, {}) })
  ] });
}, "SignalNotification");
const styles$1 = {
  container: {
    position: "fixed",
    top: "20px",
    right: "20px",
    width: "320px",
    backgroundColor: "#1e1f22",
    borderRadius: "8px",
    boxShadow: "0 8px 20px rgba(0,0,0,0.5)",
    borderLeft: "5px solid #f0b232",
    display: "flex",
    alignItems: "center",
    padding: "15px",
    zIndex: 99999,
    // En Ã¼stte
    cursor: "pointer",
    transition: "transform 0.3s ease-out"
  },
  iconBox: {
    marginRight: "15px",
    display: "flex",
    alignItems: "center"
  },
  content: {
    flex: 1,
    display: "flex",
    flexDirection: "column"
  },
  title: {
    margin: 0,
    color: "#fff",
    fontSize: "0.95em",
    fontWeight: "bold",
    marginBottom: "5px"
  },
  details: {
    display: "flex",
    alignItems: "center",
    justifyContent: "space-between",
    marginBottom: "5px"
  },
  coinName: {
    color: "#dcddde",
    fontWeight: "bold",
    fontSize: "1.1em"
  },
  directionBadge: {
    fontSize: "0.75em",
    padding: "2px 6px",
    borderRadius: "4px",
    fontWeight: "bold"
  },
  hint: {
    fontSize: "0.7em",
    color: "#949ba4",
    display: "flex",
    alignItems: "center",
    gap: "5px"
  },
  closeButton: {
    background: "none",
    border: "none",
    color: "#949ba4",
    cursor: "pointer",
    padding: "5px",
    marginLeft: "10px",
    fontSize: "1em"
  }
};
const styleSheet = document.createElement("style");
styleSheet.innerText = `
  @keyframes slideInRight {
    from { transform: translateX(100%); opacity: 0; }
    to { transform: translateX(0); opacity: 1; }
  }
  .slide-in-notification {
    animation: slideInRight 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
  }
`;
document.head.appendChild(styleSheet);
function useLoadGsiScript(options = {}) {
  const { nonce, onScriptLoadSuccess, onScriptLoadError } = options;
  const [scriptLoadedSuccessfully, setScriptLoadedSuccessfully] = reactExports.useState(false);
  const onScriptLoadSuccessRef = reactExports.useRef(onScriptLoadSuccess);
  onScriptLoadSuccessRef.current = onScriptLoadSuccess;
  const onScriptLoadErrorRef = reactExports.useRef(onScriptLoadError);
  onScriptLoadErrorRef.current = onScriptLoadError;
  reactExports.useEffect(() => {
    const scriptTag = document.createElement("script");
    scriptTag.src = "https://accounts.google.com/gsi/client";
    scriptTag.async = true;
    scriptTag.defer = true;
    scriptTag.nonce = nonce;
    scriptTag.onload = () => {
      var _a2;
      setScriptLoadedSuccessfully(true);
      (_a2 = onScriptLoadSuccessRef.current) === null || _a2 === void 0 ? void 0 : _a2.call(onScriptLoadSuccessRef);
    };
    scriptTag.onerror = () => {
      var _a2;
      setScriptLoadedSuccessfully(false);
      (_a2 = onScriptLoadErrorRef.current) === null || _a2 === void 0 ? void 0 : _a2.call(onScriptLoadErrorRef);
    };
    document.body.appendChild(scriptTag);
    return () => {
      document.body.removeChild(scriptTag);
    };
  }, [nonce]);
  return scriptLoadedSuccessfully;
}
__name(useLoadGsiScript, "useLoadGsiScript");
const GoogleOAuthContext = reactExports.createContext(null);
function GoogleOAuthProvider({ clientId, nonce, onScriptLoadSuccess, onScriptLoadError, children }) {
  const scriptLoadedSuccessfully = useLoadGsiScript({
    nonce,
    onScriptLoadSuccess,
    onScriptLoadError
  });
  const contextValue = reactExports.useMemo(() => ({
    clientId,
    scriptLoadedSuccessfully
  }), [clientId, scriptLoadedSuccessfully]);
  return React.createElement(GoogleOAuthContext.Provider, { value: contextValue }, children);
}
__name(GoogleOAuthProvider, "GoogleOAuthProvider");
const PageWrapper = /* @__PURE__ */ __name(({ children }) => {
  const isNative2 = Capacitor.isNativePlatform();
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
    width: "100%",
    height: "100dvh",
    boxSizing: "border-box",
    // ðŸ”¥ 1. TEKNÄ°K BOÅžLUK: Sadece APK ise Ã§entik payÄ± bÄ±rak
    paddingTop: isNative2 ? "max(35px, env(safe-area-inset-top))" : "0px",
    backgroundColor: "#1e1f22",
    // ðŸ”¥ 2. SCROLL BURADA OLACAK: Ä°Ã§indeki sayfalar scroll etmeyecek
    overflowY: "auto",
    overflowX: "hidden",
    display: "flex",
    flexDirection: "column"
  }, children });
}, "PageWrapper");
const _ErrorBoundary = class _ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    __publicField(this, "handleReset", /* @__PURE__ */ __name(() => {
      this.setState({ hasError: false, error: null, errorInfo: null });
      window.location.reload();
    }, "handleReset"));
    this.state = {
      hasError: false,
      error: null,
      errorInfo: null
    };
  }
  static getDerivedStateFromError(error) {
    return { hasError: true };
  }
  componentDidCatch(error, errorInfo) {
    if (isChunkLoadError(error)) {
      console.warn("ðŸ”„ Chunk yÃ¼kleme hatasÄ± algÄ±landÄ±, sayfa yenileniyor...");
      handleChunkErrorInBoundary(error);
      return;
    }
    console.error("ðŸ”´ App Crashed:", error);
    console.error("Error Info:", errorInfo);
    this.setState({
      error,
      errorInfo
    });
    try {
      const apiBase = typeof window !== "undefined" && window.__PAWSCORD_API_BASE__ || "https://api.pawscord.com/api";
      fetch(`${apiBase}/errors/report/`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          error: error?.toString(),
          stack: error?.stack,
          componentStack: errorInfo?.componentStack,
          url: window.location.href,
          userAgent: navigator.userAgent,
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        })
      }).catch(() => {
      });
    } catch (e) {
      console.warn("Could not report error:", e);
    }
  }
  render() {
    if (this.state.hasError) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: styles.container, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: styles.content, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: styles.icon, children: "ðŸ’¥" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { style: styles.title, children: "Oops! Bir ÅŸeyler ters gitti" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: styles.message, children: "ÃœzgÃ¼nÃ¼z, uygulama beklenmedik bir hatayla karÅŸÄ±laÅŸtÄ±." }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: styles.actions, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: this.handleReset, style: styles.button, children: "ðŸ”„ Yeniden BaÅŸlat" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              onClick: /* @__PURE__ */ __name(() => window.location.href = "/", "onClick"),
              style: { ...styles.button, ...styles.buttonSecondary },
              children: "ðŸ  Ana Sayfaya DÃ¶n"
            }
          )
        ] }),
        false
      ] }) });
    }
    return this.props.children;
  }
};
__name(_ErrorBoundary, "ErrorBoundary");
let ErrorBoundary = _ErrorBoundary;
const styles = {
  container: {
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    minHeight: "100vh",
    backgroundColor: "#1E1F22",
    color: "#FFFFFF",
    padding: "20px",
    fontFamily: "'Inter', sans-serif"
  },
  content: {
    textAlign: "center",
    maxWidth: "600px",
    padding: "40px",
    background: "linear-gradient(135deg, #2B2D31 0%, #1E1F22 100%)",
    borderRadius: "16px",
    boxShadow: "0 8px 32px rgba(0, 0, 0, 0.4)"
  },
  icon: {
    fontSize: "80px",
    marginBottom: "20px",
    animation: "shake 0.5s ease-in-out"
  },
  title: {
    fontSize: "32px",
    fontWeight: "bold",
    marginBottom: "16px",
    color: "#FFFFFF"
  },
  message: {
    fontSize: "16px",
    color: "#B9BBBE",
    marginBottom: "32px",
    lineHeight: "1.6"
  },
  actions: {
    display: "flex",
    gap: "12px",
    justifyContent: "center",
    flexWrap: "wrap"
  },
  button: {
    padding: "12px 24px",
    fontSize: "16px",
    fontWeight: "600",
    border: "none",
    borderRadius: "8px",
    cursor: "pointer",
    backgroundColor: "#5865F2",
    color: "#FFFFFF",
    transition: "all 0.2s",
    ":hover": {
      backgroundColor: "#4752C4"
    }
  },
  buttonSecondary: {
    backgroundColor: "#4E5058",
    ":hover": {
      backgroundColor: "#6A6F78"
    }
  }
};
const api = {
  async post(url, data, config = {}) {
    const headers = {
      "Content-Type": "application/json",
      ...config.headers
    };
    try {
      const response = await authFetch(url, {
        method: "POST",
        headers,
        body: JSON.stringify(data),
        credentials: "include"
      });
      const responseData = await response.json();
      if (!response.ok) {
        const error = new Error(responseData.error || "Request failed");
        error.response = { data: responseData, status: response.status };
        throw error;
      }
      return { data: responseData, status: response.status };
    } catch (error) {
      if (error.message === "No refresh token available") {
        const response = await fetch(url, {
          method: "POST",
          headers,
          body: JSON.stringify(data),
          credentials: "include"
        });
        const responseData = await response.json();
        if (!response.ok) {
          const err = new Error(responseData.error || "Request failed");
          err.response = { data: responseData, status: response.status };
          throw err;
        }
        return { data: responseData, status: response.status };
      }
      throw error;
    }
  },
  async get(url, config = {}) {
    const headers = {
      "Content-Type": "application/json",
      ...config.headers
    };
    try {
      const response = await authFetch(url, {
        method: "GET",
        headers,
        credentials: "include"
      });
      const responseData = await response.json();
      if (!response.ok) {
        const error = new Error(responseData.error || "Request failed");
        error.response = { data: responseData, status: response.status };
        throw error;
      }
      return { data: responseData, status: response.status };
    } catch (error) {
      if (error.message === "No refresh token available") {
        const response = await fetch(url, {
          method: "GET",
          headers,
          credentials: "include"
        });
        const responseData = await response.json();
        if (!response.ok) {
          const err = new Error(responseData.error || "Request failed");
          err.response = { data: responseData, status: response.status };
          throw err;
        }
        return { data: responseData, status: response.status };
      }
      throw error;
    }
  }
};
const AuthCallback = /* @__PURE__ */ __name(({ apiBaseUrl }) => {
  const [searchParams] = useSearchParams();
  const navigate = useNavigate();
  const { login } = useAuth();
  const [status, setStatus] = reactExports.useState("processing");
  const [error, setError] = reactExports.useState(null);
  const exchangeAttempted = reactExports.useRef(false);
  reactExports.useEffect(() => {
    const handleCallback = /* @__PURE__ */ __name(async () => {
      if (exchangeAttempted.current) {
        return;
      }
      exchangeAttempted.current = true;
      const code = searchParams.get("code");
      const accessToken = searchParams.get("access_token");
      const refreshToken2 = searchParams.get("refresh_token");
      const errorParam = searchParams.get("error");
      const needsPassword = searchParams.get("needs_password") === "true";
      if (errorParam) {
        console.error("ðŸ” [AuthCallback] Error param:", errorParam);
        setStatus("error");
        setError("Google giriÅŸ baÅŸarÄ±sÄ±z oldu. LÃ¼tfen tekrar deneyin.");
        setTimeout(() => navigate("/"), 3e3);
        return;
      }
      if (accessToken && refreshToken2) {
        try {
          localStorage.setItem("access_token", accessToken);
          localStorage.setItem("refresh_token", refreshToken2);
          if (login) {
            await login(accessToken, refreshToken2);
          }
          setStatus("success");
          setTimeout(() => {
            navigate(needsPassword ? "/settings?section=security&action=set-password" : "/");
          }, 1500);
        } catch (err) {
          console.error("ðŸ” [AuthCallback] Direct token error:", err);
          setStatus("error");
          setError("Token iÅŸleme hatasÄ±.");
          setTimeout(() => navigate("/"), 3e3);
        }
        return;
      }
      if (!code) {
        console.error("ðŸ” [AuthCallback] No code or tokens found");
        setStatus("error");
        setError("Yetkilendirme bilgisi bulunamadÄ±.");
        setTimeout(() => navigate("/"), 3e3);
        return;
      }
      try {
        setStatus("exchanging");
        const exchangeUrl = `${apiBaseUrl}/auth/exchange-code/`;
        const response = await api.post(exchangeUrl, {
          code
        });
        if (response.data.success) {
          const { access_token, refresh_token, user_id, needs_password } = response.data;
          localStorage.setItem("access_token", access_token);
          localStorage.setItem("refreshToken", refresh_token);
          if (login) {
            await login(access_token, refresh_token);
          }
          setStatus("success");
          if (needs_password) {
            setTimeout(() => {
              navigate("/settings?section=security&action=set-password");
            }, 1500);
          } else {
            setTimeout(() => {
              navigate("/");
            }, 1500);
          }
        } else {
          throw new Error(response.data.error || "Token exchange failed");
        }
      } catch (err) {
        console.error("Auth callback error:", err);
        setStatus("error");
        setError(err.response?.data?.error || "GiriÅŸ iÅŸlemi baÅŸarÄ±sÄ±z oldu.");
        setTimeout(() => navigate("/"), 3e3);
      }
    }, "handleCallback");
    handleCallback();
  }, [searchParams, navigate, login, apiBaseUrl]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "auth-callback-container", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "auth-callback-card", children: [
    status === "processing" && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "auth-spinner" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Ä°ÅŸleniyor..." }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Google hesabÄ±nÄ±z doÄŸrulanÄ±yor" })
    ] }),
    status === "exchanging" && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "auth-spinner" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "GiriÅŸ YapÄ±lÄ±yor..." }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "GÃ¼venli baÄŸlantÄ± kuruluyor" })
    ] }),
    status === "success" && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "auth-success-icon", children: "âœ“" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "GiriÅŸ BaÅŸarÄ±lÄ±!" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "YÃ¶nlendiriliyorsunuz..." })
    ] }),
    status === "error" && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "auth-error-icon", children: "âœ•" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Hata" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: error }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "auth-redirect-text", children: "Ana sayfaya yÃ¶nlendiriliyorsunuz..." })
    ] })
  ] }) });
}, "AuthCallback");
const isString = /* @__PURE__ */ __name((obj) => typeof obj === "string", "isString");
const defer = /* @__PURE__ */ __name(() => {
  let res;
  let rej;
  const promise = new Promise((resolve, reject) => {
    res = resolve;
    rej = reject;
  });
  promise.resolve = res;
  promise.reject = rej;
  return promise;
}, "defer");
const makeString = /* @__PURE__ */ __name((object) => {
  if (object == null) return "";
  return "" + object;
}, "makeString");
const copy = /* @__PURE__ */ __name((a, s, t) => {
  a.forEach((m) => {
    if (s[m]) t[m] = s[m];
  });
}, "copy");
const lastOfPathSeparatorRegExp = /###/g;
const cleanKey = /* @__PURE__ */ __name((key) => key && key.indexOf("###") > -1 ? key.replace(lastOfPathSeparatorRegExp, ".") : key, "cleanKey");
const canNotTraverseDeeper = /* @__PURE__ */ __name((object) => !object || isString(object), "canNotTraverseDeeper");
const getLastOfPath = /* @__PURE__ */ __name((object, path2, Empty) => {
  const stack = !isString(path2) ? path2 : path2.split(".");
  let stackIndex = 0;
  while (stackIndex < stack.length - 1) {
    if (canNotTraverseDeeper(object)) return {};
    const key = cleanKey(stack[stackIndex]);
    if (!object[key] && Empty) object[key] = new Empty();
    if (Object.prototype.hasOwnProperty.call(object, key)) {
      object = object[key];
    } else {
      object = {};
    }
    ++stackIndex;
  }
  if (canNotTraverseDeeper(object)) return {};
  return {
    obj: object,
    k: cleanKey(stack[stackIndex])
  };
}, "getLastOfPath");
const setPath = /* @__PURE__ */ __name((object, path2, newValue) => {
  const {
    obj,
    k
  } = getLastOfPath(object, path2, Object);
  if (obj !== void 0 || path2.length === 1) {
    obj[k] = newValue;
    return;
  }
  let e = path2[path2.length - 1];
  let p = path2.slice(0, path2.length - 1);
  let last = getLastOfPath(object, p, Object);
  while (last.obj === void 0 && p.length) {
    e = `${p[p.length - 1]}.${e}`;
    p = p.slice(0, p.length - 1);
    last = getLastOfPath(object, p, Object);
    if (last?.obj && typeof last.obj[`${last.k}.${e}`] !== "undefined") {
      last.obj = void 0;
    }
  }
  last.obj[`${last.k}.${e}`] = newValue;
}, "setPath");
const pushPath = /* @__PURE__ */ __name((object, path2, newValue, concat) => {
  const {
    obj,
    k
  } = getLastOfPath(object, path2, Object);
  obj[k] = obj[k] || [];
  obj[k].push(newValue);
}, "pushPath");
const getPath = /* @__PURE__ */ __name((object, path2) => {
  const {
    obj,
    k
  } = getLastOfPath(object, path2);
  if (!obj) return void 0;
  if (!Object.prototype.hasOwnProperty.call(obj, k)) return void 0;
  return obj[k];
}, "getPath");
const getPathWithDefaults = /* @__PURE__ */ __name((data, defaultData, key) => {
  const value = getPath(data, key);
  if (value !== void 0) {
    return value;
  }
  return getPath(defaultData, key);
}, "getPathWithDefaults");
const deepExtend = /* @__PURE__ */ __name((target, source, overwrite) => {
  for (const prop in source) {
    if (prop !== "__proto__" && prop !== "constructor") {
      if (prop in target) {
        if (isString(target[prop]) || target[prop] instanceof String || isString(source[prop]) || source[prop] instanceof String) {
          if (overwrite) target[prop] = source[prop];
        } else {
          deepExtend(target[prop], source[prop], overwrite);
        }
      } else {
        target[prop] = source[prop];
      }
    }
  }
  return target;
}, "deepExtend");
const regexEscape = /* @__PURE__ */ __name((str) => str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&"), "regexEscape");
var _entityMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;"
};
const escape$1 = /* @__PURE__ */ __name((data) => {
  if (isString(data)) {
    return data.replace(/[&<>"'\/]/g, (s) => _entityMap[s]);
  }
  return data;
}, "escape$1");
const _RegExpCache = class _RegExpCache {
  constructor(capacity) {
    this.capacity = capacity;
    this.regExpMap = /* @__PURE__ */ new Map();
    this.regExpQueue = [];
  }
  getRegExp(pattern) {
    const regExpFromCache = this.regExpMap.get(pattern);
    if (regExpFromCache !== void 0) {
      return regExpFromCache;
    }
    const regExpNew = new RegExp(pattern);
    if (this.regExpQueue.length === this.capacity) {
      this.regExpMap.delete(this.regExpQueue.shift());
    }
    this.regExpMap.set(pattern, regExpNew);
    this.regExpQueue.push(pattern);
    return regExpNew;
  }
};
__name(_RegExpCache, "RegExpCache");
let RegExpCache = _RegExpCache;
const chars = [" ", ",", "?", "!", ";"];
const looksLikeObjectPathRegExpCache = new RegExpCache(20);
const looksLikeObjectPath = /* @__PURE__ */ __name((key, nsSeparator, keySeparator) => {
  nsSeparator = nsSeparator || "";
  keySeparator = keySeparator || "";
  const possibleChars = chars.filter((c) => nsSeparator.indexOf(c) < 0 && keySeparator.indexOf(c) < 0);
  if (possibleChars.length === 0) return true;
  const r = looksLikeObjectPathRegExpCache.getRegExp(`(${possibleChars.map((c) => c === "?" ? "\\?" : c).join("|")})`);
  let matched = !r.test(key);
  if (!matched) {
    const ki = key.indexOf(keySeparator);
    if (ki > 0 && !r.test(key.substring(0, ki))) {
      matched = true;
    }
  }
  return matched;
}, "looksLikeObjectPath");
const deepFind = /* @__PURE__ */ __name((obj, path2, keySeparator = ".") => {
  if (!obj) return void 0;
  if (obj[path2]) {
    if (!Object.prototype.hasOwnProperty.call(obj, path2)) return void 0;
    return obj[path2];
  }
  const tokens = path2.split(keySeparator);
  let current = obj;
  for (let i = 0; i < tokens.length; ) {
    if (!current || typeof current !== "object") {
      return void 0;
    }
    let next;
    let nextPath = "";
    for (let j = i; j < tokens.length; ++j) {
      if (j !== i) {
        nextPath += keySeparator;
      }
      nextPath += tokens[j];
      next = current[nextPath];
      if (next !== void 0) {
        if (["string", "number", "boolean"].indexOf(typeof next) > -1 && j < tokens.length - 1) {
          continue;
        }
        i += j - i + 1;
        break;
      }
    }
    current = next;
  }
  return current;
}, "deepFind");
const getCleanedCode = /* @__PURE__ */ __name((code) => code?.replace("_", "-"), "getCleanedCode");
const consoleLogger = {
  type: "logger",
  log(args) {
    this.output("log", args);
  },
  warn(args) {
    this.output("warn", args);
  },
  error(args) {
    this.output("error", args);
  },
  output(type, args) {
    console?.[type]?.apply?.(console, args);
  }
};
const _Logger = class _Logger {
  constructor(concreteLogger, options = {}) {
    this.init(concreteLogger, options);
  }
  init(concreteLogger, options = {}) {
    this.prefix = options.prefix || "i18next:";
    this.logger = concreteLogger || consoleLogger;
    this.options = options;
    this.debug = options.debug;
  }
  log(...args) {
    return this.forward(args, "log", "", true);
  }
  warn(...args) {
    return this.forward(args, "warn", "", true);
  }
  error(...args) {
    return this.forward(args, "error", "");
  }
  deprecate(...args) {
    return this.forward(args, "warn", "WARNING DEPRECATED: ", true);
  }
  forward(args, lvl, prefix, debugOnly) {
    if (debugOnly && !this.debug) return null;
    if (isString(args[0])) args[0] = `${prefix}${this.prefix} ${args[0]}`;
    return this.logger[lvl](args);
  }
  create(moduleName) {
    return new _Logger(this.logger, {
      ...{
        prefix: `${this.prefix}:${moduleName}:`
      },
      ...this.options
    });
  }
  clone(options) {
    options = options || this.options;
    options.prefix = options.prefix || this.prefix;
    return new _Logger(this.logger, options);
  }
};
__name(_Logger, "Logger");
let Logger = _Logger;
var baseLogger = new Logger();
const _EventEmitter = class _EventEmitter {
  constructor() {
    this.observers = {};
  }
  on(events, listener) {
    events.split(" ").forEach((event) => {
      if (!this.observers[event]) this.observers[event] = /* @__PURE__ */ new Map();
      const numListeners = this.observers[event].get(listener) || 0;
      this.observers[event].set(listener, numListeners + 1);
    });
    return this;
  }
  off(event, listener) {
    if (!this.observers[event]) return;
    if (!listener) {
      delete this.observers[event];
      return;
    }
    this.observers[event].delete(listener);
  }
  emit(event, ...args) {
    if (this.observers[event]) {
      const cloned = Array.from(this.observers[event].entries());
      cloned.forEach(([observer, numTimesAdded]) => {
        for (let i = 0; i < numTimesAdded; i++) {
          observer(...args);
        }
      });
    }
    if (this.observers["*"]) {
      const cloned = Array.from(this.observers["*"].entries());
      cloned.forEach(([observer, numTimesAdded]) => {
        for (let i = 0; i < numTimesAdded; i++) {
          observer.apply(observer, [event, ...args]);
        }
      });
    }
  }
};
__name(_EventEmitter, "EventEmitter");
let EventEmitter = _EventEmitter;
const _ResourceStore = class _ResourceStore extends EventEmitter {
  constructor(data, options = {
    ns: ["translation"],
    defaultNS: "translation"
  }) {
    super();
    this.data = data || {};
    this.options = options;
    if (this.options.keySeparator === void 0) {
      this.options.keySeparator = ".";
    }
    if (this.options.ignoreJSONStructure === void 0) {
      this.options.ignoreJSONStructure = true;
    }
  }
  addNamespaces(ns) {
    if (this.options.ns.indexOf(ns) < 0) {
      this.options.ns.push(ns);
    }
  }
  removeNamespaces(ns) {
    const index = this.options.ns.indexOf(ns);
    if (index > -1) {
      this.options.ns.splice(index, 1);
    }
  }
  getResource(lng, ns, key, options = {}) {
    const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
    const ignoreJSONStructure = options.ignoreJSONStructure !== void 0 ? options.ignoreJSONStructure : this.options.ignoreJSONStructure;
    let path2;
    if (lng.indexOf(".") > -1) {
      path2 = lng.split(".");
    } else {
      path2 = [lng, ns];
      if (key) {
        if (Array.isArray(key)) {
          path2.push(...key);
        } else if (isString(key) && keySeparator) {
          path2.push(...key.split(keySeparator));
        } else {
          path2.push(key);
        }
      }
    }
    const result = getPath(this.data, path2);
    if (!result && !ns && !key && lng.indexOf(".") > -1) {
      lng = path2[0];
      ns = path2[1];
      key = path2.slice(2).join(".");
    }
    if (result || !ignoreJSONStructure || !isString(key)) return result;
    return deepFind(this.data?.[lng]?.[ns], key, keySeparator);
  }
  addResource(lng, ns, key, value, options = {
    silent: false
  }) {
    const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
    let path2 = [lng, ns];
    if (key) path2 = path2.concat(keySeparator ? key.split(keySeparator) : key);
    if (lng.indexOf(".") > -1) {
      path2 = lng.split(".");
      value = ns;
      ns = path2[1];
    }
    this.addNamespaces(ns);
    setPath(this.data, path2, value);
    if (!options.silent) this.emit("added", lng, ns, key, value);
  }
  addResources(lng, ns, resources, options = {
    silent: false
  }) {
    for (const m in resources) {
      if (isString(resources[m]) || Array.isArray(resources[m])) this.addResource(lng, ns, m, resources[m], {
        silent: true
      });
    }
    if (!options.silent) this.emit("added", lng, ns, resources);
  }
  addResourceBundle(lng, ns, resources, deep, overwrite, options = {
    silent: false,
    skipCopy: false
  }) {
    let path2 = [lng, ns];
    if (lng.indexOf(".") > -1) {
      path2 = lng.split(".");
      deep = resources;
      resources = ns;
      ns = path2[1];
    }
    this.addNamespaces(ns);
    let pack = getPath(this.data, path2) || {};
    if (!options.skipCopy) resources = JSON.parse(JSON.stringify(resources));
    if (deep) {
      deepExtend(pack, resources, overwrite);
    } else {
      pack = {
        ...pack,
        ...resources
      };
    }
    setPath(this.data, path2, pack);
    if (!options.silent) this.emit("added", lng, ns, resources);
  }
  removeResourceBundle(lng, ns) {
    if (this.hasResourceBundle(lng, ns)) {
      delete this.data[lng][ns];
    }
    this.removeNamespaces(ns);
    this.emit("removed", lng, ns);
  }
  hasResourceBundle(lng, ns) {
    return this.getResource(lng, ns) !== void 0;
  }
  getResourceBundle(lng, ns) {
    if (!ns) ns = this.options.defaultNS;
    return this.getResource(lng, ns);
  }
  getDataByLanguage(lng) {
    return this.data[lng];
  }
  hasLanguageSomeTranslations(lng) {
    const data = this.getDataByLanguage(lng);
    const n = data && Object.keys(data) || [];
    return !!n.find((v) => data[v] && Object.keys(data[v]).length > 0);
  }
  toJSON() {
    return this.data;
  }
};
__name(_ResourceStore, "ResourceStore");
let ResourceStore = _ResourceStore;
var postProcessor = {
  processors: {},
  addPostProcessor(module) {
    this.processors[module.name] = module;
  },
  handle(processors, value, key, options, translator) {
    processors.forEach((processor) => {
      value = this.processors[processor]?.process(value, key, options, translator) ?? value;
    });
    return value;
  }
};
const PATH_KEY = /* @__PURE__ */ Symbol("i18next/PATH_KEY");
function createProxy() {
  const state = [];
  const handler = /* @__PURE__ */ Object.create(null);
  let proxy;
  handler.get = (target, key) => {
    proxy?.revoke?.();
    if (key === PATH_KEY) return state;
    state.push(key);
    proxy = Proxy.revocable(target, handler);
    return proxy.proxy;
  };
  return Proxy.revocable(/* @__PURE__ */ Object.create(null), handler).proxy;
}
__name(createProxy, "createProxy");
function keysFromSelector(selector, opts) {
  const {
    [PATH_KEY]: path2
  } = selector(createProxy());
  return path2.join(opts?.keySeparator ?? ".");
}
__name(keysFromSelector, "keysFromSelector");
const checkedLoadedFor = {};
const shouldHandleAsObject = /* @__PURE__ */ __name((res) => !isString(res) && typeof res !== "boolean" && typeof res !== "number", "shouldHandleAsObject");
const _Translator = class _Translator extends EventEmitter {
  constructor(services, options = {}) {
    super();
    copy(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], services, this);
    this.options = options;
    if (this.options.keySeparator === void 0) {
      this.options.keySeparator = ".";
    }
    this.logger = baseLogger.create("translator");
  }
  changeLanguage(lng) {
    if (lng) this.language = lng;
  }
  exists(key, o = {
    interpolation: {}
  }) {
    const opt = {
      ...o
    };
    if (key == null) return false;
    const resolved = this.resolve(key, opt);
    if (resolved?.res === void 0) return false;
    const isObject = shouldHandleAsObject(resolved.res);
    if (opt.returnObjects === false && isObject) {
      return false;
    }
    return true;
  }
  extractFromKey(key, opt) {
    let nsSeparator = opt.nsSeparator !== void 0 ? opt.nsSeparator : this.options.nsSeparator;
    if (nsSeparator === void 0) nsSeparator = ":";
    const keySeparator = opt.keySeparator !== void 0 ? opt.keySeparator : this.options.keySeparator;
    let namespaces = opt.ns || this.options.defaultNS || [];
    const wouldCheckForNsInKey = nsSeparator && key.indexOf(nsSeparator) > -1;
    const seemsNaturalLanguage = !this.options.userDefinedKeySeparator && !opt.keySeparator && !this.options.userDefinedNsSeparator && !opt.nsSeparator && !looksLikeObjectPath(key, nsSeparator, keySeparator);
    if (wouldCheckForNsInKey && !seemsNaturalLanguage) {
      const m = key.match(this.interpolator.nestingRegexp);
      if (m && m.length > 0) {
        return {
          key,
          namespaces: isString(namespaces) ? [namespaces] : namespaces
        };
      }
      const parts = key.split(nsSeparator);
      if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1) namespaces = parts.shift();
      key = parts.join(keySeparator);
    }
    return {
      key,
      namespaces: isString(namespaces) ? [namespaces] : namespaces
    };
  }
  translate(keys, o, lastKey) {
    let opt = typeof o === "object" ? {
      ...o
    } : o;
    if (typeof opt !== "object" && this.options.overloadTranslationOptionHandler) {
      opt = this.options.overloadTranslationOptionHandler(arguments);
    }
    if (typeof opt === "object") opt = {
      ...opt
    };
    if (!opt) opt = {};
    if (keys == null) return "";
    if (typeof keys === "function") keys = keysFromSelector(keys, {
      ...this.options,
      ...opt
    });
    if (!Array.isArray(keys)) keys = [String(keys)];
    const returnDetails = opt.returnDetails !== void 0 ? opt.returnDetails : this.options.returnDetails;
    const keySeparator = opt.keySeparator !== void 0 ? opt.keySeparator : this.options.keySeparator;
    const {
      key,
      namespaces
    } = this.extractFromKey(keys[keys.length - 1], opt);
    const namespace = namespaces[namespaces.length - 1];
    let nsSeparator = opt.nsSeparator !== void 0 ? opt.nsSeparator : this.options.nsSeparator;
    if (nsSeparator === void 0) nsSeparator = ":";
    const lng = opt.lng || this.language;
    const appendNamespaceToCIMode = opt.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
    if (lng?.toLowerCase() === "cimode") {
      if (appendNamespaceToCIMode) {
        if (returnDetails) {
          return {
            res: `${namespace}${nsSeparator}${key}`,
            usedKey: key,
            exactUsedKey: key,
            usedLng: lng,
            usedNS: namespace,
            usedParams: this.getUsedParamsDetails(opt)
          };
        }
        return `${namespace}${nsSeparator}${key}`;
      }
      if (returnDetails) {
        return {
          res: key,
          usedKey: key,
          exactUsedKey: key,
          usedLng: lng,
          usedNS: namespace,
          usedParams: this.getUsedParamsDetails(opt)
        };
      }
      return key;
    }
    const resolved = this.resolve(keys, opt);
    let res = resolved?.res;
    const resUsedKey = resolved?.usedKey || key;
    const resExactUsedKey = resolved?.exactUsedKey || key;
    const noObject = ["[object Number]", "[object Function]", "[object RegExp]"];
    const joinArrays = opt.joinArrays !== void 0 ? opt.joinArrays : this.options.joinArrays;
    const handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;
    const needsPluralHandling = opt.count !== void 0 && !isString(opt.count);
    const hasDefaultValue = _Translator.hasDefaultValue(opt);
    const defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng, opt.count, opt) : "";
    const defaultValueSuffixOrdinalFallback = opt.ordinal && needsPluralHandling ? this.pluralResolver.getSuffix(lng, opt.count, {
      ordinal: false
    }) : "";
    const needsZeroSuffixLookup = needsPluralHandling && !opt.ordinal && opt.count === 0;
    const defaultValue = needsZeroSuffixLookup && opt[`defaultValue${this.options.pluralSeparator}zero`] || opt[`defaultValue${defaultValueSuffix}`] || opt[`defaultValue${defaultValueSuffixOrdinalFallback}`] || opt.defaultValue;
    let resForObjHndl = res;
    if (handleAsObjectInI18nFormat && !res && hasDefaultValue) {
      resForObjHndl = defaultValue;
    }
    const handleAsObject = shouldHandleAsObject(resForObjHndl);
    const resType = Object.prototype.toString.apply(resForObjHndl);
    if (handleAsObjectInI18nFormat && resForObjHndl && handleAsObject && noObject.indexOf(resType) < 0 && !(isString(joinArrays) && Array.isArray(resForObjHndl))) {
      if (!opt.returnObjects && !this.options.returnObjects) {
        if (!this.options.returnedObjectHandler) {
          this.logger.warn("accessing an object - but returnObjects options is not enabled!");
        }
        const r = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, resForObjHndl, {
          ...opt,
          ns: namespaces
        }) : `key '${key} (${this.language})' returned an object instead of string.`;
        if (returnDetails) {
          resolved.res = r;
          resolved.usedParams = this.getUsedParamsDetails(opt);
          return resolved;
        }
        return r;
      }
      if (keySeparator) {
        const resTypeIsArray = Array.isArray(resForObjHndl);
        const copy2 = resTypeIsArray ? [] : {};
        const newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;
        for (const m in resForObjHndl) {
          if (Object.prototype.hasOwnProperty.call(resForObjHndl, m)) {
            const deepKey = `${newKeyToUse}${keySeparator}${m}`;
            if (hasDefaultValue && !res) {
              copy2[m] = this.translate(deepKey, {
                ...opt,
                defaultValue: shouldHandleAsObject(defaultValue) ? defaultValue[m] : void 0,
                ...{
                  joinArrays: false,
                  ns: namespaces
                }
              });
            } else {
              copy2[m] = this.translate(deepKey, {
                ...opt,
                ...{
                  joinArrays: false,
                  ns: namespaces
                }
              });
            }
            if (copy2[m] === deepKey) copy2[m] = resForObjHndl[m];
          }
        }
        res = copy2;
      }
    } else if (handleAsObjectInI18nFormat && isString(joinArrays) && Array.isArray(res)) {
      res = res.join(joinArrays);
      if (res) res = this.extendTranslation(res, keys, opt, lastKey);
    } else {
      let usedDefault = false;
      let usedKey = false;
      if (!this.isValidLookup(res) && hasDefaultValue) {
        usedDefault = true;
        res = defaultValue;
      }
      if (!this.isValidLookup(res)) {
        usedKey = true;
        res = key;
      }
      const missingKeyNoValueFallbackToKey = opt.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey;
      const resForMissing = missingKeyNoValueFallbackToKey && usedKey ? void 0 : res;
      const updateMissing = hasDefaultValue && defaultValue !== res && this.options.updateMissing;
      if (usedKey || usedDefault || updateMissing) {
        this.logger.log(updateMissing ? "updateKey" : "missingKey", lng, namespace, key, updateMissing ? defaultValue : res);
        if (keySeparator) {
          const fk = this.resolve(key, {
            ...opt,
            keySeparator: false
          });
          if (fk && fk.res) this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.");
        }
        let lngs = [];
        const fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, opt.lng || this.language);
        if (this.options.saveMissingTo === "fallback" && fallbackLngs && fallbackLngs[0]) {
          for (let i = 0; i < fallbackLngs.length; i++) {
            lngs.push(fallbackLngs[i]);
          }
        } else if (this.options.saveMissingTo === "all") {
          lngs = this.languageUtils.toResolveHierarchy(opt.lng || this.language);
        } else {
          lngs.push(opt.lng || this.language);
        }
        const send = /* @__PURE__ */ __name((l, k, specificDefaultValue) => {
          const defaultForMissing = hasDefaultValue && specificDefaultValue !== res ? specificDefaultValue : resForMissing;
          if (this.options.missingKeyHandler) {
            this.options.missingKeyHandler(l, namespace, k, defaultForMissing, updateMissing, opt);
          } else if (this.backendConnector?.saveMissing) {
            this.backendConnector.saveMissing(l, namespace, k, defaultForMissing, updateMissing, opt);
          }
          this.emit("missingKey", l, namespace, k, res);
        }, "send");
        if (this.options.saveMissing) {
          if (this.options.saveMissingPlurals && needsPluralHandling) {
            lngs.forEach((language) => {
              const suffixes = this.pluralResolver.getSuffixes(language, opt);
              if (needsZeroSuffixLookup && opt[`defaultValue${this.options.pluralSeparator}zero`] && suffixes.indexOf(`${this.options.pluralSeparator}zero`) < 0) {
                suffixes.push(`${this.options.pluralSeparator}zero`);
              }
              suffixes.forEach((suffix) => {
                send([language], key + suffix, opt[`defaultValue${suffix}`] || defaultValue);
              });
            });
          } else {
            send(lngs, key, defaultValue);
          }
        }
      }
      res = this.extendTranslation(res, keys, opt, resolved, lastKey);
      if (usedKey && res === key && this.options.appendNamespaceToMissingKey) {
        res = `${namespace}${nsSeparator}${key}`;
      }
      if ((usedKey || usedDefault) && this.options.parseMissingKeyHandler) {
        res = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? `${namespace}${nsSeparator}${key}` : key, usedDefault ? res : void 0, opt);
      }
    }
    if (returnDetails) {
      resolved.res = res;
      resolved.usedParams = this.getUsedParamsDetails(opt);
      return resolved;
    }
    return res;
  }
  extendTranslation(res, key, opt, resolved, lastKey) {
    if (this.i18nFormat?.parse) {
      res = this.i18nFormat.parse(res, {
        ...this.options.interpolation.defaultVariables,
        ...opt
      }, opt.lng || this.language || resolved.usedLng, resolved.usedNS, resolved.usedKey, {
        resolved
      });
    } else if (!opt.skipInterpolation) {
      if (opt.interpolation) this.interpolator.init({
        ...opt,
        ...{
          interpolation: {
            ...this.options.interpolation,
            ...opt.interpolation
          }
        }
      });
      const skipOnVariables = isString(res) && (opt?.interpolation?.skipOnVariables !== void 0 ? opt.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);
      let nestBef;
      if (skipOnVariables) {
        const nb = res.match(this.interpolator.nestingRegexp);
        nestBef = nb && nb.length;
      }
      let data = opt.replace && !isString(opt.replace) ? opt.replace : opt;
      if (this.options.interpolation.defaultVariables) data = {
        ...this.options.interpolation.defaultVariables,
        ...data
      };
      res = this.interpolator.interpolate(res, data, opt.lng || this.language || resolved.usedLng, opt);
      if (skipOnVariables) {
        const na = res.match(this.interpolator.nestingRegexp);
        const nestAft = na && na.length;
        if (nestBef < nestAft) opt.nest = false;
      }
      if (!opt.lng && resolved && resolved.res) opt.lng = this.language || resolved.usedLng;
      if (opt.nest !== false) res = this.interpolator.nest(res, (...args) => {
        if (lastKey?.[0] === args[0] && !opt.context) {
          this.logger.warn(`It seems you are nesting recursively key: ${args[0]} in key: ${key[0]}`);
          return null;
        }
        return this.translate(...args, key);
      }, opt);
      if (opt.interpolation) this.interpolator.reset();
    }
    const postProcess = opt.postProcess || this.options.postProcess;
    const postProcessorNames = isString(postProcess) ? [postProcess] : postProcess;
    if (res != null && postProcessorNames?.length && opt.applyPostProcessor !== false) {
      res = postProcessor.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? {
        i18nResolved: {
          ...resolved,
          usedParams: this.getUsedParamsDetails(opt)
        },
        ...opt
      } : opt, this);
    }
    return res;
  }
  resolve(keys, opt = {}) {
    let found;
    let usedKey;
    let exactUsedKey;
    let usedLng;
    let usedNS;
    if (isString(keys)) keys = [keys];
    keys.forEach((k) => {
      if (this.isValidLookup(found)) return;
      const extracted = this.extractFromKey(k, opt);
      const key = extracted.key;
      usedKey = key;
      let namespaces = extracted.namespaces;
      if (this.options.fallbackNS) namespaces = namespaces.concat(this.options.fallbackNS);
      const needsPluralHandling = opt.count !== void 0 && !isString(opt.count);
      const needsZeroSuffixLookup = needsPluralHandling && !opt.ordinal && opt.count === 0;
      const needsContextHandling = opt.context !== void 0 && (isString(opt.context) || typeof opt.context === "number") && opt.context !== "";
      const codes = opt.lngs ? opt.lngs : this.languageUtils.toResolveHierarchy(opt.lng || this.language, opt.fallbackLng);
      namespaces.forEach((ns) => {
        if (this.isValidLookup(found)) return;
        usedNS = ns;
        if (!checkedLoadedFor[`${codes[0]}-${ns}`] && this.utils?.hasLoadedNamespace && !this.utils?.hasLoadedNamespace(usedNS)) {
          checkedLoadedFor[`${codes[0]}-${ns}`] = true;
          this.logger.warn(`key "${usedKey}" for languages "${codes.join(", ")}" won't get resolved as namespace "${usedNS}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
        }
        codes.forEach((code) => {
          if (this.isValidLookup(found)) return;
          usedLng = code;
          const finalKeys = [key];
          if (this.i18nFormat?.addLookupKeys) {
            this.i18nFormat.addLookupKeys(finalKeys, key, code, ns, opt);
          } else {
            let pluralSuffix;
            if (needsPluralHandling) pluralSuffix = this.pluralResolver.getSuffix(code, opt.count, opt);
            const zeroSuffix = `${this.options.pluralSeparator}zero`;
            const ordinalPrefix = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`;
            if (needsPluralHandling) {
              if (opt.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {
                finalKeys.push(key + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));
              }
              finalKeys.push(key + pluralSuffix);
              if (needsZeroSuffixLookup) {
                finalKeys.push(key + zeroSuffix);
              }
            }
            if (needsContextHandling) {
              const contextKey = `${key}${this.options.contextSeparator || "_"}${opt.context}`;
              finalKeys.push(contextKey);
              if (needsPluralHandling) {
                if (opt.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {
                  finalKeys.push(contextKey + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));
                }
                finalKeys.push(contextKey + pluralSuffix);
                if (needsZeroSuffixLookup) {
                  finalKeys.push(contextKey + zeroSuffix);
                }
              }
            }
          }
          let possibleKey;
          while (possibleKey = finalKeys.pop()) {
            if (!this.isValidLookup(found)) {
              exactUsedKey = possibleKey;
              found = this.getResource(code, ns, possibleKey, opt);
            }
          }
        });
      });
    });
    return {
      res: found,
      usedKey,
      exactUsedKey,
      usedLng,
      usedNS
    };
  }
  isValidLookup(res) {
    return res !== void 0 && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === "");
  }
  getResource(code, ns, key, options = {}) {
    if (this.i18nFormat?.getResource) return this.i18nFormat.getResource(code, ns, key, options);
    return this.resourceStore.getResource(code, ns, key, options);
  }
  getUsedParamsDetails(options = {}) {
    const optionsKeys = ["defaultValue", "ordinal", "context", "replace", "lng", "lngs", "fallbackLng", "ns", "keySeparator", "nsSeparator", "returnObjects", "returnDetails", "joinArrays", "postProcess", "interpolation"];
    const useOptionsReplaceForData = options.replace && !isString(options.replace);
    let data = useOptionsReplaceForData ? options.replace : options;
    if (useOptionsReplaceForData && typeof options.count !== "undefined") {
      data.count = options.count;
    }
    if (this.options.interpolation.defaultVariables) {
      data = {
        ...this.options.interpolation.defaultVariables,
        ...data
      };
    }
    if (!useOptionsReplaceForData) {
      data = {
        ...data
      };
      for (const key of optionsKeys) {
        delete data[key];
      }
    }
    return data;
  }
  static hasDefaultValue(options) {
    const prefix = "defaultValue";
    for (const option in options) {
      if (Object.prototype.hasOwnProperty.call(options, option) && prefix === option.substring(0, prefix.length) && void 0 !== options[option]) {
        return true;
      }
    }
    return false;
  }
};
__name(_Translator, "Translator");
let Translator = _Translator;
const _LanguageUtil = class _LanguageUtil {
  constructor(options) {
    this.options = options;
    this.supportedLngs = this.options.supportedLngs || false;
    this.logger = baseLogger.create("languageUtils");
  }
  getScriptPartFromCode(code) {
    code = getCleanedCode(code);
    if (!code || code.indexOf("-") < 0) return null;
    const p = code.split("-");
    if (p.length === 2) return null;
    p.pop();
    if (p[p.length - 1].toLowerCase() === "x") return null;
    return this.formatLanguageCode(p.join("-"));
  }
  getLanguagePartFromCode(code) {
    code = getCleanedCode(code);
    if (!code || code.indexOf("-") < 0) return code;
    const p = code.split("-");
    return this.formatLanguageCode(p[0]);
  }
  formatLanguageCode(code) {
    if (isString(code) && code.indexOf("-") > -1) {
      let formattedCode;
      try {
        formattedCode = Intl.getCanonicalLocales(code)[0];
      } catch (e) {
      }
      if (formattedCode && this.options.lowerCaseLng) {
        formattedCode = formattedCode.toLowerCase();
      }
      if (formattedCode) return formattedCode;
      if (this.options.lowerCaseLng) {
        return code.toLowerCase();
      }
      return code;
    }
    return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;
  }
  isSupportedCode(code) {
    if (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) {
      code = this.getLanguagePartFromCode(code);
    }
    return !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code) > -1;
  }
  getBestMatchFromCodes(codes) {
    if (!codes) return null;
    let found;
    codes.forEach((code) => {
      if (found) return;
      const cleanedLng = this.formatLanguageCode(code);
      if (!this.options.supportedLngs || this.isSupportedCode(cleanedLng)) found = cleanedLng;
    });
    if (!found && this.options.supportedLngs) {
      codes.forEach((code) => {
        if (found) return;
        const lngScOnly = this.getScriptPartFromCode(code);
        if (this.isSupportedCode(lngScOnly)) return found = lngScOnly;
        const lngOnly = this.getLanguagePartFromCode(code);
        if (this.isSupportedCode(lngOnly)) return found = lngOnly;
        found = this.options.supportedLngs.find((supportedLng) => {
          if (supportedLng === lngOnly) return supportedLng;
          if (supportedLng.indexOf("-") < 0 && lngOnly.indexOf("-") < 0) return;
          if (supportedLng.indexOf("-") > 0 && lngOnly.indexOf("-") < 0 && supportedLng.substring(0, supportedLng.indexOf("-")) === lngOnly) return supportedLng;
          if (supportedLng.indexOf(lngOnly) === 0 && lngOnly.length > 1) return supportedLng;
        });
      });
    }
    if (!found) found = this.getFallbackCodes(this.options.fallbackLng)[0];
    return found;
  }
  getFallbackCodes(fallbacks, code) {
    if (!fallbacks) return [];
    if (typeof fallbacks === "function") fallbacks = fallbacks(code);
    if (isString(fallbacks)) fallbacks = [fallbacks];
    if (Array.isArray(fallbacks)) return fallbacks;
    if (!code) return fallbacks.default || [];
    let found = fallbacks[code];
    if (!found) found = fallbacks[this.getScriptPartFromCode(code)];
    if (!found) found = fallbacks[this.formatLanguageCode(code)];
    if (!found) found = fallbacks[this.getLanguagePartFromCode(code)];
    if (!found) found = fallbacks.default;
    return found || [];
  }
  toResolveHierarchy(code, fallbackCode) {
    const fallbackCodes = this.getFallbackCodes((fallbackCode === false ? [] : fallbackCode) || this.options.fallbackLng || [], code);
    const codes = [];
    const addCode = /* @__PURE__ */ __name((c) => {
      if (!c) return;
      if (this.isSupportedCode(c)) {
        codes.push(c);
      } else {
        this.logger.warn(`rejecting language code not found in supportedLngs: ${c}`);
      }
    }, "addCode");
    if (isString(code) && (code.indexOf("-") > -1 || code.indexOf("_") > -1)) {
      if (this.options.load !== "languageOnly") addCode(this.formatLanguageCode(code));
      if (this.options.load !== "languageOnly" && this.options.load !== "currentOnly") addCode(this.getScriptPartFromCode(code));
      if (this.options.load !== "currentOnly") addCode(this.getLanguagePartFromCode(code));
    } else if (isString(code)) {
      addCode(this.formatLanguageCode(code));
    }
    fallbackCodes.forEach((fc) => {
      if (codes.indexOf(fc) < 0) addCode(this.formatLanguageCode(fc));
    });
    return codes;
  }
};
__name(_LanguageUtil, "LanguageUtil");
let LanguageUtil = _LanguageUtil;
const suffixesOrder = {
  zero: 0,
  one: 1,
  two: 2,
  few: 3,
  many: 4,
  other: 5
};
const dummyRule = {
  select: /* @__PURE__ */ __name((count) => count === 1 ? "one" : "other", "select"),
  resolvedOptions: /* @__PURE__ */ __name(() => ({
    pluralCategories: ["one", "other"]
  }), "resolvedOptions")
};
const _PluralResolver = class _PluralResolver {
  constructor(languageUtils, options = {}) {
    this.languageUtils = languageUtils;
    this.options = options;
    this.logger = baseLogger.create("pluralResolver");
    this.pluralRulesCache = {};
  }
  clearCache() {
    this.pluralRulesCache = {};
  }
  getRule(code, options = {}) {
    const cleanedCode = getCleanedCode(code === "dev" ? "en" : code);
    const type = options.ordinal ? "ordinal" : "cardinal";
    const cacheKey = JSON.stringify({
      cleanedCode,
      type
    });
    if (cacheKey in this.pluralRulesCache) {
      return this.pluralRulesCache[cacheKey];
    }
    let rule;
    try {
      rule = new Intl.PluralRules(cleanedCode, {
        type
      });
    } catch (err) {
      if (!Intl) {
        this.logger.error("No Intl support, please use an Intl polyfill!");
        return dummyRule;
      }
      if (!code.match(/-|_/)) return dummyRule;
      const lngPart = this.languageUtils.getLanguagePartFromCode(code);
      rule = this.getRule(lngPart, options);
    }
    this.pluralRulesCache[cacheKey] = rule;
    return rule;
  }
  needsPlural(code, options = {}) {
    let rule = this.getRule(code, options);
    if (!rule) rule = this.getRule("dev", options);
    return rule?.resolvedOptions().pluralCategories.length > 1;
  }
  getPluralFormsOfKey(code, key, options = {}) {
    return this.getSuffixes(code, options).map((suffix) => `${key}${suffix}`);
  }
  getSuffixes(code, options = {}) {
    let rule = this.getRule(code, options);
    if (!rule) rule = this.getRule("dev", options);
    if (!rule) return [];
    return rule.resolvedOptions().pluralCategories.sort((pluralCategory1, pluralCategory2) => suffixesOrder[pluralCategory1] - suffixesOrder[pluralCategory2]).map((pluralCategory) => `${this.options.prepend}${options.ordinal ? `ordinal${this.options.prepend}` : ""}${pluralCategory}`);
  }
  getSuffix(code, count, options = {}) {
    const rule = this.getRule(code, options);
    if (rule) {
      return `${this.options.prepend}${options.ordinal ? `ordinal${this.options.prepend}` : ""}${rule.select(count)}`;
    }
    this.logger.warn(`no plural rule found for: ${code}`);
    return this.getSuffix("dev", count, options);
  }
};
__name(_PluralResolver, "PluralResolver");
let PluralResolver = _PluralResolver;
const deepFindWithDefaults = /* @__PURE__ */ __name((data, defaultData, key, keySeparator = ".", ignoreJSONStructure = true) => {
  let path2 = getPathWithDefaults(data, defaultData, key);
  if (!path2 && ignoreJSONStructure && isString(key)) {
    path2 = deepFind(data, key, keySeparator);
    if (path2 === void 0) path2 = deepFind(defaultData, key, keySeparator);
  }
  return path2;
}, "deepFindWithDefaults");
const regexSafe = /* @__PURE__ */ __name((val) => val.replace(/\$/g, "$$$$"), "regexSafe");
const _Interpolator = class _Interpolator {
  constructor(options = {}) {
    this.logger = baseLogger.create("interpolator");
    this.options = options;
    this.format = options?.interpolation?.format || ((value) => value);
    this.init(options);
  }
  init(options = {}) {
    if (!options.interpolation) options.interpolation = {
      escapeValue: true
    };
    const {
      escape: escape$1$1,
      escapeValue,
      useRawValueToEscape,
      prefix,
      prefixEscaped,
      suffix,
      suffixEscaped,
      formatSeparator,
      unescapeSuffix,
      unescapePrefix,
      nestingPrefix,
      nestingPrefixEscaped,
      nestingSuffix,
      nestingSuffixEscaped,
      nestingOptionsSeparator,
      maxReplaces,
      alwaysFormat
    } = options.interpolation;
    this.escape = escape$1$1 !== void 0 ? escape$1$1 : escape$1;
    this.escapeValue = escapeValue !== void 0 ? escapeValue : true;
    this.useRawValueToEscape = useRawValueToEscape !== void 0 ? useRawValueToEscape : false;
    this.prefix = prefix ? regexEscape(prefix) : prefixEscaped || "{{";
    this.suffix = suffix ? regexEscape(suffix) : suffixEscaped || "}}";
    this.formatSeparator = formatSeparator || ",";
    this.unescapePrefix = unescapeSuffix ? "" : unescapePrefix || "-";
    this.unescapeSuffix = this.unescapePrefix ? "" : unescapeSuffix || "";
    this.nestingPrefix = nestingPrefix ? regexEscape(nestingPrefix) : nestingPrefixEscaped || regexEscape("$t(");
    this.nestingSuffix = nestingSuffix ? regexEscape(nestingSuffix) : nestingSuffixEscaped || regexEscape(")");
    this.nestingOptionsSeparator = nestingOptionsSeparator || ",";
    this.maxReplaces = maxReplaces || 1e3;
    this.alwaysFormat = alwaysFormat !== void 0 ? alwaysFormat : false;
    this.resetRegExp();
  }
  reset() {
    if (this.options) this.init(this.options);
  }
  resetRegExp() {
    const getOrResetRegExp = /* @__PURE__ */ __name((existingRegExp, pattern) => {
      if (existingRegExp?.source === pattern) {
        existingRegExp.lastIndex = 0;
        return existingRegExp;
      }
      return new RegExp(pattern, "g");
    }, "getOrResetRegExp");
    this.regexp = getOrResetRegExp(this.regexp, `${this.prefix}(.+?)${this.suffix}`);
    this.regexpUnescape = getOrResetRegExp(this.regexpUnescape, `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`);
    this.nestingRegexp = getOrResetRegExp(this.nestingRegexp, `${this.nestingPrefix}((?:[^()"']+|"[^"]*"|'[^']*'|\\((?:[^()]|"[^"]*"|'[^']*')*\\))*?)${this.nestingSuffix}`);
  }
  interpolate(str, data, lng, options) {
    let match;
    let value;
    let replaces;
    const defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
    const handleFormat = /* @__PURE__ */ __name((key) => {
      if (key.indexOf(this.formatSeparator) < 0) {
        const path2 = deepFindWithDefaults(data, defaultData, key, this.options.keySeparator, this.options.ignoreJSONStructure);
        return this.alwaysFormat ? this.format(path2, void 0, lng, {
          ...options,
          ...data,
          interpolationkey: key
        }) : path2;
      }
      const p = key.split(this.formatSeparator);
      const k = p.shift().trim();
      const f = p.join(this.formatSeparator).trim();
      return this.format(deepFindWithDefaults(data, defaultData, k, this.options.keySeparator, this.options.ignoreJSONStructure), f, lng, {
        ...options,
        ...data,
        interpolationkey: k
      });
    }, "handleFormat");
    this.resetRegExp();
    const missingInterpolationHandler = options?.missingInterpolationHandler || this.options.missingInterpolationHandler;
    const skipOnVariables = options?.interpolation?.skipOnVariables !== void 0 ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;
    const todos = [{
      regex: this.regexpUnescape,
      safeValue: /* @__PURE__ */ __name((val) => regexSafe(val), "safeValue")
    }, {
      regex: this.regexp,
      safeValue: /* @__PURE__ */ __name((val) => this.escapeValue ? regexSafe(this.escape(val)) : regexSafe(val), "safeValue")
    }];
    todos.forEach((todo) => {
      replaces = 0;
      while (match = todo.regex.exec(str)) {
        const matchedVar = match[1].trim();
        value = handleFormat(matchedVar);
        if (value === void 0) {
          if (typeof missingInterpolationHandler === "function") {
            const temp = missingInterpolationHandler(str, match, options);
            value = isString(temp) ? temp : "";
          } else if (options && Object.prototype.hasOwnProperty.call(options, matchedVar)) {
            value = "";
          } else if (skipOnVariables) {
            value = match[0];
            continue;
          } else {
            this.logger.warn(`missed to pass in variable ${matchedVar} for interpolating ${str}`);
            value = "";
          }
        } else if (!isString(value) && !this.useRawValueToEscape) {
          value = makeString(value);
        }
        const safeValue = todo.safeValue(value);
        str = str.replace(match[0], safeValue);
        if (skipOnVariables) {
          todo.regex.lastIndex += value.length;
          todo.regex.lastIndex -= match[0].length;
        } else {
          todo.regex.lastIndex = 0;
        }
        replaces++;
        if (replaces >= this.maxReplaces) {
          break;
        }
      }
    });
    return str;
  }
  nest(str, fc, options = {}) {
    let match;
    let value;
    let clonedOptions;
    const handleHasOptions = /* @__PURE__ */ __name((key, inheritedOptions) => {
      const sep = this.nestingOptionsSeparator;
      if (key.indexOf(sep) < 0) return key;
      const c = key.split(new RegExp(`${sep}[ ]*{`));
      let optionsString = `{${c[1]}`;
      key = c[0];
      optionsString = this.interpolate(optionsString, clonedOptions);
      const matchedSingleQuotes = optionsString.match(/'/g);
      const matchedDoubleQuotes = optionsString.match(/"/g);
      if ((matchedSingleQuotes?.length ?? 0) % 2 === 0 && !matchedDoubleQuotes || matchedDoubleQuotes.length % 2 !== 0) {
        optionsString = optionsString.replace(/'/g, '"');
      }
      try {
        clonedOptions = JSON.parse(optionsString);
        if (inheritedOptions) clonedOptions = {
          ...inheritedOptions,
          ...clonedOptions
        };
      } catch (e) {
        this.logger.warn(`failed parsing options string in nesting for key ${key}`, e);
        return `${key}${sep}${optionsString}`;
      }
      if (clonedOptions.defaultValue && clonedOptions.defaultValue.indexOf(this.prefix) > -1) delete clonedOptions.defaultValue;
      return key;
    }, "handleHasOptions");
    while (match = this.nestingRegexp.exec(str)) {
      let formatters = [];
      clonedOptions = {
        ...options
      };
      clonedOptions = clonedOptions.replace && !isString(clonedOptions.replace) ? clonedOptions.replace : clonedOptions;
      clonedOptions.applyPostProcessor = false;
      delete clonedOptions.defaultValue;
      const keyEndIndex = /{.*}/.test(match[1]) ? match[1].lastIndexOf("}") + 1 : match[1].indexOf(this.formatSeparator);
      if (keyEndIndex !== -1) {
        formatters = match[1].slice(keyEndIndex).split(this.formatSeparator).map((elem) => elem.trim()).filter(Boolean);
        match[1] = match[1].slice(0, keyEndIndex);
      }
      value = fc(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions);
      if (value && match[0] === str && !isString(value)) return value;
      if (!isString(value)) value = makeString(value);
      if (!value) {
        this.logger.warn(`missed to resolve ${match[1]} for nesting ${str}`);
        value = "";
      }
      if (formatters.length) {
        value = formatters.reduce((v, f) => this.format(v, f, options.lng, {
          ...options,
          interpolationkey: match[1].trim()
        }), value.trim());
      }
      str = str.replace(match[0], value);
      this.regexp.lastIndex = 0;
    }
    return str;
  }
};
__name(_Interpolator, "Interpolator");
let Interpolator = _Interpolator;
const parseFormatStr = /* @__PURE__ */ __name((formatStr) => {
  let formatName = formatStr.toLowerCase().trim();
  const formatOptions = {};
  if (formatStr.indexOf("(") > -1) {
    const p = formatStr.split("(");
    formatName = p[0].toLowerCase().trim();
    const optStr = p[1].substring(0, p[1].length - 1);
    if (formatName === "currency" && optStr.indexOf(":") < 0) {
      if (!formatOptions.currency) formatOptions.currency = optStr.trim();
    } else if (formatName === "relativetime" && optStr.indexOf(":") < 0) {
      if (!formatOptions.range) formatOptions.range = optStr.trim();
    } else {
      const opts = optStr.split(";");
      opts.forEach((opt) => {
        if (opt) {
          const [key, ...rest] = opt.split(":");
          const val = rest.join(":").trim().replace(/^'+|'+$/g, "");
          const trimmedKey = key.trim();
          if (!formatOptions[trimmedKey]) formatOptions[trimmedKey] = val;
          if (val === "false") formatOptions[trimmedKey] = false;
          if (val === "true") formatOptions[trimmedKey] = true;
          if (!isNaN(val)) formatOptions[trimmedKey] = parseInt(val, 10);
        }
      });
    }
  }
  return {
    formatName,
    formatOptions
  };
}, "parseFormatStr");
const createCachedFormatter = /* @__PURE__ */ __name((fn) => {
  const cache = {};
  return (v, l, o) => {
    let optForCache = o;
    if (o && o.interpolationkey && o.formatParams && o.formatParams[o.interpolationkey] && o[o.interpolationkey]) {
      optForCache = {
        ...optForCache,
        [o.interpolationkey]: void 0
      };
    }
    const key = l + JSON.stringify(optForCache);
    let frm = cache[key];
    if (!frm) {
      frm = fn(getCleanedCode(l), o);
      cache[key] = frm;
    }
    return frm(v);
  };
}, "createCachedFormatter");
const createNonCachedFormatter = /* @__PURE__ */ __name((fn) => (v, l, o) => fn(getCleanedCode(l), o)(v), "createNonCachedFormatter");
const _Formatter = class _Formatter {
  constructor(options = {}) {
    this.logger = baseLogger.create("formatter");
    this.options = options;
    this.init(options);
  }
  init(services, options = {
    interpolation: {}
  }) {
    this.formatSeparator = options.interpolation.formatSeparator || ",";
    const cf = options.cacheInBuiltFormats ? createCachedFormatter : createNonCachedFormatter;
    this.formats = {
      number: cf((lng, opt) => {
        const formatter = new Intl.NumberFormat(lng, {
          ...opt
        });
        return (val) => formatter.format(val);
      }),
      currency: cf((lng, opt) => {
        const formatter = new Intl.NumberFormat(lng, {
          ...opt,
          style: "currency"
        });
        return (val) => formatter.format(val);
      }),
      datetime: cf((lng, opt) => {
        const formatter = new Intl.DateTimeFormat(lng, {
          ...opt
        });
        return (val) => formatter.format(val);
      }),
      relativetime: cf((lng, opt) => {
        const formatter = new Intl.RelativeTimeFormat(lng, {
          ...opt
        });
        return (val) => formatter.format(val, opt.range || "day");
      }),
      list: cf((lng, opt) => {
        const formatter = new Intl.ListFormat(lng, {
          ...opt
        });
        return (val) => formatter.format(val);
      })
    };
  }
  add(name, fc) {
    this.formats[name.toLowerCase().trim()] = fc;
  }
  addCached(name, fc) {
    this.formats[name.toLowerCase().trim()] = createCachedFormatter(fc);
  }
  format(value, format, lng, options = {}) {
    const formats = format.split(this.formatSeparator);
    if (formats.length > 1 && formats[0].indexOf("(") > 1 && formats[0].indexOf(")") < 0 && formats.find((f) => f.indexOf(")") > -1)) {
      const lastIndex = formats.findIndex((f) => f.indexOf(")") > -1);
      formats[0] = [formats[0], ...formats.splice(1, lastIndex)].join(this.formatSeparator);
    }
    const result = formats.reduce((mem, f) => {
      const {
        formatName,
        formatOptions
      } = parseFormatStr(f);
      if (this.formats[formatName]) {
        let formatted = mem;
        try {
          const valOptions = options?.formatParams?.[options.interpolationkey] || {};
          const l = valOptions.locale || valOptions.lng || options.locale || options.lng || lng;
          formatted = this.formats[formatName](mem, l, {
            ...formatOptions,
            ...options,
            ...valOptions
          });
        } catch (error) {
          this.logger.warn(error);
        }
        return formatted;
      } else {
        this.logger.warn(`there was no format function for ${formatName}`);
      }
      return mem;
    }, value);
    return result;
  }
};
__name(_Formatter, "Formatter");
let Formatter = _Formatter;
const removePending = /* @__PURE__ */ __name((q, name) => {
  if (q.pending[name] !== void 0) {
    delete q.pending[name];
    q.pendingCount--;
  }
}, "removePending");
const _Connector = class _Connector extends EventEmitter {
  constructor(backend, store, services, options = {}) {
    super();
    this.backend = backend;
    this.store = store;
    this.services = services;
    this.languageUtils = services.languageUtils;
    this.options = options;
    this.logger = baseLogger.create("backendConnector");
    this.waitingReads = [];
    this.maxParallelReads = options.maxParallelReads || 10;
    this.readingCalls = 0;
    this.maxRetries = options.maxRetries >= 0 ? options.maxRetries : 5;
    this.retryTimeout = options.retryTimeout >= 1 ? options.retryTimeout : 350;
    this.state = {};
    this.queue = [];
    this.backend?.init?.(services, options.backend, options);
  }
  queueLoad(languages, namespaces, options, callback) {
    const toLoad = {};
    const pending = {};
    const toLoadLanguages = {};
    const toLoadNamespaces = {};
    languages.forEach((lng) => {
      let hasAllNamespaces = true;
      namespaces.forEach((ns) => {
        const name = `${lng}|${ns}`;
        if (!options.reload && this.store.hasResourceBundle(lng, ns)) {
          this.state[name] = 2;
        } else if (this.state[name] < 0) ;
        else if (this.state[name] === 1) {
          if (pending[name] === void 0) pending[name] = true;
        } else {
          this.state[name] = 1;
          hasAllNamespaces = false;
          if (pending[name] === void 0) pending[name] = true;
          if (toLoad[name] === void 0) toLoad[name] = true;
          if (toLoadNamespaces[ns] === void 0) toLoadNamespaces[ns] = true;
        }
      });
      if (!hasAllNamespaces) toLoadLanguages[lng] = true;
    });
    if (Object.keys(toLoad).length || Object.keys(pending).length) {
      this.queue.push({
        pending,
        pendingCount: Object.keys(pending).length,
        loaded: {},
        errors: [],
        callback
      });
    }
    return {
      toLoad: Object.keys(toLoad),
      pending: Object.keys(pending),
      toLoadLanguages: Object.keys(toLoadLanguages),
      toLoadNamespaces: Object.keys(toLoadNamespaces)
    };
  }
  loaded(name, err, data) {
    const s = name.split("|");
    const lng = s[0];
    const ns = s[1];
    if (err) this.emit("failedLoading", lng, ns, err);
    if (!err && data) {
      this.store.addResourceBundle(lng, ns, data, void 0, void 0, {
        skipCopy: true
      });
    }
    this.state[name] = err ? -1 : 2;
    if (err && data) this.state[name] = 0;
    const loaded = {};
    this.queue.forEach((q) => {
      pushPath(q.loaded, [lng], ns);
      removePending(q, name);
      if (err) q.errors.push(err);
      if (q.pendingCount === 0 && !q.done) {
        Object.keys(q.loaded).forEach((l) => {
          if (!loaded[l]) loaded[l] = {};
          const loadedKeys = q.loaded[l];
          if (loadedKeys.length) {
            loadedKeys.forEach((n) => {
              if (loaded[l][n] === void 0) loaded[l][n] = true;
            });
          }
        });
        q.done = true;
        if (q.errors.length) {
          q.callback(q.errors);
        } else {
          q.callback();
        }
      }
    });
    this.emit("loaded", loaded);
    this.queue = this.queue.filter((q) => !q.done);
  }
  read(lng, ns, fcName, tried = 0, wait = this.retryTimeout, callback) {
    if (!lng.length) return callback(null, {});
    if (this.readingCalls >= this.maxParallelReads) {
      this.waitingReads.push({
        lng,
        ns,
        fcName,
        tried,
        wait,
        callback
      });
      return;
    }
    this.readingCalls++;
    const resolver = /* @__PURE__ */ __name((err, data) => {
      this.readingCalls--;
      if (this.waitingReads.length > 0) {
        const next = this.waitingReads.shift();
        this.read(next.lng, next.ns, next.fcName, next.tried, next.wait, next.callback);
      }
      if (err && data && tried < this.maxRetries) {
        setTimeout(() => {
          this.read.call(this, lng, ns, fcName, tried + 1, wait * 2, callback);
        }, wait);
        return;
      }
      callback(err, data);
    }, "resolver");
    const fc = this.backend[fcName].bind(this.backend);
    if (fc.length === 2) {
      try {
        const r = fc(lng, ns);
        if (r && typeof r.then === "function") {
          r.then((data) => resolver(null, data)).catch(resolver);
        } else {
          resolver(null, r);
        }
      } catch (err) {
        resolver(err);
      }
      return;
    }
    return fc(lng, ns, resolver);
  }
  prepareLoading(languages, namespaces, options = {}, callback) {
    if (!this.backend) {
      this.logger.warn("No backend was added via i18next.use. Will not load resources.");
      return callback && callback();
    }
    if (isString(languages)) languages = this.languageUtils.toResolveHierarchy(languages);
    if (isString(namespaces)) namespaces = [namespaces];
    const toLoad = this.queueLoad(languages, namespaces, options, callback);
    if (!toLoad.toLoad.length) {
      if (!toLoad.pending.length) callback();
      return null;
    }
    toLoad.toLoad.forEach((name) => {
      this.loadOne(name);
    });
  }
  load(languages, namespaces, callback) {
    this.prepareLoading(languages, namespaces, {}, callback);
  }
  reload(languages, namespaces, callback) {
    this.prepareLoading(languages, namespaces, {
      reload: true
    }, callback);
  }
  loadOne(name, prefix = "") {
    const s = name.split("|");
    const lng = s[0];
    const ns = s[1];
    this.read(lng, ns, "read", void 0, void 0, (err, data) => {
      if (err) this.logger.warn(`${prefix}loading namespace ${ns} for language ${lng} failed`, err);
      if (!err && data) this.logger.log(`${prefix}loaded namespace ${ns} for language ${lng}`, data);
      this.loaded(name, err, data);
    });
  }
  saveMissing(languages, namespace, key, fallbackValue, isUpdate, options = {}, clb = () => {
  }) {
    if (this.services?.utils?.hasLoadedNamespace && !this.services?.utils?.hasLoadedNamespace(namespace)) {
      this.logger.warn(`did not save key "${key}" as the namespace "${namespace}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
      return;
    }
    if (key === void 0 || key === null || key === "") return;
    if (this.backend?.create) {
      const opts = {
        ...options,
        isUpdate
      };
      const fc = this.backend.create.bind(this.backend);
      if (fc.length < 6) {
        try {
          let r;
          if (fc.length === 5) {
            r = fc(languages, namespace, key, fallbackValue, opts);
          } else {
            r = fc(languages, namespace, key, fallbackValue);
          }
          if (r && typeof r.then === "function") {
            r.then((data) => clb(null, data)).catch(clb);
          } else {
            clb(null, r);
          }
        } catch (err) {
          clb(err);
        }
      } else {
        fc(languages, namespace, key, fallbackValue, clb, opts);
      }
    }
    if (!languages || !languages[0]) return;
    this.store.addResource(languages[0], namespace, key, fallbackValue);
  }
};
__name(_Connector, "Connector");
let Connector = _Connector;
const get = /* @__PURE__ */ __name(() => ({
  debug: false,
  initAsync: true,
  ns: ["translation"],
  defaultNS: ["translation"],
  fallbackLng: ["dev"],
  fallbackNS: false,
  supportedLngs: false,
  nonExplicitSupportedLngs: false,
  load: "all",
  preload: false,
  simplifyPluralSuffix: true,
  keySeparator: ".",
  nsSeparator: ":",
  pluralSeparator: "_",
  contextSeparator: "_",
  partialBundledLanguages: false,
  saveMissing: false,
  updateMissing: false,
  saveMissingTo: "fallback",
  saveMissingPlurals: true,
  missingKeyHandler: false,
  missingInterpolationHandler: false,
  postProcess: false,
  postProcessPassResolved: false,
  returnNull: false,
  returnEmptyString: true,
  returnObjects: false,
  joinArrays: false,
  returnedObjectHandler: false,
  parseMissingKeyHandler: false,
  appendNamespaceToMissingKey: false,
  appendNamespaceToCIMode: false,
  overloadTranslationOptionHandler: /* @__PURE__ */ __name((args) => {
    let ret = {};
    if (typeof args[1] === "object") ret = args[1];
    if (isString(args[1])) ret.defaultValue = args[1];
    if (isString(args[2])) ret.tDescription = args[2];
    if (typeof args[2] === "object" || typeof args[3] === "object") {
      const options = args[3] || args[2];
      Object.keys(options).forEach((key) => {
        ret[key] = options[key];
      });
    }
    return ret;
  }, "overloadTranslationOptionHandler"),
  interpolation: {
    escapeValue: true,
    format: /* @__PURE__ */ __name((value) => value, "format"),
    prefix: "{{",
    suffix: "}}",
    formatSeparator: ",",
    unescapePrefix: "-",
    nestingPrefix: "$t(",
    nestingSuffix: ")",
    nestingOptionsSeparator: ",",
    maxReplaces: 1e3,
    skipOnVariables: true
  },
  cacheInBuiltFormats: true
}), "get");
const transformOptions = /* @__PURE__ */ __name((options) => {
  if (isString(options.ns)) options.ns = [options.ns];
  if (isString(options.fallbackLng)) options.fallbackLng = [options.fallbackLng];
  if (isString(options.fallbackNS)) options.fallbackNS = [options.fallbackNS];
  if (options.supportedLngs?.indexOf?.("cimode") < 0) {
    options.supportedLngs = options.supportedLngs.concat(["cimode"]);
  }
  if (typeof options.initImmediate === "boolean") options.initAsync = options.initImmediate;
  return options;
}, "transformOptions");
const noop = /* @__PURE__ */ __name(() => {
}, "noop");
const bindMemberFunctions = /* @__PURE__ */ __name((inst) => {
  const mems = Object.getOwnPropertyNames(Object.getPrototypeOf(inst));
  mems.forEach((mem) => {
    if (typeof inst[mem] === "function") {
      inst[mem] = inst[mem].bind(inst);
    }
  });
}, "bindMemberFunctions");
const usesLocize = /* @__PURE__ */ __name((inst) => {
  if (inst?.modules?.backend?.name?.indexOf("Locize") > 0) return true;
  if (inst?.modules?.backend?.constructor?.name?.indexOf("Locize") > 0) return true;
  if (inst?.options?.backend?.backends) {
    if (inst.options.backend.backends.some((b) => b?.name?.indexOf("Locize") > 0 || b?.constructor?.name?.indexOf("Locize") > 0)) return true;
  }
  return false;
}, "usesLocize");
const _I18n = class _I18n extends EventEmitter {
  constructor(options = {}, callback) {
    super();
    this.options = transformOptions(options);
    this.services = {};
    this.logger = baseLogger;
    this.modules = {
      external: []
    };
    bindMemberFunctions(this);
    if (callback && !this.isInitialized && !options.isClone) {
      if (!this.options.initAsync) {
        this.init(options, callback);
        return this;
      }
      setTimeout(() => {
        this.init(options, callback);
      }, 0);
    }
  }
  init(options = {}, callback) {
    this.isInitializing = true;
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    if (options.defaultNS == null && options.ns) {
      if (isString(options.ns)) {
        options.defaultNS = options.ns;
      } else if (options.ns.indexOf("translation") < 0) {
        options.defaultNS = options.ns[0];
      }
    }
    const defOpts = get();
    this.options = {
      ...defOpts,
      ...this.options,
      ...transformOptions(options)
    };
    this.options.interpolation = {
      ...defOpts.interpolation,
      ...this.options.interpolation
    };
    if (options.keySeparator !== void 0) {
      this.options.userDefinedKeySeparator = options.keySeparator;
    }
    if (options.nsSeparator !== void 0) {
      this.options.userDefinedNsSeparator = options.nsSeparator;
    }
    if (typeof this.options.overloadTranslationOptionHandler !== "function") {
      this.options.overloadTranslationOptionHandler = defOpts.overloadTranslationOptionHandler;
    }
    if (this.options.showSupportNotice !== false && !usesLocize(this)) {
      if (typeof console !== "undefined" && typeof console.info !== "undefined") console.info("ðŸŒ i18next is maintained with support from locize.com â€” consider powering your project with managed localization (AI, CDN, integrations): https://locize.com ðŸ’™");
    }
    const createClassOnDemand = /* @__PURE__ */ __name((ClassOrObject) => {
      if (!ClassOrObject) return null;
      if (typeof ClassOrObject === "function") return new ClassOrObject();
      return ClassOrObject;
    }, "createClassOnDemand");
    if (!this.options.isClone) {
      if (this.modules.logger) {
        baseLogger.init(createClassOnDemand(this.modules.logger), this.options);
      } else {
        baseLogger.init(null, this.options);
      }
      let formatter;
      if (this.modules.formatter) {
        formatter = this.modules.formatter;
      } else {
        formatter = Formatter;
      }
      const lu = new LanguageUtil(this.options);
      this.store = new ResourceStore(this.options.resources, this.options);
      const s = this.services;
      s.logger = baseLogger;
      s.resourceStore = this.store;
      s.languageUtils = lu;
      s.pluralResolver = new PluralResolver(lu, {
        prepend: this.options.pluralSeparator,
        simplifyPluralSuffix: this.options.simplifyPluralSuffix
      });
      const usingLegacyFormatFunction = this.options.interpolation.format && this.options.interpolation.format !== defOpts.interpolation.format;
      if (usingLegacyFormatFunction) {
        this.logger.deprecate(`init: you are still using the legacy format function, please use the new approach: https://www.i18next.com/translation-function/formatting`);
      }
      if (formatter && (!this.options.interpolation.format || this.options.interpolation.format === defOpts.interpolation.format)) {
        s.formatter = createClassOnDemand(formatter);
        if (s.formatter.init) s.formatter.init(s, this.options);
        this.options.interpolation.format = s.formatter.format.bind(s.formatter);
      }
      s.interpolator = new Interpolator(this.options);
      s.utils = {
        hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
      };
      s.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s.resourceStore, s, this.options);
      s.backendConnector.on("*", (event, ...args) => {
        this.emit(event, ...args);
      });
      if (this.modules.languageDetector) {
        s.languageDetector = createClassOnDemand(this.modules.languageDetector);
        if (s.languageDetector.init) s.languageDetector.init(s, this.options.detection, this.options);
      }
      if (this.modules.i18nFormat) {
        s.i18nFormat = createClassOnDemand(this.modules.i18nFormat);
        if (s.i18nFormat.init) s.i18nFormat.init(this);
      }
      this.translator = new Translator(this.services, this.options);
      this.translator.on("*", (event, ...args) => {
        this.emit(event, ...args);
      });
      this.modules.external.forEach((m) => {
        if (m.init) m.init(this);
      });
    }
    this.format = this.options.interpolation.format;
    if (!callback) callback = noop;
    if (this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
      const codes = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
      if (codes.length > 0 && codes[0] !== "dev") this.options.lng = codes[0];
    }
    if (!this.services.languageDetector && !this.options.lng) {
      this.logger.warn("init: no languageDetector is used and no lng is defined");
    }
    const storeApi = ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"];
    storeApi.forEach((fcName) => {
      this[fcName] = (...args) => this.store[fcName](...args);
    });
    const storeApiChained = ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"];
    storeApiChained.forEach((fcName) => {
      this[fcName] = (...args) => {
        this.store[fcName](...args);
        return this;
      };
    });
    const deferred = defer();
    const load = /* @__PURE__ */ __name(() => {
      const finish = /* @__PURE__ */ __name((err, t) => {
        this.isInitializing = false;
        if (this.isInitialized && !this.initializedStoreOnce) this.logger.warn("init: i18next is already initialized. You should call init just once!");
        this.isInitialized = true;
        if (!this.options.isClone) this.logger.log("initialized", this.options);
        this.emit("initialized", this.options);
        deferred.resolve(t);
        callback(err, t);
      }, "finish");
      if (this.languages && !this.isInitialized) return finish(null, this.t.bind(this));
      this.changeLanguage(this.options.lng, finish);
    }, "load");
    if (this.options.resources || !this.options.initAsync) {
      load();
    } else {
      setTimeout(load, 0);
    }
    return deferred;
  }
  loadResources(language, callback = noop) {
    let usedCallback = callback;
    const usedLng = isString(language) ? language : this.language;
    if (typeof language === "function") usedCallback = language;
    if (!this.options.resources || this.options.partialBundledLanguages) {
      if (usedLng?.toLowerCase() === "cimode" && (!this.options.preload || this.options.preload.length === 0)) return usedCallback();
      const toLoad = [];
      const append = /* @__PURE__ */ __name((lng) => {
        if (!lng) return;
        if (lng === "cimode") return;
        const lngs = this.services.languageUtils.toResolveHierarchy(lng);
        lngs.forEach((l) => {
          if (l === "cimode") return;
          if (toLoad.indexOf(l) < 0) toLoad.push(l);
        });
      }, "append");
      if (!usedLng) {
        const fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
        fallbacks.forEach((l) => append(l));
      } else {
        append(usedLng);
      }
      this.options.preload?.forEach?.((l) => append(l));
      this.services.backendConnector.load(toLoad, this.options.ns, (e) => {
        if (!e && !this.resolvedLanguage && this.language) this.setResolvedLanguage(this.language);
        usedCallback(e);
      });
    } else {
      usedCallback(null);
    }
  }
  reloadResources(lngs, ns, callback) {
    const deferred = defer();
    if (typeof lngs === "function") {
      callback = lngs;
      lngs = void 0;
    }
    if (typeof ns === "function") {
      callback = ns;
      ns = void 0;
    }
    if (!lngs) lngs = this.languages;
    if (!ns) ns = this.options.ns;
    if (!callback) callback = noop;
    this.services.backendConnector.reload(lngs, ns, (err) => {
      deferred.resolve();
      callback(err);
    });
    return deferred;
  }
  use(module) {
    if (!module) throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
    if (!module.type) throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
    if (module.type === "backend") {
      this.modules.backend = module;
    }
    if (module.type === "logger" || module.log && module.warn && module.error) {
      this.modules.logger = module;
    }
    if (module.type === "languageDetector") {
      this.modules.languageDetector = module;
    }
    if (module.type === "i18nFormat") {
      this.modules.i18nFormat = module;
    }
    if (module.type === "postProcessor") {
      postProcessor.addPostProcessor(module);
    }
    if (module.type === "formatter") {
      this.modules.formatter = module;
    }
    if (module.type === "3rdParty") {
      this.modules.external.push(module);
    }
    return this;
  }
  setResolvedLanguage(l) {
    if (!l || !this.languages) return;
    if (["cimode", "dev"].indexOf(l) > -1) return;
    for (let li = 0; li < this.languages.length; li++) {
      const lngInLngs = this.languages[li];
      if (["cimode", "dev"].indexOf(lngInLngs) > -1) continue;
      if (this.store.hasLanguageSomeTranslations(lngInLngs)) {
        this.resolvedLanguage = lngInLngs;
        break;
      }
    }
    if (!this.resolvedLanguage && this.languages.indexOf(l) < 0 && this.store.hasLanguageSomeTranslations(l)) {
      this.resolvedLanguage = l;
      this.languages.unshift(l);
    }
  }
  changeLanguage(lng, callback) {
    this.isLanguageChangingTo = lng;
    const deferred = defer();
    this.emit("languageChanging", lng);
    const setLngProps = /* @__PURE__ */ __name((l) => {
      this.language = l;
      this.languages = this.services.languageUtils.toResolveHierarchy(l);
      this.resolvedLanguage = void 0;
      this.setResolvedLanguage(l);
    }, "setLngProps");
    const done = /* @__PURE__ */ __name((err, l) => {
      if (l) {
        if (this.isLanguageChangingTo === lng) {
          setLngProps(l);
          this.translator.changeLanguage(l);
          this.isLanguageChangingTo = void 0;
          this.emit("languageChanged", l);
          this.logger.log("languageChanged", l);
        }
      } else {
        this.isLanguageChangingTo = void 0;
      }
      deferred.resolve((...args) => this.t(...args));
      if (callback) callback(err, (...args) => this.t(...args));
    }, "done");
    const setLng = /* @__PURE__ */ __name((lngs) => {
      if (!lng && !lngs && this.services.languageDetector) lngs = [];
      const fl = isString(lngs) ? lngs : lngs && lngs[0];
      const l = this.store.hasLanguageSomeTranslations(fl) ? fl : this.services.languageUtils.getBestMatchFromCodes(isString(lngs) ? [lngs] : lngs);
      if (l) {
        if (!this.language) {
          setLngProps(l);
        }
        if (!this.translator.language) this.translator.changeLanguage(l);
        this.services.languageDetector?.cacheUserLanguage?.(l);
      }
      this.loadResources(l, (err) => {
        done(err, l);
      });
    }, "setLng");
    if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {
      setLng(this.services.languageDetector.detect());
    } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {
      if (this.services.languageDetector.detect.length === 0) {
        this.services.languageDetector.detect().then(setLng);
      } else {
        this.services.languageDetector.detect(setLng);
      }
    } else {
      setLng(lng);
    }
    return deferred;
  }
  getFixedT(lng, ns, keyPrefix) {
    const fixedT = /* @__PURE__ */ __name((key, opts, ...rest) => {
      let o;
      if (typeof opts !== "object") {
        o = this.options.overloadTranslationOptionHandler([key, opts].concat(rest));
      } else {
        o = {
          ...opts
        };
      }
      o.lng = o.lng || fixedT.lng;
      o.lngs = o.lngs || fixedT.lngs;
      o.ns = o.ns || fixedT.ns;
      if (o.keyPrefix !== "") o.keyPrefix = o.keyPrefix || keyPrefix || fixedT.keyPrefix;
      const keySeparator = this.options.keySeparator || ".";
      let resultKey;
      if (o.keyPrefix && Array.isArray(key)) {
        resultKey = key.map((k) => {
          if (typeof k === "function") k = keysFromSelector(k, {
            ...this.options,
            ...opts
          });
          return `${o.keyPrefix}${keySeparator}${k}`;
        });
      } else {
        if (typeof key === "function") key = keysFromSelector(key, {
          ...this.options,
          ...opts
        });
        resultKey = o.keyPrefix ? `${o.keyPrefix}${keySeparator}${key}` : key;
      }
      return this.t(resultKey, o);
    }, "fixedT");
    if (isString(lng)) {
      fixedT.lng = lng;
    } else {
      fixedT.lngs = lng;
    }
    fixedT.ns = ns;
    fixedT.keyPrefix = keyPrefix;
    return fixedT;
  }
  t(...args) {
    return this.translator?.translate(...args);
  }
  exists(...args) {
    return this.translator?.exists(...args);
  }
  setDefaultNamespace(ns) {
    this.options.defaultNS = ns;
  }
  hasLoadedNamespace(ns, options = {}) {
    if (!this.isInitialized) {
      this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages);
      return false;
    }
    if (!this.languages || !this.languages.length) {
      this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages);
      return false;
    }
    const lng = options.lng || this.resolvedLanguage || this.languages[0];
    const fallbackLng = this.options ? this.options.fallbackLng : false;
    const lastLng = this.languages[this.languages.length - 1];
    if (lng.toLowerCase() === "cimode") return true;
    const loadNotPending = /* @__PURE__ */ __name((l, n) => {
      const loadState = this.services.backendConnector.state[`${l}|${n}`];
      return loadState === -1 || loadState === 0 || loadState === 2;
    }, "loadNotPending");
    if (options.precheck) {
      const preResult = options.precheck(this, loadNotPending);
      if (preResult !== void 0) return preResult;
    }
    if (this.hasResourceBundle(lng, ns)) return true;
    if (!this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages) return true;
    if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns))) return true;
    return false;
  }
  loadNamespaces(ns, callback) {
    const deferred = defer();
    if (!this.options.ns) {
      if (callback) callback();
      return Promise.resolve();
    }
    if (isString(ns)) ns = [ns];
    ns.forEach((n) => {
      if (this.options.ns.indexOf(n) < 0) this.options.ns.push(n);
    });
    this.loadResources((err) => {
      deferred.resolve();
      if (callback) callback(err);
    });
    return deferred;
  }
  loadLanguages(lngs, callback) {
    const deferred = defer();
    if (isString(lngs)) lngs = [lngs];
    const preloaded = this.options.preload || [];
    const newLngs = lngs.filter((lng) => preloaded.indexOf(lng) < 0 && this.services.languageUtils.isSupportedCode(lng));
    if (!newLngs.length) {
      if (callback) callback();
      return Promise.resolve();
    }
    this.options.preload = preloaded.concat(newLngs);
    this.loadResources((err) => {
      deferred.resolve();
      if (callback) callback(err);
    });
    return deferred;
  }
  dir(lng) {
    if (!lng) lng = this.resolvedLanguage || (this.languages?.length > 0 ? this.languages[0] : this.language);
    if (!lng) return "rtl";
    try {
      const l = new Intl.Locale(lng);
      if (l && l.getTextInfo) {
        const ti = l.getTextInfo();
        if (ti && ti.direction) return ti.direction;
      }
    } catch (e) {
    }
    const rtlLngs = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"];
    const languageUtils = this.services?.languageUtils || new LanguageUtil(get());
    if (lng.toLowerCase().indexOf("-latn") > 1) return "ltr";
    return rtlLngs.indexOf(languageUtils.getLanguagePartFromCode(lng)) > -1 || lng.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr";
  }
  static createInstance(options = {}, callback) {
    const instance2 = new _I18n(options, callback);
    instance2.createInstance = _I18n.createInstance;
    return instance2;
  }
  cloneInstance(options = {}, callback = noop) {
    const forkResourceStore = options.forkResourceStore;
    if (forkResourceStore) delete options.forkResourceStore;
    const mergedOptions = {
      ...this.options,
      ...options,
      ...{
        isClone: true
      }
    };
    const clone = new _I18n(mergedOptions);
    if (options.debug !== void 0 || options.prefix !== void 0) {
      clone.logger = clone.logger.clone(options);
    }
    const membersToCopy = ["store", "services", "language"];
    membersToCopy.forEach((m) => {
      clone[m] = this[m];
    });
    clone.services = {
      ...this.services
    };
    clone.services.utils = {
      hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
    };
    if (forkResourceStore) {
      const clonedData = Object.keys(this.store.data).reduce((prev, l) => {
        prev[l] = {
          ...this.store.data[l]
        };
        prev[l] = Object.keys(prev[l]).reduce((acc, n) => {
          acc[n] = {
            ...prev[l][n]
          };
          return acc;
        }, prev[l]);
        return prev;
      }, {});
      clone.store = new ResourceStore(clonedData, mergedOptions);
      clone.services.resourceStore = clone.store;
    }
    if (options.interpolation) {
      const defOpts = get();
      const mergedInterpolation = {
        ...defOpts.interpolation,
        ...this.options.interpolation,
        ...options.interpolation
      };
      const mergedForInterpolator = {
        ...mergedOptions,
        interpolation: mergedInterpolation
      };
      clone.services.interpolator = new Interpolator(mergedForInterpolator);
    }
    clone.translator = new Translator(clone.services, mergedOptions);
    clone.translator.on("*", (event, ...args) => {
      clone.emit(event, ...args);
    });
    clone.init(mergedOptions, callback);
    clone.translator.options = mergedOptions;
    clone.translator.backendConnector.services.utils = {
      hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
    };
    return clone;
  }
  toJSON() {
    return {
      options: this.options,
      store: this.store,
      language: this.language,
      languages: this.languages,
      resolvedLanguage: this.resolvedLanguage
    };
  }
};
__name(_I18n, "I18n");
let I18n = _I18n;
const instance = I18n.createInstance();
instance.createInstance;
instance.dir;
instance.init;
instance.loadResources;
instance.reloadResources;
instance.use;
instance.changeLanguage;
instance.getFixedT;
instance.t;
instance.exists;
instance.setDefaultNamespace;
instance.hasLoadedNamespace;
instance.loadNamespaces;
instance.loadLanguages;
const matchHtmlEntity = /&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34|nbsp|#160|copy|#169|reg|#174|hellip|#8230|#x2F|#47);/g;
const htmlEntities = {
  "&amp;": "&",
  "&#38;": "&",
  "&lt;": "<",
  "&#60;": "<",
  "&gt;": ">",
  "&#62;": ">",
  "&apos;": "'",
  "&#39;": "'",
  "&quot;": '"',
  "&#34;": '"',
  "&nbsp;": " ",
  "&#160;": " ",
  "&copy;": "Â©",
  "&#169;": "Â©",
  "&reg;": "Â®",
  "&#174;": "Â®",
  "&hellip;": "â€¦",
  "&#8230;": "â€¦",
  "&#x2F;": "/",
  "&#47;": "/"
};
const unescapeHtmlEntity = /* @__PURE__ */ __name((m) => htmlEntities[m], "unescapeHtmlEntity");
const unescape = /* @__PURE__ */ __name((text) => text.replace(matchHtmlEntity, unescapeHtmlEntity), "unescape");
let defaultOptions = {
  bindI18n: "languageChanged",
  bindI18nStore: "",
  transEmptyNodeValue: "",
  transSupportBasicHtmlNodes: true,
  transWrapTextNodes: "",
  transKeepBasicHtmlNodesFor: ["br", "strong", "i", "p"],
  useSuspense: true,
  unescape,
  transDefaultProps: void 0
};
const setDefaults = /* @__PURE__ */ __name((options = {}) => {
  defaultOptions = {
    ...defaultOptions,
    ...options
  };
}, "setDefaults");
const initReactI18next = {
  type: "3rdParty",
  init(instance2) {
    setDefaults(instance2.options.react);
  }
};
const {
  slice,
  forEach
} = [];
function defaults(obj) {
  forEach.call(slice.call(arguments, 1), (source) => {
    if (source) {
      for (const prop in source) {
        if (obj[prop] === void 0) obj[prop] = source[prop];
      }
    }
  });
  return obj;
}
__name(defaults, "defaults");
function hasXSS(input) {
  if (typeof input !== "string") return false;
  const xssPatterns = [/<\s*script.*?>/i, /<\s*\/\s*script\s*>/i, /<\s*img.*?on\w+\s*=/i, /<\s*\w+\s*on\w+\s*=.*?>/i, /javascript\s*:/i, /vbscript\s*:/i, /expression\s*\(/i, /eval\s*\(/i, /alert\s*\(/i, /document\.cookie/i, /document\.write\s*\(/i, /window\.location/i, /innerHTML/i];
  return xssPatterns.some((pattern) => pattern.test(input));
}
__name(hasXSS, "hasXSS");
const fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
const serializeCookie = /* @__PURE__ */ __name(function(name, val) {
  let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
    path: "/"
  };
  const opt = options;
  const value = encodeURIComponent(val);
  let str = `${name}=${value}`;
  if (opt.maxAge > 0) {
    const maxAge = opt.maxAge - 0;
    if (Number.isNaN(maxAge)) throw new Error("maxAge should be a Number");
    str += `; Max-Age=${Math.floor(maxAge)}`;
  }
  if (opt.domain) {
    if (!fieldContentRegExp.test(opt.domain)) {
      throw new TypeError("option domain is invalid");
    }
    str += `; Domain=${opt.domain}`;
  }
  if (opt.path) {
    if (!fieldContentRegExp.test(opt.path)) {
      throw new TypeError("option path is invalid");
    }
    str += `; Path=${opt.path}`;
  }
  if (opt.expires) {
    if (typeof opt.expires.toUTCString !== "function") {
      throw new TypeError("option expires is invalid");
    }
    str += `; Expires=${opt.expires.toUTCString()}`;
  }
  if (opt.httpOnly) str += "; HttpOnly";
  if (opt.secure) str += "; Secure";
  if (opt.sameSite) {
    const sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
    switch (sameSite) {
      case true:
        str += "; SameSite=Strict";
        break;
      case "lax":
        str += "; SameSite=Lax";
        break;
      case "strict":
        str += "; SameSite=Strict";
        break;
      case "none":
        str += "; SameSite=None";
        break;
      default:
        throw new TypeError("option sameSite is invalid");
    }
  }
  if (opt.partitioned) str += "; Partitioned";
  return str;
}, "serializeCookie");
const cookie = {
  create(name, value, minutes, domain) {
    let cookieOptions = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
      path: "/",
      sameSite: "strict"
    };
    if (minutes) {
      cookieOptions.expires = /* @__PURE__ */ new Date();
      cookieOptions.expires.setTime(cookieOptions.expires.getTime() + minutes * 60 * 1e3);
    }
    if (domain) cookieOptions.domain = domain;
    document.cookie = serializeCookie(name, value, cookieOptions);
  },
  read(name) {
    const nameEQ = `${name}=`;
    const ca = document.cookie.split(";");
    for (let i = 0; i < ca.length; i++) {
      let c = ca[i];
      while (c.charAt(0) === " ") c = c.substring(1, c.length);
      if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);
    }
    return null;
  },
  remove(name, domain) {
    this.create(name, "", -1, domain);
  }
};
var cookie$1 = {
  name: "cookie",
  // Deconstruct the options object and extract the lookupCookie property
  lookup(_ref) {
    let {
      lookupCookie
    } = _ref;
    if (lookupCookie && typeof document !== "undefined") {
      return cookie.read(lookupCookie) || void 0;
    }
    return void 0;
  },
  // Deconstruct the options object and extract the lookupCookie, cookieMinutes, cookieDomain, and cookieOptions properties
  cacheUserLanguage(lng, _ref2) {
    let {
      lookupCookie,
      cookieMinutes,
      cookieDomain,
      cookieOptions
    } = _ref2;
    if (lookupCookie && typeof document !== "undefined") {
      cookie.create(lookupCookie, lng, cookieMinutes, cookieDomain, cookieOptions);
    }
  }
};
var querystring = {
  name: "querystring",
  // Deconstruct the options object and extract the lookupQuerystring property
  lookup(_ref) {
    let {
      lookupQuerystring
    } = _ref;
    let found;
    if (typeof window !== "undefined") {
      let {
        search
      } = window.location;
      if (!window.location.search && window.location.hash?.indexOf("?") > -1) {
        search = window.location.hash.substring(window.location.hash.indexOf("?"));
      }
      const query = search.substring(1);
      const params = query.split("&");
      for (let i = 0; i < params.length; i++) {
        const pos = params[i].indexOf("=");
        if (pos > 0) {
          const key = params[i].substring(0, pos);
          if (key === lookupQuerystring) {
            found = params[i].substring(pos + 1);
          }
        }
      }
    }
    return found;
  }
};
var hash = {
  name: "hash",
  // Deconstruct the options object and extract the lookupHash property and the lookupFromHashIndex property
  lookup(_ref) {
    let {
      lookupHash,
      lookupFromHashIndex
    } = _ref;
    let found;
    if (typeof window !== "undefined") {
      const {
        hash: hash2
      } = window.location;
      if (hash2 && hash2.length > 2) {
        const query = hash2.substring(1);
        if (lookupHash) {
          const params = query.split("&");
          for (let i = 0; i < params.length; i++) {
            const pos = params[i].indexOf("=");
            if (pos > 0) {
              const key = params[i].substring(0, pos);
              if (key === lookupHash) {
                found = params[i].substring(pos + 1);
              }
            }
          }
        }
        if (found) return found;
        if (!found && lookupFromHashIndex > -1) {
          const language = hash2.match(/\/([a-zA-Z-]*)/g);
          if (!Array.isArray(language)) return void 0;
          const index = typeof lookupFromHashIndex === "number" ? lookupFromHashIndex : 0;
          return language[index]?.replace("/", "");
        }
      }
    }
    return found;
  }
};
let hasLocalStorageSupport = null;
const localStorageAvailable = /* @__PURE__ */ __name(() => {
  if (hasLocalStorageSupport !== null) return hasLocalStorageSupport;
  try {
    hasLocalStorageSupport = typeof window !== "undefined" && window.localStorage !== null;
    if (!hasLocalStorageSupport) {
      return false;
    }
    const testKey = "i18next.translate.boo";
    window.localStorage.setItem(testKey, "foo");
    window.localStorage.removeItem(testKey);
  } catch (e) {
    hasLocalStorageSupport = false;
  }
  return hasLocalStorageSupport;
}, "localStorageAvailable");
var localStorage$1 = {
  name: "localStorage",
  // Deconstruct the options object and extract the lookupLocalStorage property
  lookup(_ref) {
    let {
      lookupLocalStorage
    } = _ref;
    if (lookupLocalStorage && localStorageAvailable()) {
      return window.localStorage.getItem(lookupLocalStorage) || void 0;
    }
    return void 0;
  },
  // Deconstruct the options object and extract the lookupLocalStorage property
  cacheUserLanguage(lng, _ref2) {
    let {
      lookupLocalStorage
    } = _ref2;
    if (lookupLocalStorage && localStorageAvailable()) {
      window.localStorage.setItem(lookupLocalStorage, lng);
    }
  }
};
let hasSessionStorageSupport = null;
const sessionStorageAvailable = /* @__PURE__ */ __name(() => {
  if (hasSessionStorageSupport !== null) return hasSessionStorageSupport;
  try {
    hasSessionStorageSupport = typeof window !== "undefined" && window.sessionStorage !== null;
    if (!hasSessionStorageSupport) {
      return false;
    }
    const testKey = "i18next.translate.boo";
    window.sessionStorage.setItem(testKey, "foo");
    window.sessionStorage.removeItem(testKey);
  } catch (e) {
    hasSessionStorageSupport = false;
  }
  return hasSessionStorageSupport;
}, "sessionStorageAvailable");
var sessionStorage$1 = {
  name: "sessionStorage",
  lookup(_ref) {
    let {
      lookupSessionStorage
    } = _ref;
    if (lookupSessionStorage && sessionStorageAvailable()) {
      return window.sessionStorage.getItem(lookupSessionStorage) || void 0;
    }
    return void 0;
  },
  cacheUserLanguage(lng, _ref2) {
    let {
      lookupSessionStorage
    } = _ref2;
    if (lookupSessionStorage && sessionStorageAvailable()) {
      window.sessionStorage.setItem(lookupSessionStorage, lng);
    }
  }
};
var navigator$1 = {
  name: "navigator",
  lookup(options) {
    const found = [];
    if (typeof navigator !== "undefined") {
      const {
        languages,
        userLanguage,
        language
      } = navigator;
      if (languages) {
        for (let i = 0; i < languages.length; i++) {
          found.push(languages[i]);
        }
      }
      if (userLanguage) {
        found.push(userLanguage);
      }
      if (language) {
        found.push(language);
      }
    }
    return found.length > 0 ? found : void 0;
  }
};
var htmlTag = {
  name: "htmlTag",
  // Deconstruct the options object and extract the htmlTag property
  lookup(_ref) {
    let {
      htmlTag: htmlTag2
    } = _ref;
    let found;
    const internalHtmlTag = htmlTag2 || (typeof document !== "undefined" ? document.documentElement : null);
    if (internalHtmlTag && typeof internalHtmlTag.getAttribute === "function") {
      found = internalHtmlTag.getAttribute("lang");
    }
    return found;
  }
};
var path = {
  name: "path",
  // Deconstruct the options object and extract the lookupFromPathIndex property
  lookup(_ref) {
    let {
      lookupFromPathIndex
    } = _ref;
    if (typeof window === "undefined") return void 0;
    const language = window.location.pathname.match(/\/([a-zA-Z-]*)/g);
    if (!Array.isArray(language)) return void 0;
    const index = typeof lookupFromPathIndex === "number" ? lookupFromPathIndex : 0;
    return language[index]?.replace("/", "");
  }
};
var subdomain = {
  name: "subdomain",
  lookup(_ref) {
    let {
      lookupFromSubdomainIndex
    } = _ref;
    const internalLookupFromSubdomainIndex = typeof lookupFromSubdomainIndex === "number" ? lookupFromSubdomainIndex + 1 : 1;
    const language = typeof window !== "undefined" && window.location?.hostname?.match(/^(\w{2,5})\.(([a-z0-9-]{1,63}\.[a-z]{2,6})|localhost)/i);
    if (!language) return void 0;
    return language[internalLookupFromSubdomainIndex];
  }
};
let canCookies = false;
try {
  document.cookie;
  canCookies = true;
} catch (e) {
}
const order = ["querystring", "cookie", "localStorage", "sessionStorage", "navigator", "htmlTag"];
if (!canCookies) order.splice(1, 1);
const getDefaults = /* @__PURE__ */ __name(() => ({
  order,
  lookupQuerystring: "lng",
  lookupCookie: "i18next",
  lookupLocalStorage: "i18nextLng",
  lookupSessionStorage: "i18nextLng",
  // cache user language
  caches: ["localStorage"],
  excludeCacheFor: ["cimode"],
  // cookieMinutes: 10,
  // cookieDomain: 'myDomain'
  convertDetectedLanguage: /* @__PURE__ */ __name((l) => l, "convertDetectedLanguage")
}), "getDefaults");
const _Browser = class _Browser {
  constructor(services) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.type = "languageDetector";
    this.detectors = {};
    this.init(services, options);
  }
  init() {
    let services = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      languageUtils: {}
    };
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let i18nOptions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    this.services = services;
    this.options = defaults(options, this.options || {}, getDefaults());
    if (typeof this.options.convertDetectedLanguage === "string" && this.options.convertDetectedLanguage.indexOf("15897") > -1) {
      this.options.convertDetectedLanguage = (l) => l.replace("-", "_");
    }
    if (this.options.lookupFromUrlIndex) this.options.lookupFromPathIndex = this.options.lookupFromUrlIndex;
    this.i18nOptions = i18nOptions;
    this.addDetector(cookie$1);
    this.addDetector(querystring);
    this.addDetector(localStorage$1);
    this.addDetector(sessionStorage$1);
    this.addDetector(navigator$1);
    this.addDetector(htmlTag);
    this.addDetector(path);
    this.addDetector(subdomain);
    this.addDetector(hash);
  }
  addDetector(detector) {
    this.detectors[detector.name] = detector;
    return this;
  }
  detect() {
    let detectionOrder = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.options.order;
    let detected = [];
    detectionOrder.forEach((detectorName) => {
      if (this.detectors[detectorName]) {
        let lookup = this.detectors[detectorName].lookup(this.options);
        if (lookup && typeof lookup === "string") lookup = [lookup];
        if (lookup) detected = detected.concat(lookup);
      }
    });
    detected = detected.filter((d) => d !== void 0 && d !== null && !hasXSS(d)).map((d) => this.options.convertDetectedLanguage(d));
    if (this.services && this.services.languageUtils && this.services.languageUtils.getBestMatchFromCodes) return detected;
    return detected.length > 0 ? detected[0] : null;
  }
  cacheUserLanguage(lng) {
    let caches2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.options.caches;
    if (!caches2) return;
    if (this.options.excludeCacheFor && this.options.excludeCacheFor.indexOf(lng) > -1) return;
    caches2.forEach((cacheName) => {
      if (this.detectors[cacheName]) this.detectors[cacheName].cacheUserLanguage(lng, this.options);
    });
  }
};
__name(_Browser, "Browser");
let Browser = _Browser;
Browser.type = "languageDetector";
const common$1 = { "loading": "YÃ¼kleniyor...", "save": "Kaydet", "cancel": "Ä°ptal", "delete": "Sil", "edit": "DÃ¼zenle", "close": "Kapat", "confirm": "Onayla", "search": "Ara", "send": "GÃ¶nder", "copy": "Kopyala", "copied": "KopyalandÄ±!", "back": "Geri", "next": "Ä°leri", "yes": "Evet", "no": "HayÄ±r", "ok": "Tamam", "error": "Hata", "success": "BaÅŸarÄ±lÄ±", "warning": "UyarÄ±", "info": "Bilgi", "retry": "Tekrar Dene", "logout": "Ã‡Ä±kÄ±ÅŸ Yap", "settings": "Ayarlar", "profile": "Profil", "online": "Ã‡evrimiÃ§i", "offline": "Ã‡evrimdÄ±ÅŸÄ±", "idle": "BoÅŸta", "dnd": "RahatsÄ±z Etmeyin", "invisible": "GÃ¶rÃ¼nmez", "members": "Ãœyeler", "channels": "Kanallar", "roles": "Roller", "server": "Sunucu", "invite": "Davet Et", "upload": "YÃ¼kle", "download": "Ä°ndir", "mute": "Sessize Al", "unmute": "Sesi AÃ§", "deafen": "SaÄŸÄ±rlaÅŸtÄ±r", "undeafen": "SaÄŸÄ±rlÄ±ÄŸÄ± KaldÄ±r", "ban": "Yasakla", "kick": "At", "block": "Engelle", "unblock": "Engeli KaldÄ±r", "report": "Åžikayet Et" };
const auth$1 = { "login": "GiriÅŸ Yap", "register": "KayÄ±t Ol", "email": "E-posta", "password": "Åžifre", "confirmPassword": "Åžifre Tekrar", "username": "KullanÄ±cÄ± AdÄ±", "forgotPassword": "Åžifreni mi unuttun?", "loginWith": "ile GiriÅŸ Yap", "registerWith": "ile KayÄ±t Ol", "orContinueWith": "veya ÅŸununla devam et", "alreadyHaveAccount": "Zaten hesabÄ±n var mÄ±?", "dontHaveAccount": "HesabÄ±n yok mu?", "loginSuccess": "GiriÅŸ baÅŸarÄ±lÄ±!", "registerSuccess": "KayÄ±t baÅŸarÄ±lÄ±!", "invalidCredentials": "GeÃ§ersiz e-posta veya ÅŸifre", "emailRequired": "E-posta gerekli", "passwordRequired": "Åžifre gerekli", "passwordTooShort": "Åžifre en az 8 karakter olmalÄ±", "passwordsDoNotMatch": "Åžifreler eÅŸleÅŸmiyor", "emailAlreadyInUse": "Bu e-posta zaten kullanÄ±mda", "usernameAlreadyInUse": "Bu kullanÄ±cÄ± adÄ± zaten alÄ±nmÄ±ÅŸ", "verifyEmail": "E-postanÄ±zÄ± doÄŸrulayÄ±n", "verifyEmailSent": "DoÄŸrulama e-postasÄ± gÃ¶nderildi", "twoFactorAuth": "Ä°ki FaktÃ¶rlÃ¼ DoÄŸrulama", "enterCode": "Kodu girin", "enable2FA": "2FA'yÄ± EtkinleÅŸtir", "disable2FA": "2FA'yÄ± Devre DÄ±ÅŸÄ± BÄ±rak" };
const chat$1 = { "typeMessage": "Mesaj yaz...", "editMessage": "MesajÄ± DÃ¼zenle", "deleteMessage": "MesajÄ± Sil", "replyTo": "YanÄ±tla", "pinMessage": "MesajÄ± Sabitle", "unpinMessage": "Sabitlemeyi KaldÄ±r", "threadStart": "Konu BaÅŸlat", "noMessages": "HenÃ¼z mesaj yok", "newMessages": "Yeni mesajlar", "today": "BugÃ¼n", "yesterday": "DÃ¼n", "edited": "(dÃ¼zenlendi)", "deleted": "Bu mesaj silindi", "pinned": "Sabitlendi", "attachFile": "Dosya Ekle", "sendImage": "Resim GÃ¶nder", "sendGif": "GIF GÃ¶nder", "emoji": "Emoji", "reactions": "Tepkiler", "messageDeleted": "Mesaj silindi", "messageEdited": "Mesaj dÃ¼zenlendi", "deleteConfirm": "Bu mesajÄ± silmek istediÄŸinize emin misiniz?", "typing": "yazÄ±yor...", "typingMultiple": "{{count}} kiÅŸi yazÄ±yor..." };
const server$1 = { "createServer": "Sunucu OluÅŸtur", "serverName": "Sunucu AdÄ±", "serverSettings": "Sunucu AyarlarÄ±", "deleteServer": "Sunucuyu Sil", "leaveServer": "Sunucudan AyrÄ±l", "inviteLink": "Davet BaÄŸlantÄ±sÄ±", "generateInvite": "Davet OluÅŸtur", "inviteCopied": "Davet baÄŸlantÄ±sÄ± kopyalandÄ±!", "joinServer": "Sunucuya KatÄ±l", "serverIcon": "Sunucu Ä°konu", "serverBanner": "Sunucu AfiÅŸi", "overview": "Genel BakÄ±ÅŸ", "createChannel": "Kanal OluÅŸtur", "channelName": "Kanal AdÄ±", "textChannel": "Metin KanalÄ±", "voiceChannel": "Ses KanalÄ±", "categoryName": "Kategori AdÄ±", "createCategory": "Kategori OluÅŸtur", "manageRoles": "Rolleri YÃ¶net", "roleName": "Rol AdÄ±", "roleColor": "Rol Rengi", "createRole": "Rol OluÅŸtur", "deleteConfirm": '"{{name}}" sunucusunu silmek istediÄŸinize emin misiniz? Bu iÅŸlem geri alÄ±namaz.', "leaveConfirm": '"{{name}}" sunucusundan ayrÄ±lmak istediÄŸinize emin misiniz?', "memberCount": "{{count}} Ã¼ye", "onlineCount": "{{count}} Ã§evrimiÃ§i" };
const friends$1 = { "addFriend": "ArkadaÅŸ Ekle", "friendList": "ArkadaÅŸ Listesi", "pending": "Bekleyen", "blocked": "Engellenen", "all": "TÃ¼mÃ¼", "online": "Ã‡evrimiÃ§i", "sendRequest": "Ä°stek GÃ¶nder", "acceptRequest": "Kabul Et", "declineRequest": "Reddet", "removeFriend": "ArkadaÅŸlÄ±ktan Ã‡Ä±kar", "friendRequestSent": "ArkadaÅŸlÄ±k isteÄŸi gÃ¶nderildi!", "friendRequestAccepted": "ArkadaÅŸlÄ±k isteÄŸi kabul edildi!", "noFriends": "HenÃ¼z arkadaÅŸÄ±n yok", "noPending": "Bekleyen istek yok", "startDM": "Mesaj GÃ¶nder" };
const voice$1 = { "joinVoice": "Ses KanalÄ±na KatÄ±l", "leaveVoice": "Ses KanalÄ±ndan AyrÄ±l", "voiceConnected": "Ses BaÄŸlÄ±", "voiceDisconnected": "Ses BaÄŸlantÄ±sÄ± Kesildi", "screenShare": "Ekran PaylaÅŸ", "stopScreenShare": "PaylaÅŸÄ±mÄ± Durdur", "camera": "Kamera", "stopCamera": "KamerayÄ± Kapat", "goLive": "CanlÄ± YayÄ±n BaÅŸlat", "stopLive": "CanlÄ± YayÄ±nÄ± Durdur", "connecting": "BaÄŸlanÄ±yor...", "reconnecting": "Yeniden BaÄŸlanÄ±yor...", "noOneInVoice": "Ses kanalÄ±nda kimse yok" };
const settings$1 = { "userSettings": "KullanÄ±cÄ± AyarlarÄ±", "appearance": "GÃ¶rÃ¼nÃ¼m", "notifications": "Bildirimler", "privacy": "Gizlilik ve GÃ¼venlik", "language": "Dil", "theme": "Tema", "darkTheme": "KaranlÄ±k Tema", "lightTheme": "AydÄ±nlÄ±k Tema", "about": "HakkÄ±nda", "changeAvatar": "AvatarÄ± DeÄŸiÅŸtir", "changeBanner": "AfiÅŸi DeÄŸiÅŸtir", "changeStatus": "Durumu DeÄŸiÅŸtir", "customStatus": "Ã–zel Durum", "accountInfo": "Hesap Bilgileri", "changePassword": "Åžifre DeÄŸiÅŸtir", "deleteAccount": "HesabÄ± Sil", "version": "SÃ¼rÃ¼m" };
const dm$1 = { "directMessages": "Direkt Mesajlar", "newDM": "Yeni Mesaj", "noDMs": "HenÃ¼z DM yok", "startConversation": "Bir sohbet baÅŸlat!" };
const premium$1 = { "premiumStore": "Premium MaÄŸaza", "buyCoins": "Jeton SatÄ±n Al", "yourCoins": "JetonlarÄ±nÄ±z", "purchase": "SatÄ±n Al", "insufficientCoins": "Yetersiz jeton", "purchaseSuccess": "SatÄ±n alma baÅŸarÄ±lÄ±!", "nitro": "Pawscord Nitro", "nitroDesc": "Premium Ã¶zelliklerle Pawscord deneyimini yÃ¼kseltin!" };
const notifications$1 = { "noNotifications": "Bildirim yok", "markAllRead": "TÃ¼mÃ¼nÃ¼ Okundu Ä°ÅŸaretle", "mentionedYou": "sizi etiketledi", "sentMessage": "mesaj gÃ¶nderdi", "friendRequest": "ArkadaÅŸlÄ±k isteÄŸi", "serverInvite": "Sunucu daveti" };
const errors$1 = { "networkError": "AÄŸ hatasÄ±. BaÄŸlantÄ±nÄ±zÄ± kontrol edin.", "serverError": "Sunucu hatasÄ±. LÃ¼tfen tekrar deneyin.", "notFound": "Sayfa bulunamadÄ±", "unauthorized": "Bu iÅŸlem iÃ§in yetkiniz yok", "rateLimited": "Ã‡ok fazla istek. LÃ¼tfen bekleyin.", "fileTooLarge": "Dosya Ã§ok bÃ¼yÃ¼k (maks. {{size}}MB)", "invalidFileType": "GeÃ§ersiz dosya tÃ¼rÃ¼", "sessionExpired": "Oturumunuz sona erdi. LÃ¼tfen tekrar giriÅŸ yapÄ±n." };
const time$1 = { "justNow": "Az Ã¶nce", "minutesAgo": "{{count}} dakika Ã¶nce", "hoursAgo": "{{count}} saat Ã¶nce", "daysAgo": "{{count}} gÃ¼n Ã¶nce", "weeksAgo": "{{count}} hafta Ã¶nce" };
const tr = {
  common: common$1,
  auth: auth$1,
  chat: chat$1,
  server: server$1,
  friends: friends$1,
  voice: voice$1,
  settings: settings$1,
  dm: dm$1,
  premium: premium$1,
  notifications: notifications$1,
  errors: errors$1,
  time: time$1
};
const common = { "loading": "Loading...", "save": "Save", "cancel": "Cancel", "delete": "Delete", "edit": "Edit", "close": "Close", "confirm": "Confirm", "search": "Search", "send": "Send", "copy": "Copy", "copied": "Copied!", "back": "Back", "next": "Next", "yes": "Yes", "no": "No", "ok": "OK", "error": "Error", "success": "Success", "warning": "Warning", "info": "Info", "retry": "Retry", "logout": "Log Out", "settings": "Settings", "profile": "Profile", "online": "Online", "offline": "Offline", "idle": "Idle", "dnd": "Do Not Disturb", "invisible": "Invisible", "members": "Members", "channels": "Channels", "roles": "Roles", "server": "Server", "invite": "Invite", "upload": "Upload", "download": "Download", "mute": "Mute", "unmute": "Unmute", "deafen": "Deafen", "undeafen": "Undeafen", "ban": "Ban", "kick": "Kick", "block": "Block", "unblock": "Unblock", "report": "Report" };
const auth = { "login": "Log In", "register": "Sign Up", "email": "Email", "password": "Password", "confirmPassword": "Confirm Password", "username": "Username", "forgotPassword": "Forgot your password?", "loginWith": "Log in with", "registerWith": "Sign up with", "orContinueWith": "or continue with", "alreadyHaveAccount": "Already have an account?", "dontHaveAccount": "Don't have an account?", "loginSuccess": "Login successful!", "registerSuccess": "Registration successful!", "invalidCredentials": "Invalid email or password", "emailRequired": "Email is required", "passwordRequired": "Password is required", "passwordTooShort": "Password must be at least 8 characters", "passwordsDoNotMatch": "Passwords do not match", "emailAlreadyInUse": "This email is already in use", "usernameAlreadyInUse": "This username is already taken", "verifyEmail": "Verify your email", "verifyEmailSent": "Verification email sent", "twoFactorAuth": "Two-Factor Authentication", "enterCode": "Enter code", "enable2FA": "Enable 2FA", "disable2FA": "Disable 2FA" };
const chat = { "typeMessage": "Type a message...", "editMessage": "Edit Message", "deleteMessage": "Delete Message", "replyTo": "Reply", "pinMessage": "Pin Message", "unpinMessage": "Unpin Message", "threadStart": "Start Thread", "noMessages": "No messages yet", "newMessages": "New messages", "today": "Today", "yesterday": "Yesterday", "edited": "(edited)", "deleted": "This message was deleted", "pinned": "Pinned", "attachFile": "Attach File", "sendImage": "Send Image", "sendGif": "Send GIF", "emoji": "Emoji", "reactions": "Reactions", "messageDeleted": "Message deleted", "messageEdited": "Message edited", "deleteConfirm": "Are you sure you want to delete this message?", "typing": "is typing...", "typingMultiple": "{{count}} people are typing..." };
const server = { "createServer": "Create Server", "serverName": "Server Name", "serverSettings": "Server Settings", "deleteServer": "Delete Server", "leaveServer": "Leave Server", "inviteLink": "Invite Link", "generateInvite": "Generate Invite", "inviteCopied": "Invite link copied!", "joinServer": "Join Server", "serverIcon": "Server Icon", "serverBanner": "Server Banner", "overview": "Overview", "createChannel": "Create Channel", "channelName": "Channel Name", "textChannel": "Text Channel", "voiceChannel": "Voice Channel", "categoryName": "Category Name", "createCategory": "Create Category", "manageRoles": "Manage Roles", "roleName": "Role Name", "roleColor": "Role Color", "createRole": "Create Role", "deleteConfirm": 'Are you sure you want to delete "{{name}}"? This cannot be undone.', "leaveConfirm": 'Are you sure you want to leave "{{name}}"?', "memberCount": "{{count}} members", "onlineCount": "{{count}} online" };
const friends = { "addFriend": "Add Friend", "friendList": "Friend List", "pending": "Pending", "blocked": "Blocked", "all": "All", "online": "Online", "sendRequest": "Send Request", "acceptRequest": "Accept", "declineRequest": "Decline", "removeFriend": "Remove Friend", "friendRequestSent": "Friend request sent!", "friendRequestAccepted": "Friend request accepted!", "noFriends": "No friends yet", "noPending": "No pending requests", "startDM": "Send Message" };
const voice = { "joinVoice": "Join Voice Channel", "leaveVoice": "Leave Voice Channel", "voiceConnected": "Voice Connected", "voiceDisconnected": "Voice Disconnected", "screenShare": "Share Screen", "stopScreenShare": "Stop Sharing", "camera": "Camera", "stopCamera": "Stop Camera", "goLive": "Go Live", "stopLive": "Stop Live", "connecting": "Connecting...", "reconnecting": "Reconnecting...", "noOneInVoice": "No one in voice channel" };
const settings = { "userSettings": "User Settings", "appearance": "Appearance", "notifications": "Notifications", "privacy": "Privacy & Safety", "language": "Language", "theme": "Theme", "darkTheme": "Dark Theme", "lightTheme": "Light Theme", "about": "About", "changeAvatar": "Change Avatar", "changeBanner": "Change Banner", "changeStatus": "Change Status", "customStatus": "Custom Status", "accountInfo": "Account Info", "changePassword": "Change Password", "deleteAccount": "Delete Account", "version": "Version" };
const dm = { "directMessages": "Direct Messages", "newDM": "New Message", "noDMs": "No DMs yet", "startConversation": "Start a conversation!" };
const premium = { "premiumStore": "Premium Store", "buyCoins": "Buy Coins", "yourCoins": "Your Coins", "purchase": "Purchase", "insufficientCoins": "Insufficient coins", "purchaseSuccess": "Purchase successful!", "nitro": "Pawscord Nitro", "nitroDesc": "Upgrade your Pawscord experience with premium features!" };
const notifications = { "noNotifications": "No notifications", "markAllRead": "Mark All as Read", "mentionedYou": "mentioned you", "sentMessage": "sent a message", "friendRequest": "Friend request", "serverInvite": "Server invite" };
const errors = { "networkError": "Network error. Check your connection.", "serverError": "Server error. Please try again.", "notFound": "Page not found", "unauthorized": "You don't have permission for this action", "rateLimited": "Too many requests. Please wait.", "fileTooLarge": "File too large (max {{size}}MB)", "invalidFileType": "Invalid file type", "sessionExpired": "Your session has expired. Please log in again." };
const time = { "justNow": "Just now", "minutesAgo": "{{count}} minutes ago", "hoursAgo": "{{count}} hours ago", "daysAgo": "{{count}} days ago", "weeksAgo": "{{count}} weeks ago" };
const en = {
  common,
  auth,
  chat,
  server,
  friends,
  voice,
  settings,
  dm,
  premium,
  notifications,
  errors,
  time
};
instance.use(Browser).use(initReactI18next).init({
  resources: {
    tr: { translation: tr },
    en: { translation: en }
  },
  fallbackLng: "tr",
  debug: false,
  interpolation: {
    escapeValue: false
    // React already escapes
  },
  detection: {
    order: ["localStorage", "navigator", "htmlTag"],
    lookupLocalStorage: "pawscord_language",
    caches: ["localStorage"]
  }
});
const EnglishHub = lazyWithRetry(() => __vitePreload(() => import("./EnglishHub-G_KHUP-w.js"), true ? __vite__mapDeps([340,1,14,4]) : void 0));
const GrammarQuizPage = lazyWithRetry(() => __vitePreload(() => import("./GrammarQuizPage-DTOgzkom.js"), true ? __vite__mapDeps([341,1,14,4,3,15,0,16]) : void 0));
const EnglishLearningPage = lazyWithRetry(() => __vitePreload(() => import("./EnglishLearningPage-XO_712z8.js"), true ? __vite__mapDeps([342,1,14,3,15,0,4,16]) : void 0));
const CryptoDashboard = lazyWithRetry(() => __vitePreload(() => import("./CryptoDashboard-DtZ_yZ-_.js"), true ? __vite__mapDeps([343,1,14,4,344,3,15,0,16]) : void 0));
const CryptoSignals = lazyWithRetry(() => __vitePreload(() => import("./CryptoSignals-C755l00d.js"), true ? __vite__mapDeps([345,1,4,14,344,3,15,0,16]) : void 0));
const WhitelistGuard = /* @__PURE__ */ __name(({ children }) => {
  const { token, isAuthenticated } = useAuth();
  const [allowed, setAllowed] = reactExports.useState(null);
  const checkedRef = reactExports.useRef(false);
  reactExports.useEffect(() => {
    if (!isAuthenticated || !token) {
      setAllowed(false);
      checkedRef.current = false;
      return;
    }
    if (checkedRef.current) return;
    (async () => {
      try {
        const res = await fetch(`${API_BASE_URL$2}/users/me/`, {
          headers: { "Authorization": `Bearer ${token}` }
        });
        if (res.ok) {
          const data = await res.json();
          setAllowed(!!data.is_whitelisted);
          checkedRef.current = true;
        } else if (res.status === 401) {
          console.warn("âš ï¸ [WhitelistGuard] 401 - waiting for token refresh");
        } else {
          setAllowed(false);
        }
      } catch {
        setAllowed(false);
      }
    })();
  }, [isAuthenticated, token]);
  if (allowed === null) return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", justifyContent: "center", alignItems: "center", height: "100vh", background: "#1e1f22", color: "#f0b232", fontSize: 18 }, children: "â³ Kontrol ediliyor..." });
  if (!allowed) return /* @__PURE__ */ jsxRuntimeExports.jsx(Navigate, { to: "/", replace: true });
  return children;
}, "WhitelistGuard");
const ForgotPasswordPage = lazyWithRetry(() => __vitePreload(() => import("./ForgotPasswordPage-Dvi04eBr.js"), true ? __vite__mapDeps([294,1,4,269,14]) : void 0));
const ResetPasswordPage = lazyWithRetry(() => __vitePreload(() => import("./ResetPasswordPage-C9pWHncF.js"), true ? __vite__mapDeps([295,1,4,14]) : void 0));
const TwoFactorLoginPage = lazyWithRetry(() => __vitePreload(() => import("./TwoFactorLoginPage-DpZIJ5dO.js"), true ? __vite__mapDeps([296,1,14,4,3,15,0,16]) : void 0));
const VerifyEmailPageNew = lazyWithRetry(() => __vitePreload(() => import("./VerifyEmailPage-CPqjRClY.js"), true ? __vite__mapDeps([293,1,4,14]) : void 0));
const PrivacyPolicyPage = lazyWithRetry(() => __vitePreload(() => import("./PrivacyPolicyPage-BdVuT4be.js"), true ? __vite__mapDeps([346,1]) : void 0));
const StorePage = lazyWithRetry(() => __vitePreload(() => import("./StorePage-Cr8dmOoY.js"), true ? __vite__mapDeps([347,1,3,14,15,0,4,16]) : void 0));
const LandingPage = lazyWithRetry(() => __vitePreload(() => import("./LandingPage-CbI7e7j_.js"), true ? __vite__mapDeps([348,1,13,3,14,15,0,4,16,349]) : void 0));
const ReferralProgram = lazyWithRetry(() => __vitePreload(() => import("./ReferralProgram-lkfv9pX0.js"), true ? __vite__mapDeps([350,1,13,3,14,15,0,4,16,351]) : void 0));
const GrowthDashboard = lazyWithRetry(() => __vitePreload(() => import("./GrowthDashboard-DQnhMVeM.js"), true ? __vite__mapDeps([352,1,13,19,16,353]) : void 0));
const ToastDemo = lazyWithRetry(() => __vitePreload(() => import("./ToastDemo-BSh7d2-e.js"), true ? __vite__mapDeps([354,1,3,14,15,0,4,16,355]) : void 0));
const GOOGLE_CLIENT_ID = GOOGLE_WEB_CLIENT_ID;
const RootApp = /* @__PURE__ */ __name(() => {
  reactExports.useEffect(() => {
    const preloadTimer = setTimeout(() => {
      try {
        preloadCriticalChunks();
      } catch (e) {
        console.warn("preloadCriticalChunks error", e);
      }
    }, 500);
    if ("requestIdleCallback" in window) {
      window.requestIdleCallback(() => {
        try {
          prefetchNextChunks();
        } catch (e) {
          console.warn("prefetchNextChunks error", e);
        }
      }, { timeout: 1500 });
    } else {
      const fallbackTimer = setTimeout(() => {
        try {
          prefetchNextChunks();
        } catch (e) {
          console.warn("prefetchNextChunks error", e);
        }
      }, 2e3);
      return () => clearTimeout(fallbackTimer);
    }
    return () => clearTimeout(preloadTimer);
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GoogleOAuthProvider, { clientId: GOOGLE_CLIENT_ID, children: /* @__PURE__ */ jsxRuntimeExports.jsx(AuthProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(GlobalWebSocketProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBoundary, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(HashRouter, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(SignalNotification, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Routes, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/verify/:token", element: /* @__PURE__ */ jsxRuntimeExports.jsx(PageWrapper, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(VerifyEmailPage$1, {}) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/verify-email/:token", element: /* @__PURE__ */ jsxRuntimeExports.jsx(PageWrapper, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(React.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "YÃ¼kleniyor..." }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(VerifyEmailPageNew, { apiBaseUrl: API_BASE_URL$2 }) }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/forgot-password", element: /* @__PURE__ */ jsxRuntimeExports.jsx(PageWrapper, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(React.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "YÃ¼kleniyor..." }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(ForgotPasswordPage, { apiBaseUrl: API_BASE_URL$2 }) }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/reset-password/:token", element: /* @__PURE__ */ jsxRuntimeExports.jsx(PageWrapper, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(React.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "YÃ¼kleniyor..." }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(ResetPasswordPage, { apiBaseUrl: API_BASE_URL$2 }) }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/2fa-login", element: /* @__PURE__ */ jsxRuntimeExports.jsx(PageWrapper, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(React.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "YÃ¼kleniyor..." }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(TwoFactorLoginPage, { apiBaseUrl: API_BASE_URL$2 }) }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/auth/callback", element: /* @__PURE__ */ jsxRuntimeExports.jsx(PageWrapper, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(AuthCallback, { apiBaseUrl: API_URL_BASE_STRING$1 }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/privacy-policy", element: /* @__PURE__ */ jsxRuntimeExports.jsx(React.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { padding: "40px", textAlign: "center", color: "#fff" }, children: "Loading..." }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(PrivacyPolicyPage, {}) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/terms-of-service", element: /* @__PURE__ */ jsxRuntimeExports.jsx(React.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { padding: "40px", textAlign: "center", color: "#fff" }, children: "Loading..." }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(PrivacyPolicyPage, {}) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/store", element: /* @__PURE__ */ jsxRuntimeExports.jsx(React.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { padding: "40px", textAlign: "center", color: "#fff" }, children: "Loading..." }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(StorePage, {}) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/launch", element: /* @__PURE__ */ jsxRuntimeExports.jsx(PageWrapper, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(React.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "YÃ¼kleniyor..." }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(LandingPage, { apiBaseUrl: API_BASE_URL$2 }) }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/referral", element: /* @__PURE__ */ jsxRuntimeExports.jsx(PageWrapper, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(React.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "YÃ¼kleniyor..." }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(ReferralProgram, { apiBaseUrl: API_BASE_URL$2 }) }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/growth-dashboard", element: /* @__PURE__ */ jsxRuntimeExports.jsx(PageWrapper, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(React.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "YÃ¼kleniyor..." }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(GrowthDashboard, { apiBaseUrl: API_BASE_URL$2 }) }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/toast-demo", element: /* @__PURE__ */ jsxRuntimeExports.jsx(PageWrapper, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(React.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "YÃ¼kleniyor..." }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(ToastDemo, {}) }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/invite/:code", element: /* @__PURE__ */ jsxRuntimeExports.jsx(PageWrapper, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(InvitePage, {}) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/spotify-callback", element: /* @__PURE__ */ jsxRuntimeExports.jsx(PageWrapper, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(SpotifyCallback$1, { apiBaseUrl: API_BASE_URL$2 }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/eng-learn", element: /* @__PURE__ */ jsxRuntimeExports.jsx(PageWrapper, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(React.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "YÃ¼kleniyor..." }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(EnglishHub, {}) }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/eng-learn/vocab", element: /* @__PURE__ */ jsxRuntimeExports.jsx(PageWrapper, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(React.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "YÃ¼kleniyor..." }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(EnglishLearningPage, {}) }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/eng-learn/grammar", element: /* @__PURE__ */ jsxRuntimeExports.jsx(PageWrapper, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(React.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "YÃ¼kleniyor..." }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(GrammarQuizPage, {}) }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/eng-learn/voice", element: /* @__PURE__ */ jsxRuntimeExports.jsx(PageWrapper, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(EnglishVoicePractice, { apiBaseUrl: API_BASE_URL$2 }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/eng-learn/pronunciation", element: /* @__PURE__ */ jsxRuntimeExports.jsx(PageWrapper, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(PronunciationPage$1, { apiBaseUrl: API_BASE_URL$2 }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/crypto-analysis", element: /* @__PURE__ */ jsxRuntimeExports.jsx(PageWrapper, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(React.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "YÃ¼kleniyor..." }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(WhitelistGuard, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(CryptoSignals, {}) }) }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/crypto-dashboard-old", element: /* @__PURE__ */ jsxRuntimeExports.jsx(PageWrapper, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(React.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "YÃ¼kleniyor..." }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(CryptoDashboard, {}) }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/*", element: /* @__PURE__ */ jsxRuntimeExports.jsx(App, {}) })
    ] })
  ] }) }) }) }) });
}, "RootApp");
window.addEventListener("unhandledrejection", (event) => {
  const msg = event?.reason?.message || "";
  if (msg.includes("Failed to fetch dynamically imported module") || msg.includes("Loading chunk") || msg.includes("ChunkLoadError")) {
    const RELOAD_KEY2 = "pawscord_chunk_reload";
    const RELOAD_COUNT_KEY2 = "pawscord_chunk_reload_count";
    const lastReload = sessionStorage.getItem(RELOAD_KEY2);
    const reloadCount = parseInt(sessionStorage.getItem(RELOAD_COUNT_KEY2) || "0", 10);
    const now = Date.now();
    if (reloadCount >= 2) {
      console.error("âŒ Chunk reload limiti aÅŸÄ±ldÄ± (2/2). Sonsuz dÃ¶ngÃ¼ engellendi.");
      console.error("ðŸ’¡ LÃ¼tfen Ctrl+Shift+R ile sayfayÄ± tamamen yenileyin.");
      return;
    }
    if (!lastReload || now - parseInt(lastReload, 10) > 1e4) {
      console.warn(`ðŸ”„ Chunk hatasÄ± yakalandÄ±, sayfa yenileniyor... (${reloadCount + 1}/2)`);
      sessionStorage.setItem(RELOAD_KEY2, now.toString());
      sessionStorage.setItem(RELOAD_COUNT_KEY2, (reloadCount + 1).toString());
      event.preventDefault();
      window.location.reload();
    }
  }
});
window.addEventListener("load", () => {
  setTimeout(() => {
    sessionStorage.removeItem("pawscord_chunk_reload_count");
  }, 5e3);
});
const root = ReactDOM$1.createRoot(document.getElementById("root"));
root.render(/* @__PURE__ */ jsxRuntimeExports.jsx(RootApp, {}));
export {
  API_BASE_URL$2 as A,
  Capacitor as C,
  GoogleAuth as G,
  PRODUCTION_URL as P,
  THEMES as T,
  WS_PROTOCOL$1 as W,
  useAuth as a,
  getMediaBase as b,
  GOOGLE_WEB_CLIENT_ID as c,
  confirmDialog as d,
  applyTheme as e,
  useChatStore as f,
  getApiBase as g,
  isEncrypted as h,
  isElectron$1 as i,
  decryptMessage as j,
  useMeasurePerformance as k,
  useDebounce$1 as l,
  logger as m,
  ABSOLUTE_HOST_URL$1 as n,
  useVoice as o,
  useResponsive as p,
  getShortcutKey as q,
  API_HOST$1 as r,
  API_BASE_URL$1 as s,
  toast as t,
  useGlobalWebSocket as u,
  API_URL_BASE_STRING$1 as v,
  WebPlugin as w,
  registerPlugin as x
};
