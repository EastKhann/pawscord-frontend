var w=Object.defineProperty;var i=(e,t)=>w(e,"name",{value:t,configurable:!0});async function A(){const e=await crypto.subtle.generateKey({name:"ECDH",namedCurve:"P-256"},!0,["deriveKey","deriveBits"]);return{publicKey:await p(e.publicKey),privateKey:await l(e.privateKey)}}i(A,"generateIdentityKeyPair");async function k(e,t){const r=await crypto.subtle.generateKey({name:"ECDH",namedCurve:"P-256"},!0,["deriveKey","deriveBits"]),n=await g(r.publicKey),a=await v(n);return{keyId:e,publicKey:await p(r.publicKey),privateKey:await l(r.privateKey),signature:o(a)}}i(k,"generateSignedPreKeyPair");async function x(e=100){const t=[];for(let r=0;r<e;r++){const n=await crypto.subtle.generateKey({name:"ECDH",namedCurve:"P-256"},!0,["deriveKey","deriveBits"]);t.push({keyId:r,publicKey:await p(n.publicKey),privateKey:await l(n.privateKey)})}return t}i(x,"generateOneTimePreKeys");async function p(e){const t=await crypto.subtle.exportKey("jwk",e);return JSON.stringify(t)}i(p,"exportPublicKey");async function l(e){const t=await crypto.subtle.exportKey("jwk",e);return JSON.stringify(t)}i(l,"exportPrivateKey");async function g(e){return await crypto.subtle.exportKey("raw",e)}i(g,"exportPublicKeyBytes");async function m(e){const t=JSON.parse(e);return await crypto.subtle.importKey("jwk",t,{name:"ECDH",namedCurve:"P-256"},!0,[])}i(m,"importPublicKey");async function b(e){const t=JSON.parse(e);return await crypto.subtle.importKey("jwk",t,{name:"ECDH",namedCurve:"P-256"},!0,["deriveKey","deriveBits"])}i(b,"importPrivateKey");async function v(e,t){const r=await crypto.subtle.generateKey({name:"ECDSA",namedCurve:"P-256"},!1,["sign","verify"]);return await crypto.subtle.sign({name:"ECDSA",hash:{name:"SHA-256"}},r.privateKey,e)}i(v,"signData");async function B(e,t){const r=await d(t),n=crypto.getRandomValues(new Uint8Array(12)),a=await crypto.subtle.encrypt({name:"AES-GCM",iv:n},r,h(e));return{ciphertext:o(a),iv:o(n)}}i(B,"encryptMessage");async function _(e,t,r){const n=await d(r),a=await crypto.subtle.decrypt({name:"AES-GCM",iv:c(t)},n,c(e));return C(a)}i(_,"decryptMessage");async function E(e,t){const r=await b(e),n=await m(t),a=await crypto.subtle.deriveBits({name:"ECDH",public:n},r,256);return o(a)}i(E,"deriveSharedSecret");async function d(e){const t=c(e),r=await crypto.subtle.importKey("raw",t,"HKDF",!1,["deriveKey"]);return await crypto.subtle.deriveKey({name:"HKDF",hash:"SHA-256",salt:new Uint8Array([]),info:new Uint8Array([])},r,{name:"AES-GCM",length:256},!1,["encrypt","decrypt"])}i(d,"deriveEncryptionKey");function D(e,t,r){return{rootKey:r,sendingChainKey:null,receivingChainKey:null,sendCounter:0,receiveCounter:0,myRatchetPrivateKey:e,theirRatchetPublicKey:t}}i(D,"initializeRatchet");async function j(e,t){if(t==="send"){e.sendCounter++;const r=await u(e.sendingChainKey||e.rootKey);e.sendingChainKey=r}else{e.receiveCounter++;const r=await u(e.receivingChainKey||e.rootKey);e.receivingChainKey=r}return e}i(j,"ratchetForward");async function H(e,t){const r=e+t,n=await u(r);return P(n).split("").map(s=>parseInt(s,16).toString()).join("").substring(0,60).match(/.{1,5}/g).join(" ")}i(H,"generateSafetyNumber");async function M(e){const t=await crypto.subtle.generateKey({name:"AES-GCM",length:256},!0,["encrypt","decrypt"]),r=await e.arrayBuffer(),n=crypto.getRandomValues(new Uint8Array(12)),a=await crypto.subtle.encrypt({name:"AES-GCM",iv:n},t,r),y=await crypto.subtle.exportKey("jwk",t);return{encryptedFile:new Blob([a],{type:"application/octet-stream"}),fileKey:JSON.stringify(y),iv:o(n),originalFilename:e.name,originalMimeType:e.type}}i(M,"encryptFile");async function I(e,t,r,n,a){const y=JSON.parse(t),s=await crypto.subtle.importKey("jwk",y,{name:"AES-GCM",length:256},!1,["decrypt"]),f=await e.arrayBuffer(),K=await crypto.subtle.decrypt({name:"AES-GCM",iv:c(r)},s,f);return new File([K],n,{type:a})}i(I,"decryptFile");function h(e){return new TextEncoder().encode(e)}i(h,"stringToArrayBuffer");function C(e){return new TextDecoder().decode(e)}i(C,"arrayBufferToString");function o(e){const t=new Uint8Array(e);let r="";for(let n=0;n<t.byteLength;n++)r+=String.fromCharCode(t[n]);return btoa(r)}i(o,"arrayBufferToBase64");function c(e){const t=atob(e),r=new Uint8Array(t.length);for(let n=0;n<t.length;n++)r[n]=t.charCodeAt(n);return r.buffer}i(c,"base64ToArrayBuffer");function P(e){const t=new Uint8Array(e);return Array.from(t).map(r=>r.toString(16).padStart(2,"0")).join("")}i(P,"arrayBufferToHex");async function u(e){const t=new TextEncoder,r=typeof e=="string"?t.encode(e):e;return await crypto.subtle.digest("SHA-256",r)}i(u,"hashData");async function T(e,t,r){try{return localStorage.setItem(`e2ee_identity_private_${e}`,t),localStorage.setItem(`e2ee_signed_pre_key_private_${e}`,r),localStorage.setItem(`e2ee_keys_timestamp_${e}`,Date.now().toString()),!0}catch(n){throw n}}i(T,"storePrivateKeys");async function F(e){try{const t=localStorage.getItem(`e2ee_identity_private_${e}`),r=localStorage.getItem(`e2ee_signed_pre_key_private_${e}`),n=localStorage.getItem(`e2ee_keys_timestamp_${e}`);return!t||!r?null:{username:e,identityPrivateKey:t,signedPreKeyPrivateKey:r,timestamp:parseInt(n)}}catch{return null}}i(F,"getPrivateKeys");async function $(e,t,r){try{const n=await r(`${e}/e2ee/pre-key-bundle/${t}/`);if(!n.ok)throw new Error(`Failed to fetch public keys: ${n.status}`);return await n.json()}catch(n){throw n}}i($,"fetchUserPublicKeys");export{I as decryptFile,_ as decryptMessage,E as deriveSharedSecret,M as encryptFile,B as encryptMessage,$ as fetchUserPublicKeys,A as generateIdentityKeyPair,x as generateOneTimePreKeys,H as generateSafetyNumber,k as generateSignedPreKeyPair,F as getPrivateKeys,D as initializeRatchet,j as ratchetForward,T as storePrivateKeys};
