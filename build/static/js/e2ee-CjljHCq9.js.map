{"version":3,"file":"e2ee-CjljHCq9.js","sources":["../../../src/utils/e2ee.js"],"sourcesContent":["// frontend/src/utils/e2ee.js\n/**\n * E2EE (End-to-End Encryption) Utilities\n * Signal Protocol Implementation (simplified)\n *\n * Uses Web Crypto API for cryptographic operations\n */\n\n// === KEY GENERATION ===\n\n/**\n * Generate Identity Key Pair (Ed25519)\n * Long-term key for user identity\n */\nexport async function generateIdentityKeyPair() {\n    const keyPair = await crypto.subtle.generateKey(\n        {\n            name: \"ECDH\",\n            namedCurve: \"P-256\"\n        },\n        true, // extractable\n        [\"deriveKey\", \"deriveBits\"]\n    );\n\n    return {\n        publicKey: await exportPublicKey(keyPair.publicKey),\n        privateKey: await exportPrivateKey(keyPair.privateKey)\n    };\n}\n\n/**\n * Generate Signed Pre-Key Pair\n * Rotated periodically (every month)\n */\nexport async function generateSignedPreKeyPair(keyId, identityPrivateKey) {\n    const keyPair = await crypto.subtle.generateKey(\n        {\n            name: \"ECDH\",\n            namedCurve: \"P-256\"\n        },\n        true,\n        [\"deriveKey\", \"deriveBits\"]\n    );\n\n    // Sign the public key with identity key\n    const publicKeyBytes = await exportPublicKeyBytes(keyPair.publicKey);\n    const signature = await signData(publicKeyBytes, identityPrivateKey);\n\n    return {\n        keyId,\n        publicKey: await exportPublicKey(keyPair.publicKey),\n        privateKey: await exportPrivateKey(keyPair.privateKey),\n        signature: arrayBufferToBase64(signature)\n    };\n}\n\n/**\n * Generate One-Time Pre-Key Bundle (100 keys)\n */\nexport async function generateOneTimePreKeys(count = 100) {\n    const keys = [];\n\n    for (let i = 0; i < count; i++) {\n        const keyPair = await crypto.subtle.generateKey(\n            {\n                name: \"ECDH\",\n                namedCurve: \"P-256\"\n            },\n            true,\n            [\"deriveKey\", \"deriveBits\"]\n        );\n\n        keys.push({\n            keyId: i,\n            publicKey: await exportPublicKey(keyPair.publicKey),\n            privateKey: await exportPrivateKey(keyPair.privateKey)\n        });\n    }\n\n    return keys;\n}\n\n// === KEY EXPORT/IMPORT ===\n\nasync function exportPublicKey(publicKey) {\n    const exported = await crypto.subtle.exportKey(\"jwk\", publicKey);\n    return JSON.stringify(exported);\n}\n\nasync function exportPrivateKey(privateKey) {\n    const exported = await crypto.subtle.exportKey(\"jwk\", privateKey);\n    return JSON.stringify(exported);\n}\n\nasync function exportPublicKeyBytes(publicKey) {\n    const exported = await crypto.subtle.exportKey(\"raw\", publicKey);\n    return exported;\n}\n\nasync function importPublicKey(publicKeyJWK) {\n    const jwk = JSON.parse(publicKeyJWK);\n    return await crypto.subtle.importKey(\n        \"jwk\",\n        jwk,\n        { name: \"ECDH\", namedCurve: \"P-256\" },\n        true,\n        []\n    );\n}\n\nasync function importPrivateKey(privateKeyJWK) {\n    const jwk = JSON.parse(privateKeyJWK);\n    return await crypto.subtle.importKey(\n        \"jwk\",\n        jwk,\n        { name: \"ECDH\", namedCurve: \"P-256\" },\n        true,\n        [\"deriveKey\", \"deriveBits\"]\n    );\n}\n\n// === SIGNING & VERIFICATION ===\n\nasync function signData(data, privateKeyJWK) {\n    // For signing, we use ECDSA (not ECDH)\n    const signingKeyPair = await crypto.subtle.generateKey(\n        {\n            name: \"ECDSA\",\n            namedCurve: \"P-256\"\n        },\n        false,\n        [\"sign\", \"verify\"]\n    );\n\n    return await crypto.subtle.sign(\n        {\n            name: \"ECDSA\",\n            hash: { name: \"SHA-256\" }\n        },\n        signingKeyPair.privateKey,\n        data\n    );\n}\n\n// === ENCRYPTION/DECRYPTION ===\n\n/**\n * Encrypt message with shared secret\n */\nexport async function encryptMessage(plaintext, sharedSecret) {\n    // Derive encryption key from shared secret\n    const encryptionKey = await deriveEncryptionKey(sharedSecret);\n\n    // Generate random IV\n    const iv = crypto.getRandomValues(new Uint8Array(12));\n\n    // Encrypt\n    const ciphertext = await crypto.subtle.encrypt(\n        {\n            name: \"AES-GCM\",\n            iv: iv\n        },\n        encryptionKey,\n        stringToArrayBuffer(plaintext)\n    );\n\n    return {\n        ciphertext: arrayBufferToBase64(ciphertext),\n        iv: arrayBufferToBase64(iv)\n    };\n}\n\n/**\n * Decrypt message with shared secret\n */\nexport async function decryptMessage(ciphertext, iv, sharedSecret) {\n    // Derive encryption key from shared secret\n    const encryptionKey = await deriveEncryptionKey(sharedSecret);\n\n    // Decrypt\n    const plaintext = await crypto.subtle.decrypt(\n        {\n            name: \"AES-GCM\",\n            iv: base64ToArrayBuffer(iv)\n        },\n        encryptionKey,\n        base64ToArrayBuffer(ciphertext)\n    );\n\n    return arrayBufferToString(plaintext);\n}\n\n// === SHARED SECRET DERIVATION (ECDH) ===\n\n/**\n * Perform ECDH key agreement\n */\nexport async function deriveSharedSecret(myPrivateKey, theirPublicKey) {\n    const myPrivateKeyCrypto = await importPrivateKey(myPrivateKey);\n    const theirPublicKeyCrypto = await importPublicKey(theirPublicKey);\n\n    const sharedSecret = await crypto.subtle.deriveBits(\n        {\n            name: \"ECDH\",\n            public: theirPublicKeyCrypto\n        },\n        myPrivateKeyCrypto,\n        256 // 256 bits\n    );\n\n    return arrayBufferToBase64(sharedSecret);\n}\n\n/**\n * Derive encryption key from shared secret using HKDF\n */\nasync function deriveEncryptionKey(sharedSecret) {\n    const sharedSecretBuffer = base64ToArrayBuffer(sharedSecret);\n\n    // Import as raw key material\n    const keyMaterial = await crypto.subtle.importKey(\n        \"raw\",\n        sharedSecretBuffer,\n        \"HKDF\",\n        false,\n        [\"deriveKey\"]\n    );\n\n    // Derive AES-GCM key\n    const encryptionKey = await crypto.subtle.deriveKey(\n        {\n            name: \"HKDF\",\n            hash: \"SHA-256\",\n            salt: new Uint8Array([]), // No salt for simplicity\n            info: new Uint8Array([])\n        },\n        keyMaterial,\n        {\n            name: \"AES-GCM\",\n            length: 256\n        },\n        false,\n        [\"encrypt\", \"decrypt\"]\n    );\n\n    return encryptionKey;\n}\n\n// === DOUBLE RATCHET (Simplified) ===\n\n/**\n * Initialize ratchet state for new conversation\n */\nexport function initializeRatchet(myPrivateKey, theirPublicKey, sharedSecret) {\n    return {\n        rootKey: sharedSecret,\n        sendingChainKey: null,\n        receivingChainKey: null,\n        sendCounter: 0,\n        receiveCounter: 0,\n        myRatchetPrivateKey: myPrivateKey,\n        theirRatchetPublicKey: theirPublicKey\n    };\n}\n\n/**\n * Ratchet forward (after sending/receiving message)\n */\nexport async function ratchetForward(ratchetState, direction) {\n    if (direction === 'send') {\n        // Increment send counter\n        ratchetState.sendCounter++;\n\n        // Derive new chain key (simplified - should use KDF)\n        const newChainKey = await hashData(ratchetState.sendingChainKey || ratchetState.rootKey);\n        ratchetState.sendingChainKey = newChainKey;\n    } else {\n        // Increment receive counter\n        ratchetState.receiveCounter++;\n\n        // Derive new chain key\n        const newChainKey = await hashData(ratchetState.receivingChainKey || ratchetState.rootKey);\n        ratchetState.receivingChainKey = newChainKey;\n    }\n\n    return ratchetState;\n}\n\n// === SAFETY NUMBER ===\n\n/**\n * Generate safety number (fingerprint of identity keys)\n */\nexport async function generateSafetyNumber(myIdentityKey, theirIdentityKey) {\n    const combined = myIdentityKey + theirIdentityKey;\n    const hash = await hashData(combined);\n\n    // Convert to 60-digit number\n    const hex = arrayBufferToHex(hash);\n    const digits = hex.split('').map(c => parseInt(c, 16).toString()).join('').substring(0, 60);\n\n    // Format: 12 groups of 5 digits\n    return digits.match(/.{1,5}/g).join(' ');\n}\n\n// === FILE ENCRYPTION ===\n\n/**\n * Encrypt file (for attachments)\n */\nexport async function encryptFile(file) {\n    // Generate random file encryption key\n    const fileKey = await crypto.subtle.generateKey(\n        {\n            name: \"AES-GCM\",\n            length: 256\n        },\n        true,\n        [\"encrypt\", \"decrypt\"]\n    );\n\n    // Read file\n    const fileBuffer = await file.arrayBuffer();\n\n    // Encrypt\n    const iv = crypto.getRandomValues(new Uint8Array(12));\n    const encryptedBuffer = await crypto.subtle.encrypt(\n        {\n            name: \"AES-GCM\",\n            iv: iv\n        },\n        fileKey,\n        fileBuffer\n    );\n\n    // Export file key\n    const exportedKey = await crypto.subtle.exportKey(\"jwk\", fileKey);\n\n    return {\n        encryptedFile: new Blob([encryptedBuffer], { type: 'application/octet-stream' }),\n        fileKey: JSON.stringify(exportedKey),\n        iv: arrayBufferToBase64(iv),\n        originalFilename: file.name,\n        originalMimeType: file.type\n    };\n}\n\n/**\n * Decrypt file\n */\nexport async function decryptFile(encryptedBlob, fileKeyJWK, iv, filename, mimeType) {\n    // Import file key\n    const jwk = JSON.parse(fileKeyJWK);\n    const fileKey = await crypto.subtle.importKey(\n        \"jwk\",\n        jwk,\n        { name: \"AES-GCM\", length: 256 },\n        false,\n        [\"decrypt\"]\n    );\n\n    // Decrypt\n    const encryptedBuffer = await encryptedBlob.arrayBuffer();\n    const decryptedBuffer = await crypto.subtle.decrypt(\n        {\n            name: \"AES-GCM\",\n            iv: base64ToArrayBuffer(iv)\n        },\n        fileKey,\n        encryptedBuffer\n    );\n\n    return new File([decryptedBuffer], filename, { type: mimeType });\n}\n\n// === UTILITY FUNCTIONS ===\n\nfunction stringToArrayBuffer(str) {\n    const encoder = new TextEncoder();\n    return encoder.encode(str);\n}\n\nfunction arrayBufferToString(buffer) {\n    const decoder = new TextDecoder();\n    return decoder.decode(buffer);\n}\n\nfunction arrayBufferToBase64(buffer) {\n    const bytes = new Uint8Array(buffer);\n    let binary = '';\n    for (let i = 0; i < bytes.byteLength; i++) {\n        binary += String.fromCharCode(bytes[i]);\n    }\n    return btoa(binary);\n}\n\nfunction base64ToArrayBuffer(base64) {\n    const binary = atob(base64);\n    const bytes = new Uint8Array(binary.length);\n    for (let i = 0; i < binary.length; i++) {\n        bytes[i] = binary.charCodeAt(i);\n    }\n    return bytes.buffer;\n}\n\nfunction arrayBufferToHex(buffer) {\n    const bytes = new Uint8Array(buffer);\n    return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');\n}\n\nasync function hashData(data) {\n    const encoder = new TextEncoder();\n    const dataBuffer = typeof data === 'string' ? encoder.encode(data) : data;\n    return await crypto.subtle.digest(\"SHA-256\", dataBuffer);\n}\n\n// === STORAGE (IndexedDB for private keys) ===\n\n/**\n * Store private keys securely in localStorage (simplified)\n * NEVER send private keys to server!\n * In production, use IndexedDB with encryption\n */\nexport async function storePrivateKeys(username, identityPrivateKey, signedPreKeyPrivateKey) {\n    try {\n        localStorage.setItem(`e2ee_identity_private_${username}`, identityPrivateKey);\n        localStorage.setItem(`e2ee_signed_pre_key_private_${username}`, signedPreKeyPrivateKey);\n        localStorage.setItem(`e2ee_keys_timestamp_${username}`, Date.now().toString());\n        return true;\n    } catch (err) {\n        console.error('❌ Failed to store private keys:', err);\n        throw err;\n    }\n}\n\n/**\n * Retrieve private keys from localStorage\n */\nexport async function getPrivateKeys(username) {\n    try {\n        const identityPrivateKey = localStorage.getItem(`e2ee_identity_private_${username}`);\n        const signedPreKeyPrivateKey = localStorage.getItem(`e2ee_signed_pre_key_private_${username}`);\n        const timestamp = localStorage.getItem(`e2ee_keys_timestamp_${username}`);\n\n        if (!identityPrivateKey || !signedPreKeyPrivateKey) {\n            return null;\n        }\n\n        return {\n            username,\n            identityPrivateKey,\n            signedPreKeyPrivateKey,\n            timestamp: parseInt(timestamp)\n        };\n    } catch (err) {\n        console.error('❌ Failed to retrieve private keys:', err);\n        return null;\n    }\n}\n\n/**\n * Fetch user's public key bundle from server\n */\nexport async function fetchUserPublicKeys(apiBaseUrl, targetUser, fetchWithAuth) {\n    try {\n        const response = await fetchWithAuth(\n            `${apiBaseUrl}/e2ee/pre-key-bundle/${targetUser}/`\n        );\n        \n        if (!response.ok) {\n            throw new Error(`Failed to fetch public keys: ${response.status}`);\n        }\n        \n        return await response.json();\n    } catch (err) {\n        console.error('❌ Failed to fetch user public keys:', err);\n        throw err;\n    }\n}\n\n\n\n\n"],"names":[],"mappings":"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"}