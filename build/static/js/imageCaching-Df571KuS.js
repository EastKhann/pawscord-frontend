var v=Object.defineProperty;var i=(s,t)=>v(s,"name",{value:t,configurable:!0});import{a as w}from"./react-core-Djgtqrmb.js";const y="pawscord-image-cache",S="v1",C=50*1024*1024,z=10080*60*1e3,o=new Map,m=new Map,u=class u{constructor(){this.cache=new Map,this.loadFromLocalStorage()}loadFromLocalStorage(){try{const t=localStorage.getItem(`${y}-${S}`);if(t){const a=JSON.parse(t);Object.entries(a).forEach(([e,c])=>{this.isValidCacheEntry(c)&&this.cache.set(e,c)})}}catch{this.clearCache()}}saveToLocalStorage(){try{const t=Object.fromEntries(this.cache);localStorage.setItem(`${y}-${S}`,JSON.stringify(t))}catch{this.pruneCache()}}isValidCacheEntry(t){return!t||!t.timestamp?!1:Date.now()-t.timestamp<z}async get(t){const a=this.cache.get(t);return a&&this.isValidCacheEntry(a)?(a.lastAccessed=Date.now(),this.saveToLocalStorage(),a.data):(a&&this.cache.delete(t),null)}async set(t,a){const e=this.getCacheSize(),c=new Blob([a]).size;e+c>C&&this.pruneCache(),this.cache.set(t,{data:a,timestamp:Date.now(),lastAccessed:Date.now(),size:c}),this.saveToLocalStorage()}getCacheSize(){let t=0;return this.cache.forEach(a=>{t+=a.size||0}),t}pruneCache(){const t=Array.from(this.cache.entries());t.sort((e,c)=>e[1].lastAccessed-c[1].lastAccessed);const a=Math.ceil(t.length*.3);for(let e=0;e<a;e++)this.cache.delete(t[e][0]);this.saveToLocalStorage()}clearCache(){this.cache.clear();try{localStorage.removeItem(`${y}-${S}`)}catch{}}async prefetch(t){const a=t.map(async e=>{if(!this.cache.has(e))try{const n=await(await fetch(e)).blob(),l=await this.blobToDataUrl(n);await this.set(e,l)}catch{}});await Promise.allSettled(a)}blobToDataUrl(t){return new Promise((a,e)=>{const c=new FileReader;c.onload=()=>a(c.result),c.onerror=e,c.readAsDataURL(t)})}getStats(){return{entries:this.cache.size,size:this.getCacheSize(),maxSize:C,usage:(this.getCacheSize()/C*100).toFixed(2)+"%",oldestEntry:Math.min(...Array.from(this.cache.values()).map(t=>t.timestamp)),newestEntry:Math.max(...Array.from(this.cache.values()).map(t=>t.timestamp))}}};i(u,"ImageCache");let b=u;const h=new b,D=i(s=>{const[t,a]=w.useState(()=>s&&o.has(s)?o.get(s):null),[e,c]=w.useState(!t),[n,l]=w.useState(null);return w.useEffect(()=>{let f=!1;return i(async()=>{if(!s){c(!1);return}if(o.has(s)){a(o.get(s)),c(!1);return}if(m.has(s)){try{const r=await m.get(s);f||(a(r),c(!1))}catch(r){f||(l(r),a(s),c(!1))}return}const g=(async()=>{try{c(!0);const r=await h.get(s);if(r)return o.set(s,r),r;const d=await fetch(s);if(!d.ok)throw new Error("Image fetch failed");const E=await d.blob(),p=await h.blobToDataUrl(E);return await h.set(s,p),o.set(s,p),p}finally{m.delete(s)}})();m.set(s,g);try{const r=await g;f||(a(r),c(!1))}catch(r){f||(l(r),a(s),c(!1))}},"loadImage")(),()=>{f=!0}},[s]),{url:t,loading:e,error:n}},"useCachedImage"),M=i(async s=>{const a={profile:["/avatars/cat_1.png"],home:["/static/logo.png"]}[s]||[];await h.prefetch(a)},"prefetchRouteImages"),$=i(()=>{h.clearCache(),o.clear(),m.clear()},"clearImageCache"),L=i(()=>({...h.getStats(),inMemoryCount:o.size,pendingLoads:m.size}),"getImageCacheStats"),_=i(async s=>{if(!s||!Array.isArray(s))return;const t=s.map(e=>e.avatar_url||e.avatar).filter(e=>e&&typeof e=="string"&&e.startsWith("http")).filter(e=>!o.has(e));if(t.length===0)return;const a=5;for(let e=0;e<t.length;e+=a){const c=t.slice(e,e+a);await Promise.allSettled(c.map(async n=>{if(!o.has(n))try{const l=await h.get(n);if(l){o.set(n,l);return}const f=`?_=${Date.now()}`,A=n.includes("?")?`${n}&_=${Date.now()}`:`${n}${f}`,g=await fetch(A,{mode:"cors",cache:"no-cache"});if(!g.ok)return;const r=await g.blob(),d=await h.blobToDataUrl(r);await h.set(n,d),o.set(n,d)}catch{}}))}},"prefetchUserAvatars"),T=i(s=>s&&o.get(s)||null,"getAvatarFromCache");export{$ as clearImageCache,h as default,T as getAvatarFromCache,L as getImageCacheStats,M as prefetchRouteImages,_ as prefetchUserAvatars,D as useCachedImage};
