import{d}from"./react-core-DMT_QkRe.js";const p="pawscord-image-cache",C="v1",S=50*1024*1024,u=10080*60*1e3,r=new Map,g=new Map;class A{constructor(){this.cache=new Map,this.loadFromLocalStorage()}loadFromLocalStorage(){try{const e=localStorage.getItem(`${p}-${C}`);if(e){const a=JSON.parse(e);Object.entries(a).forEach(([t,c])=>{this.isValidCacheEntry(c)&&this.cache.set(t,c)})}}catch(e){console.warn("[ImageCache] Failed to load from localStorage:",e),this.clearCache()}}saveToLocalStorage(){try{const e=Object.fromEntries(this.cache);localStorage.setItem(`${p}-${C}`,JSON.stringify(e))}catch{console.warn("[ImageCache] localStorage full, clearing old entries"),this.pruneCache()}}isValidCacheEntry(e){return!e||!e.timestamp?!1:Date.now()-e.timestamp<u}async get(e){const a=this.cache.get(e);return a&&this.isValidCacheEntry(a)?(a.lastAccessed=Date.now(),this.saveToLocalStorage(),a.data):(a&&this.cache.delete(e),null)}async set(e,a){const t=this.getCacheSize(),c=new Blob([a]).size;t+c>S&&this.pruneCache(),this.cache.set(e,{data:a,timestamp:Date.now(),lastAccessed:Date.now(),size:c}),this.saveToLocalStorage()}getCacheSize(){let e=0;return this.cache.forEach(a=>{e+=a.size||0}),e}pruneCache(){const e=Array.from(this.cache.entries());e.sort((t,c)=>t[1].lastAccessed-c[1].lastAccessed);const a=Math.ceil(e.length*.3);for(let t=0;t<a;t++)this.cache.delete(e[t][0]);this.saveToLocalStorage()}clearCache(){this.cache.clear();try{localStorage.removeItem(`${p}-${C}`)}catch(e){console.warn("[ImageCache] Failed to clear localStorage:",e)}}async prefetch(e){const a=e.map(async t=>{if(!this.cache.has(t))try{const n=await(await fetch(t)).blob(),h=await this.blobToDataUrl(n);await this.set(t,h)}catch(c){console.warn("[ImageCache] Failed to prefetch:",t,c)}});await Promise.allSettled(a)}blobToDataUrl(e){return new Promise((a,t)=>{const c=new FileReader;c.onload=()=>a(c.result),c.onerror=t,c.readAsDataURL(e)})}getStats(){return{entries:this.cache.size,size:this.getCacheSize(),maxSize:S,usage:(this.getCacheSize()/S*100).toFixed(2)+"%",oldestEntry:Math.min(...Array.from(this.cache.values()).map(e=>e.timestamp)),newestEntry:Math.max(...Array.from(this.cache.values()).map(e=>e.timestamp))}}}const i=new A,E=s=>{const[e,a]=d.useState(()=>s&&r.has(s)?r.get(s):null),[t,c]=d.useState(!e),[n,h]=d.useState(null);return d.useEffect(()=>{let l=!1;return(async()=>{if(!s){c(!1);return}if(r.has(s)){a(r.get(s)),c(!1);return}if(g.has(s)){try{const o=await g.get(s);l||(a(o),c(!1))}catch(o){l||(h(o),a(s),c(!1))}return}const f=(async()=>{try{c(!0);const o=await i.get(s);if(o)return r.set(s,o),o;const m=await fetch(s);if(!m.ok)throw new Error("Image fetch failed");const b=await m.blob(),w=await i.blobToDataUrl(b);return await i.set(s,w),r.set(s,w),w}finally{g.delete(s)}})();g.set(s,f);try{const o=await f;l||(a(o),c(!1))}catch(o){l||(h(o),a(s),c(!1))}})(),()=>{l=!0}},[s]),{url:e,loading:t,error:n}},I=async s=>{const a={profile:["/avatars/cat_1.png"],home:["/static/logo.png"]}[s]||[];await i.prefetch(a)},z=()=>{i.clearCache(),r.clear(),g.clear()},U=()=>({...i.getStats(),inMemoryCount:r.size,pendingLoads:g.size}),$=async s=>{if(!s||!Array.isArray(s))return;const e=s.map(t=>t.avatar_url||t.avatar).filter(t=>t&&typeof t=="string"&&t.startsWith("http")).filter(t=>!r.has(t));if(e.length===0)return;console.log(`üñºÔ∏è [AvatarCache] Prefetching ${e.length} avatars...`);const a=5;for(let t=0;t<e.length;t+=a){const c=e.slice(t,t+a);await Promise.allSettled(c.map(async n=>{if(!r.has(n))try{const h=await i.get(n);if(h){r.set(n,h);return}const l=`?_=${Date.now()}`,y=n.includes("?")?`${n}&_=${Date.now()}`:`${n}${l}`,f=await fetch(y,{mode:"cors",cache:"no-cache"});if(!f.ok)return;const o=await f.blob(),m=await i.blobToDataUrl(o);await i.set(n,m),r.set(n,m)}catch{}}))}console.log(`‚úÖ [AvatarCache] Prefetch complete. Memory cache: ${r.size} items`)},M=s=>s&&r.get(s)||null;export{z as clearImageCache,i as default,M as getAvatarFromCache,U as getImageCacheStats,I as prefetchRouteImages,$ as prefetchUserAvatars,E as useCachedImage};
