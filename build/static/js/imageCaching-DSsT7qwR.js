import{a as d}from"./react-core-D6cE4lil.js";const p="pawscord-image-cache",C="v1",y=50*1024*1024,u=10080*60*1e3,o=new Map,f=new Map;class A{constructor(){this.cache=new Map,this.loadFromLocalStorage()}loadFromLocalStorage(){try{const e=localStorage.getItem(`${p}-${C}`);if(e){const a=JSON.parse(e);Object.entries(a).forEach(([t,c])=>{this.isValidCacheEntry(c)&&this.cache.set(t,c)})}}catch{this.clearCache()}}saveToLocalStorage(){try{const e=Object.fromEntries(this.cache);localStorage.setItem(`${p}-${C}`,JSON.stringify(e))}catch{this.pruneCache()}}isValidCacheEntry(e){return!e||!e.timestamp?!1:Date.now()-e.timestamp<u}async get(e){const a=this.cache.get(e);return a&&this.isValidCacheEntry(a)?(a.lastAccessed=Date.now(),this.saveToLocalStorage(),a.data):(a&&this.cache.delete(e),null)}async set(e,a){const t=this.getCacheSize(),c=new Blob([a]).size;t+c>y&&this.pruneCache(),this.cache.set(e,{data:a,timestamp:Date.now(),lastAccessed:Date.now(),size:c}),this.saveToLocalStorage()}getCacheSize(){let e=0;return this.cache.forEach(a=>{e+=a.size||0}),e}pruneCache(){const e=Array.from(this.cache.entries());e.sort((t,c)=>t[1].lastAccessed-c[1].lastAccessed);const a=Math.ceil(e.length*.3);for(let t=0;t<a;t++)this.cache.delete(e[t][0]);this.saveToLocalStorage()}clearCache(){this.cache.clear();try{localStorage.removeItem(`${p}-${C}`)}catch{}}async prefetch(e){const a=e.map(async t=>{if(!this.cache.has(t))try{const n=await(await fetch(t)).blob(),h=await this.blobToDataUrl(n);await this.set(t,h)}catch{}});await Promise.allSettled(a)}blobToDataUrl(e){return new Promise((a,t)=>{const c=new FileReader;c.onload=()=>a(c.result),c.onerror=t,c.readAsDataURL(e)})}getStats(){return{entries:this.cache.size,size:this.getCacheSize(),maxSize:y,usage:(this.getCacheSize()/y*100).toFixed(2)+"%",oldestEntry:Math.min(...Array.from(this.cache.values()).map(e=>e.timestamp)),newestEntry:Math.max(...Array.from(this.cache.values()).map(e=>e.timestamp))}}}const i=new A,v=s=>{const[e,a]=d.useState(()=>s&&o.has(s)?o.get(s):null),[t,c]=d.useState(!e),[n,h]=d.useState(null);return d.useEffect(()=>{let l=!1;return(async()=>{if(!s){c(!1);return}if(o.has(s)){a(o.get(s)),c(!1);return}if(f.has(s)){try{const r=await f.get(s);l||(a(r),c(!1))}catch(r){l||(h(r),a(s),c(!1))}return}const m=(async()=>{try{c(!0);const r=await i.get(s);if(r)return o.set(s,r),r;const g=await fetch(s);if(!g.ok)throw new Error("Image fetch failed");const b=await g.blob(),w=await i.blobToDataUrl(b);return await i.set(s,w),o.set(s,w),w}finally{f.delete(s)}})();f.set(s,m);try{const r=await m;l||(a(r),c(!1))}catch(r){l||(h(r),a(s),c(!1))}})(),()=>{l=!0}},[s]),{url:e,loading:t,error:n}},z=async s=>{const a={profile:["/avatars/cat_1.png"],home:["/static/logo.png"]}[s]||[];await i.prefetch(a)},I=()=>{i.clearCache(),o.clear(),f.clear()},U=()=>({...i.getStats(),inMemoryCount:o.size,pendingLoads:f.size}),D=async s=>{if(!s||!Array.isArray(s))return;const e=s.map(t=>t.avatar_url||t.avatar).filter(t=>t&&typeof t=="string"&&t.startsWith("http")).filter(t=>!o.has(t));if(e.length===0)return;const a=5;for(let t=0;t<e.length;t+=a){const c=e.slice(t,t+a);await Promise.allSettled(c.map(async n=>{if(!o.has(n))try{const h=await i.get(n);if(h){o.set(n,h);return}const l=`?_=${Date.now()}`,S=n.includes("?")?`${n}&_=${Date.now()}`:`${n}${l}`,m=await fetch(S,{mode:"cors",cache:"no-cache"});if(!m.ok)return;const r=await m.blob(),g=await i.blobToDataUrl(r);await i.set(n,g),o.set(n,g)}catch{}}))}},M=s=>s&&o.get(s)||null;export{I as clearImageCache,i as default,M as getAvatarFromCache,U as getImageCacheStats,z as prefetchRouteImages,D as prefetchUserAvatars,v as useCachedImage};
